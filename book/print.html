<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dgraph中文文档</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> 预览</a></li><li class="chapter-item expanded "><a href="graphql/overview.html"><strong aria-hidden="true">2.</strong> GraphQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dgraphql/overview.html"><strong aria-hidden="true">2.1.</strong> 预览</a></li><li class="chapter-item expanded "><a href="dgraphql/quick_start.html"><strong aria-hidden="true">2.2.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="graphql/how_graphql_works_in_dgraph.html"><strong aria-hidden="true">2.3.</strong> GraphQl 是如何运行在 Dgraph 中的</a></li><li class="chapter-item expanded "><a href="graphql/todo_list_app_tutorial/overview.html"><strong aria-hidden="true">2.4.</strong> TODO List示例应用的开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphql/todo_list_app_tutorial/overview.html"><strong aria-hidden="true">2.4.1.</strong> 预览</a></li><li class="chapter-item expanded "><a href="graphql/todo_list_app_tutorial/schema_design.html"><strong aria-hidden="true">2.4.2.</strong> Schema 设计</a></li><li class="chapter-item expanded "><a href="graphql/todo_list_app_tutorial/creating_a_basic_ui.html"><strong aria-hidden="true">2.4.3.</strong> 创建基本的UI界面</a></li><li class="chapter-item expanded "><a href="graphql/todo_list_app_tutorial/authorization_rules.html"><strong aria-hidden="true">2.4.4.</strong> 添加认证</a></li><li class="chapter-item expanded "><a href="graphql/todo_list_app_tutorial/using_auth0.html"><strong aria-hidden="true">2.4.5.</strong> 使用 Auth0 颁发 Token</a></li><li class="chapter-item expanded "><a href="graphql/todo_list_app_tutorial/using_firebase_authentication.html"><strong aria-hidden="true">2.4.6.</strong> 使用 Firebase 认证</a></li><li class="chapter-item expanded "><a href="graphql/deploying_on_dgraph_cloud.html"><strong aria-hidden="true">2.4.7.</strong> 部署到 Dgraph 云</a></li></ol></li><li class="chapter-item expanded "><a href="graphql/authorization/overview.html"><strong aria-hidden="true">2.5.</strong> 认证</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphql/auth_directive.html"><strong aria-hidden="true">2.5.1.</strong> @auth 动词</a></li><li class="chapter-item expanded "><a href="graphql/mutations.html"><strong aria-hidden="true">2.5.2.</strong> 在变更中使用 @auth 动词</a></li></ol></li><li class="chapter-item expanded "><a href="api/overview.html"><strong aria-hidden="true">2.6.</strong> API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/overview.html"><strong aria-hidden="true">2.6.1.</strong> 预览</a></li><li class="chapter-item expanded "><a href="api/requests_and_responses.html"><strong aria-hidden="true">2.6.2.</strong> 请求和请求响应</a></li><li class="chapter-item expanded "><a href="api/graphql_variables.html"><strong aria-hidden="true">2.6.3.</strong> GraphQL 变量</a></li><li class="chapter-item expanded "><a href="api/graphql_fragment.html"><strong aria-hidden="true">2.6.4.</strong> GraphQL 片段</a></li><li class="chapter-item expanded "><a href="api/multiple_graphql_operations_in_a_request.html"><strong aria-hidden="true">2.6.5.</strong> 一次请求多次操作</a></li><li class="chapter-item expanded "><a href="api/graphql_errors.html"><strong aria-hidden="true">2.6.6.</strong> GraphQL 错误</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="dql/overview.html"><strong aria-hidden="true">3.</strong> DQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dql/get_started.html"><strong aria-hidden="true">3.1.</strong> 开始</a></li><li class="chapter-item expanded "><a href="dql/tutorials.html"><strong aria-hidden="true">3.2.</strong> 手册</a></li><li class="chapter-item expanded "><a href="dql/query_language/dql_fundamentals.html"><strong aria-hidden="true">3.3.</strong> 查询</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dql/query_language/dql_fundamentals.html"><strong aria-hidden="true">3.3.1.</strong> DQL基础</a></li><li class="chapter-item expanded "><a href="dql/query_language/functions.html"><strong aria-hidden="true">3.3.2.</strong> 函数</a></li><li class="chapter-item expanded "><a href="dql/query_language/connecting_filters.html"><strong aria-hidden="true">3.3.3.</strong> 联合过滤</a></li><li class="chapter-item expanded "><a href="dql/query_language/aliases.html"><strong aria-hidden="true">3.3.4.</strong> 别名</a></li><li class="chapter-item expanded "><a href="dql/query_language/paging.html"><strong aria-hidden="true">3.3.5.</strong> 分页</a></li><li class="chapter-item expanded "><a href="dql/query_language/count.html"><strong aria-hidden="true">3.3.6.</strong> 计算总数</a></li><li class="chapter-item expanded "><a href="dql/query_language/shorting.html"><strong aria-hidden="true">3.3.7.</strong> 排序</a></li><li class="chapter-item expanded "><a href="dql/query_language/multiple_query_blocks.html"><strong aria-hidden="true">3.3.8.</strong> 多查找块</a></li><li class="chapter-item expanded "><a href="dql/query_language/query_variables.html"><strong aria-hidden="true">3.3.9.</strong> 查询变量</a></li><li class="chapter-item expanded "><a href="dql/query_language/value_variables.html"><strong aria-hidden="true">3.3.10.</strong> 值变量</a></li><li class="chapter-item expanded "><a href="dql/query_language/aggregation.html"><strong aria-hidden="true">3.3.11.</strong> 聚合</a></li><li class="chapter-item expanded "><a href="dql/query_language/math_on_value_variables.html"><strong aria-hidden="true">3.3.12.</strong> 值变量上的数学处理</a></li><li class="chapter-item expanded "><a href="dql/query_language/groupby.html"><strong aria-hidden="true">3.3.13.</strong> 分组</a></li><li class="chapter-item expanded "><a href="dql/query_language/expand_predicates.html"><strong aria-hidden="true">3.3.14.</strong> 展开操作</a></li><li class="chapter-item expanded "><a href="dql/query_language/cascade_directive.html"><strong aria-hidden="true">3.3.15.</strong> 省去操作</a></li><li class="chapter-item expanded "><a href="dql/query_language/normalize.html"><strong aria-hidden="true">3.3.16.</strong> @normalize 正则化</a></li><li class="chapter-item expanded "><a href="dql/query_language/ignorereflex.html"><strong aria-hidden="true">3.3.17.</strong> @ignorereflex</a></li><li class="chapter-item expanded "><a href="dql/query_language/debug.html"><strong aria-hidden="true">3.3.18.</strong> Debug</a></li><li class="chapter-item expanded "><a href="dql/query_language/schema.html"><strong aria-hidden="true">3.3.19.</strong> Schema</a></li><li class="chapter-item expanded "><a href="dql/query_language/type_system.html"><strong aria-hidden="true">3.3.20.</strong> 类型系统</a></li><li class="chapter-item expanded "><a href="dql/query_language/facets_and_edge_attributes.html"><strong aria-hidden="true">3.3.21.</strong> 边属性</a></li><li class="chapter-item expanded "><a href="dql/query_language/shortest_path_query.html"><strong aria-hidden="true">3.3.22.</strong> 最短路径查询</a></li><li class="chapter-item expanded "><a href="dql/query_language/recurse_query.html"><strong aria-hidden="true">3.3.23.</strong> 递归查询</a></li><li class="chapter-item expanded "><a href="dql/query_language/fragment.html"><strong aria-hidden="true">3.3.24.</strong> 片段</a></li><li class="chapter-item expanded "><a href="dql/query_language/graphql_variables.html"><strong aria-hidden="true">3.3.25.</strong> GraphQL变量</a></li><li class="chapter-item expanded "><a href="dql/query_language/indexing_with_custom_tokenizers.html"><strong aria-hidden="true">3.3.26.</strong> 自定义Tokenizers来创建索引</a></li></ol></li><li class="chapter-item expanded "><a href="dql/mutations/triples.html"><strong aria-hidden="true">3.4.</strong> 变更</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dql/mutations/triples.html"><strong aria-hidden="true">3.4.1.</strong> 三元组</a></li><li class="chapter-item expanded "><a href="dql/mutations/blank_nodes_and_uid.html"><strong aria-hidden="true">3.4.2.</strong> 空白node和UID</a></li><li class="chapter-item expanded "><a href="dql/mutations/externals_ids.html"><strong aria-hidden="true">3.4.3.</strong> 外部ID</a></li><li class="chapter-item expanded "><a href="dql/mutations/externals_ids_and_upsert_block.html"><strong aria-hidden="true">3.4.4.</strong> 外部ID和插入块</a></li><li class="chapter-item expanded "><a href="dql/mutations/language_and_rdf_types.html"><strong aria-hidden="true">3.4.5.</strong> 语言和RDF类型</a></li><li class="chapter-item expanded "><a href="dql/mutations/batch_mutations.html"><strong aria-hidden="true">3.4.6.</strong> 批量变更</a></li><li class="chapter-item expanded "><a href="dql/mutations/delete.html"><strong aria-hidden="true">3.4.7.</strong> 删除</a></li><li class="chapter-item expanded "><a href="dql/mutations/facet_list_in_rdf.html"><strong aria-hidden="true">3.4.8.</strong> RDF中的边属性</a></li><li class="chapter-item expanded "><a href="dql/mutations/mutations_using_curl.html"><strong aria-hidden="true">3.4.9.</strong> 使用cURL变更</a></li><li class="chapter-item expanded "><a href="dql/mutations/json_mutation_format.html"><strong aria-hidden="true">3.4.10.</strong> JSON 变更格式</a></li><li class="chapter-item expanded "><a href="dql/mutations/upsert_block.html"><strong aria-hidden="true">3.4.11.</strong> 插入块</a></li><li class="chapter-item expanded "><a href="dql/mutations/conditional_upsert.html"><strong aria-hidden="true">3.4.12.</strong> 条件插入</a></li><li class="chapter-item expanded "><a href="dql/mutations/reverse_edge.html"><strong aria-hidden="true">3.4.13.</strong> 反向边</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="client/overview.html"><strong aria-hidden="true">4.</strong> 客户端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/overview.html"><strong aria-hidden="true">4.1.</strong> 预览</a></li><li class="chapter-item expanded "><a href="client/go.html"><strong aria-hidden="true">4.2.</strong> GO</a></li><li class="chapter-item expanded "><a href="client/c#.html"><strong aria-hidden="true">4.3.</strong> C#</a></li><li class="chapter-item expanded "><a href="client/java.html"><strong aria-hidden="true">4.4.</strong> Java</a></li><li class="chapter-item expanded "><a href="client/javascript/grpc_client.html"><strong aria-hidden="true">4.5.</strong> JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/javascript/grpc_client.html"><strong aria-hidden="true">4.5.1.</strong> gRpc 客户端</a></li><li class="chapter-item expanded "><a href="client/javascript/http_client.html"><strong aria-hidden="true">4.5.2.</strong> HTTP 客户端</a></li></ol></li><li class="chapter-item expanded "><a href="client/python.html"><strong aria-hidden="true">4.6.</strong> Python</a></li><li class="chapter-item expanded "><a href="client/unofficial_dgraph_clients.html"><strong aria-hidden="true">4.7.</strong> 非官方客户端</a></li><li class="chapter-item expanded "><a href="client/raw_http.html"><strong aria-hidden="true">4.8.</strong> 原生HTTP</a></li></ol></li><li class="chapter-item expanded "><a href="ratel_ui/overview.html"><strong aria-hidden="true">5.</strong> Ratel 界面</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ratel_ui/overview.html"><strong aria-hidden="true">5.1.</strong> 预览</a></li><li class="chapter-item expanded "><a href="ratel_ui/connection.html"><strong aria-hidden="true">5.2.</strong> 连接</a></li><li class="chapter-item expanded "><a href="ratel_ui/console.html"><strong aria-hidden="true">5.3.</strong> 控制台</a></li><li class="chapter-item expanded "><a href="ratel_ui/schema.html"><strong aria-hidden="true">5.4.</strong> Schema</a></li><li class="chapter-item expanded "><a href="ratel_ui/cluster.html"><strong aria-hidden="true">5.5.</strong> 集群</a></li><li class="chapter-item expanded "><a href="ratel_ui/backups.html"><strong aria-hidden="true">5.6.</strong> 备份</a></li></ol></li><li class="chapter-item expanded "><a href="deploy_and_manage/overview.html"><strong aria-hidden="true">6.</strong> 部署和管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploy_and_manage/overview.html"><strong aria-hidden="true">6.1.</strong> 预览</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/download.html"><strong aria-hidden="true">6.2.</strong> 下载</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/config.html"><strong aria-hidden="true">6.3.</strong> 配置</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/more_about_dgraph_zero.html"><strong aria-hidden="true">6.4.</strong> 关于 Dgraph Zero 的更多信息</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/more_about_dgraph_alpha.html"><strong aria-hidden="true">6.5.</strong> 关于 Dgraph Alpha 的更多信息</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/single_host_setup.html"><strong aria-hidden="true">6.6.</strong> 单机部署</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/multi_host_setup.html"><strong aria-hidden="true">6.7.</strong> 多机部署</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/using_k8s.html"><strong aria-hidden="true">6.8.</strong> 使用 K8S</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/cluster_setup.html"><strong aria-hidden="true">6.9.</strong> 集群部署</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/cluster_checklist.html"><strong aria-hidden="true">6.10.</strong> 集群部署注意事项</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/production_checklist.html"><strong aria-hidden="true">6.11.</strong> 生产环境注意事项</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/data_decryption.html"><strong aria-hidden="true">6.12.</strong> 数据加密</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/dgraph_cli_reference.html"><strong aria-hidden="true">6.13.</strong> Dgraph 命令行接口使用手册</a></li><li class="chapter-item expanded "><a href="deploy_and_manage/troubleshooting.html"><strong aria-hidden="true">6.14.</strong> 问题解决</a></li></ol></li><li class="chapter-item expanded "><a href="enterprise_features/access_control_lists.html"><strong aria-hidden="true">7.</strong> 付费版特性</a></li><li class="chapter-item expanded "><a href="migration/loading_csv_data.html"><strong aria-hidden="true">8.</strong> 数据迁移</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="migration/loading_csv_data.html"><strong aria-hidden="true">8.1.</strong> 加载CSV数据</a></li></ol></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">9.</strong> 常见问题和解决方案</a></li><li class="chapter-item expanded "><a href="how_to_guides/retrieving_debug_information.html"><strong aria-hidden="true">10.</strong> 最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="how_to_guides/retrieving_debug_information.html"><strong aria-hidden="true">10.1.</strong> 检索调试信息</a></li><li class="chapter-item expanded "><a href="how_to_guides/shell_completion.html"><strong aria-hidden="true">10.2.</strong> 命令行补全</a></li><li class="chapter-item expanded "><a href="how_to_guides/using_the_debug_tool.html"><strong aria-hidden="true">10.3.</strong> 使用调试工具</a></li><li class="chapter-item expanded "><a href="how_to_guides/using_the_dgraph_sentry_integration.html"><strong aria-hidden="true">10.4.</strong> 使用 Dgraph Sentry 集成</a></li><li class="chapter-item expanded "><a href="how_to_guides/using_the_increment_tool.html"><strong aria-hidden="true">10.5.</strong> 使用增量工具</a></li><li class="chapter-item expanded "><a href="how_to_guides/giving_nodes_a_type.html"><strong aria-hidden="true">10.6.</strong> 设置一个node的类型</a></li><li class="chapter-item expanded "><a href="how_to_guides/load_balancing_queries_with_nginx.html"><strong aria-hidden="true">10.7.</strong> 使用 nginx 做查询负载均衡</a></li><li class="chapter-item expanded "><a href="how_to_guides/a_simple_login_system.html"><strong aria-hidden="true">10.8.</strong> 一个简单的登录系统</a></li><li class="chapter-item expanded "><a href="how_to_guides/upserts.html"><strong aria-hidden="true">10.9.</strong> 插入</a></li><li class="chapter-item expanded "><a href="how_to_guides/run_jepsen_tests.html"><strong aria-hidden="true">10.10.</strong> 运行 Jepsen 测试</a></li><li class="chapter-item expanded "><a href="how_to_guides/concurrent_mutations_and_conflicts.html"><strong aria-hidden="true">10.11.</strong> 并行变更和冲突</a></li></ol></li><li class="chapter-item expanded "><a href="design_concepts/concepts.html"><strong aria-hidden="true">11.</strong> 设计原则</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design_concepts/concepts.html"><strong aria-hidden="true">11.1.</strong> 原则</a></li></ol></li><li class="chapter-item expanded "><a href="releases.html"><strong aria-hidden="true">12.</strong> 版本更新</a></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">13.</strong> 手册总览</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dgraph中文文档</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="预览"><a class="header" href="#预览">预览</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="部署到-dgraph-云"><a class="header" href="#部署到-dgraph-云">部署到 Dgraph 云</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="auth-动词"><a class="header" href="#auth-动词">@auth 动词</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在变更中使用-auth-动词"><a class="header" href="#在变更中使用-auth-动词">在变更中使用 @auth 动词</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="请求和请求响应"><a class="header" href="#请求和请求响应">请求和请求响应</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-变量"><a class="header" href="#graphql-变量">GraphQL 变量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-片段"><a class="header" href="#graphql-片段">GraphQL 片段</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一次请求多次操作"><a class="header" href="#一次请求多次操作">一次请求多次操作</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-错误"><a class="header" href="#graphql-错误">GraphQL 错误</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dql"><a class="header" href="#dql">DQL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<blockquote>
<p>这是一份快速开始的手册，你可以在<a href="https://dgraph.io/docs/tutorials/">这里</a>找到开始系列的教程。</p>
</blockquote>
<h2 id="dgraph"><a class="header" href="#dgraph">Dgraph</a></h2>
<p><code>Dgraph</code>从头开始设计，以便在生产环境中运行，它是带有<code>GraphQL</code>后端的原生<code>GraphQL</code>数据库。它是开源的，可扩展的，分布式的，高可用性的和具有闪电般的速度。</p>
<p><code>Dgraph</code>集群由不同的节点(<code>Zero</code>, <code>Alpha</code>和<code>Ratel</code>)组成，每个节点都有不同的用途：</p>
<ul>
<li><code>Dgraph Zero</code>控制<code>Dgraph</code>集群，将服务器分配给一个组，并在服务器组之间重新平衡数据。</li>
<li><code>Dgraph Alpha</code>托管谓词(predicate)和索引(index)。谓词是与节点(node)关联的属性(facets)或两个节点之间的关系(relation)。索引是可以与谓词关联的标记器，可以使用适当的函数启用过滤。</li>
<li><code>Ratel</code>服务于<code>UI</code>来运行查询、变更和更改<code>Schema</code>。</li>
</ul>
<p>你至少需要一个<code>Dgraph Zero</code>和一个<code>Dgraph Alpha</code>来启动<code>Dgraph</code>数据库。</p>
<p><strong>这里有一个四个步骤的教程来帮助你启动和运行。</strong></p>
<p>这是一个运行<code>Dgraph</code>的快速入门指南。如果你想了解互动的攻略，那就来看看吧。</p>
<blockquote>
<p>提示：本指南针对的是强大的<code>Dgraph</code>查询语言，<code>DQL</code>是<code>Facebook</code>创建的一种查询语言<code>GraphQL</code>的变体。您可以从<code>dgraph.io/ GraphQL</code>中找到开始使用<code>GraphQL</code>的说明。</p>
</blockquote>
<h2 id="步骤一运行-dgraph"><a class="header" href="#步骤一运行-dgraph">步骤一：运行 Dgraph</a></h2>
<p>安装和运行<code>Dgraph</code>有几种方法，都可以在下载页面中找到。</p>
<p>让<code>Dgraph</code>启动并运行的最简单方法是使用<code>dgraph/standalone</code>这个<code>docker</code>映像。如果您还没有<code>Docker</code>，请按照这里的说明安装它：</p>
<pre><code class="language-bash">docker run --rm -it -p &quot;8080:8080&quot; -p &quot;9080:9080&quot; -p &quot;8000:8000&quot; -v ~/dgraph:/dgraph &quot;dgraph/standalone:v21.03.2&quot;
</code></pre>
<blockquote>
<p>注意：此独立映像仅用于快速启动目的。不建议在生产环境中使用。</p>
</blockquote>
<p>这将启动一个容器，其中运行<code>Dgraph Alpha</code>、<code>Dgraph Zero</code>和<code>Ratel</code>。您会发现<code>Dgraph</code>数据存储在主目录的一个名为<code>Dgraph</code>的文件夹中。</p>
<h2 id="使用变更"><a class="header" href="#使用变更">使用变更</a></h2>
<blockquote>
<p>提示：<code>Dgraph</code>运行起来后，您可以通过<code>http://localhost:8000</code>访问<code>Ratel</code>。它允许基于浏览器的查询、变化和可视化。您可以通过命令行中的curl或将突变数据粘贴到<code>Ratel</code>中来运行下面的突变和查询。</p>
</blockquote>
<h3 id="数据集"><a class="header" href="#数据集">数据集</a></h3>
<p>数据集是一个电影图，其中的图节点是类型导演、演员、类型或电影的实体。</p>
<h3 id="在-dgraph-中检索数据"><a class="header" href="#在-dgraph-中检索数据">在 <code>Dgraph</code> 中检索数据</a></h3>
<p>更改存储在<code>Dgraph</code>中的数据叫做<code>变更</code>(mutation)。到目前为止，<code>Dgraph</code>支持通过两种方式变更数据：<code>RDF</code>和<code>JSON</code>。下面的<code>RDF</code>变更存储关于<code>星球大战</code>系列的前三次发行和<code>星际迷航</code>系列电影之一的信息。提交<code>RDF</code>变更(通过<code>curl</code>或<code>Ratel UI</code>的<code>mutate</code>选项卡)将在<code>Dgraph</code>中存储数据：</p>
<pre><code class="language-bash">curl &quot;localhost:8080/mutate?commitNow=true&quot; --silent --request POST \
 --header  &quot;Content-Type: application/rdf&quot; \
 --data $'
{
  set {
   _:luke &lt;name&gt; &quot;Luke Skywalker&quot; .
   _:luke &lt;dgraph.type&gt; &quot;Person&quot; .
   _:leia &lt;name&gt; &quot;Princess Leia&quot; .
   _:leia &lt;dgraph.type&gt; &quot;Person&quot; .
   _:han &lt;name&gt; &quot;Han Solo&quot; .
   _:han &lt;dgraph.type&gt; &quot;Person&quot; .
   _:lucas &lt;name&gt; &quot;George Lucas&quot; .
   _:lucas &lt;dgraph.type&gt; &quot;Person&quot; .
   _:irvin &lt;name&gt; &quot;Irvin Kernshner&quot; .
   _:irvin &lt;dgraph.type&gt; &quot;Person&quot; .
   _:richard &lt;name&gt; &quot;Richard Marquand&quot; .
   _:richard &lt;dgraph.type&gt; &quot;Person&quot; .

   _:sw1 &lt;name&gt; &quot;Star Wars: Episode IV - A New Hope&quot; .
   _:sw1 &lt;release_date&gt; &quot;1977-05-25&quot; .
   _:sw1 &lt;revenue&gt; &quot;775000000&quot; .
   _:sw1 &lt;running_time&gt; &quot;121&quot; .
   _:sw1 &lt;starring&gt; _:luke .
   _:sw1 &lt;starring&gt; _:leia .
   _:sw1 &lt;starring&gt; _:han .
   _:sw1 &lt;director&gt; _:lucas .
   _:sw1 &lt;dgraph.type&gt; &quot;Film&quot; .

   _:sw2 &lt;name&gt; &quot;Star Wars: Episode V - The Empire Strikes Back&quot; .
   _:sw2 &lt;release_date&gt; &quot;1980-05-21&quot; .
   _:sw2 &lt;revenue&gt; &quot;534000000&quot; .
   _:sw2 &lt;running_time&gt; &quot;124&quot; .
   _:sw2 &lt;starring&gt; _:luke .
   _:sw2 &lt;starring&gt; _:leia .
   _:sw2 &lt;starring&gt; _:han .
   _:sw2 &lt;director&gt; _:irvin .
   _:sw2 &lt;dgraph.type&gt; &quot;Film&quot; .

   _:sw3 &lt;name&gt; &quot;Star Wars: Episode VI - Return of the Jedi&quot; .
   _:sw3 &lt;release_date&gt; &quot;1983-05-25&quot; .
   _:sw3 &lt;revenue&gt; &quot;572000000&quot; .
   _:sw3 &lt;running_time&gt; &quot;131&quot; .
   _:sw3 &lt;starring&gt; _:luke .
   _:sw3 &lt;starring&gt; _:leia .
   _:sw3 &lt;starring&gt; _:han .
   _:sw3 &lt;director&gt; _:richard .
   _:sw3 &lt;dgraph.type&gt; &quot;Film&quot; .

   _:st1 &lt;name&gt; &quot;Star Trek: The Motion Picture&quot; .
   _:st1 &lt;release_date&gt; &quot;1979-12-07&quot; .
   _:st1 &lt;revenue&gt; &quot;139000000&quot; .
   _:st1 &lt;running_time&gt; &quot;132&quot; .
   _:st1 &lt;dgraph.type&gt; &quot;Film&quot; .
  }
}
' | python -m json.tool | less
</code></pre>
<blockquote>
<p>提示：要通过<code>curl</code>使用文件提交<code>RDF/JSON</code>变更，可以使用<code>curl</code>选项<code>--data-binary @/path/ To /mutation</code>。<code>--data-binary</code>选项跳过<code>curl</code>的默认<code>url</code>编码，包括删除所有换行符。因此，通过使用<code>--data-binary</code>选项，您可以在文本中使用<code>#</code>注释，因为使用<code>--data</code>选项，文本中第一个<code>#</code>之后的任何内容都将出现在同一行，因此将被视为一个长注释。</p>
</blockquote>
<h3 id="步骤三修改schema"><a class="header" href="#步骤三修改schema">步骤三：修改Schema</a></h3>
<p>修改<code>Schema</code>，在某些数据上添加索引，这样查询就可以使用术语匹配、过滤和排序。</p>
<pre><code class="language-bash">curl &quot;localhost:8080/alter&quot; --silent --request POST \
  --data $'
name: string @index(term) .
release_date: datetime @index(year) .
revenue: float .
running_time: int .
starring: [uid] .
director: [uid] .

type Person {
  name
}

type Film {
  name
  release_date
  revenue
  running_time
  starring
  director
}
' | python -m json.tool | less
</code></pre>
<blockquote>
<p>提示：要从<code>Ratel UI</code>提交Schema``，请转到<code>Schema</code>页面，单击批量编辑，然后粘贴<code>Schema</code>。</p>
</blockquote>
<h3 id="步骤四运行查询"><a class="header" href="#步骤四运行查询">步骤四：运行查询</a></h3>
<h4 id="查询所有电影"><a class="header" href="#查询所有电影">查询所有电影</a></h4>
<p>运行此查询以获取所有电影。该查询列出了所有具有主演优势的电影：</p>
<blockquote>
<p>提示：您也可以在<code>Ratel UI</code>的<code>query</code>选项卡中运行<code>DQL</code>查询。</p>
</blockquote>
<pre><code class="language-bash">curl &quot;localhost:8080/query&quot; --silent --request POST \
  --header &quot;Content-Type: application/dql&quot; \
  --data $'
{
 me(func: has(starring)) {
   name
  }
}
' | python -m json.tool | less
</code></pre>
<blockquote>
<p>注意GraphQL+-已重命名为Dgraph查询语言(DQL)。虽然application/dql是Content-Type头的首选值，但我们将继续支持Content-Type: application/graphql+-，以避免进行破坏性的更改。</p>
</blockquote>
<h4 id="获得1980年之后发行的所有电影"><a class="header" href="#获得1980年之后发行的所有电影">获得1980年之后发行的所有电影</a></h4>
<p>运行这个查询可以得到“1980年”之后发行的“星球大战”电影。在用户界面中尝试它，以图形的形式查看结果：</p>
<pre><code class="language-bash">curl &quot;localhost:8080/query&quot; --silent --request POST \
  --header &quot;Content-Type: application/dql&quot; \
  --data $'
{
  me(func: allofterms(name, &quot;Star Wars&quot;), orderasc: release_date) @filter(ge(release_date, &quot;1980&quot;)) {
    name
    release_date
    revenue
    running_time
    director {
     name
    }
    starring (orderasc: name) {
     name
    }
  }
}
' | python -m json.tool | less
</code></pre>
<p>返回结果：</p>
<pre><code class="language-json">{
  &quot;data&quot;:{
    &quot;me&quot;:[
      {
        &quot;name&quot;:&quot;Star Wars: Episode V - The Empire Strikes Back&quot;,
        &quot;release_date&quot;:&quot;1980-05-21T00:00:00Z&quot;,
        &quot;revenue&quot;:534000000.0,
        &quot;running_time&quot;:124,
        &quot;director&quot;:[
          {
            &quot;name&quot;:&quot;Irvin Kernshner&quot;
          }
        ],
        &quot;starring&quot;:[
          {
            &quot;name&quot;:&quot;Han Solo&quot;
          },
          {
            &quot;name&quot;:&quot;Luke Skywalker&quot;
          },
          {
            &quot;name&quot;:&quot;Princess Leia&quot;
          }
        ]
      },
      {
        &quot;name&quot;:&quot;Star Wars: Episode VI - Return of the Jedi&quot;,
        &quot;release_date&quot;:&quot;1983-05-25T00:00:00Z&quot;,
        &quot;revenue&quot;:572000000.0,
        &quot;running_time&quot;:131,
        &quot;director&quot;:[
          {
            &quot;name&quot;:&quot;Richard Marquand&quot;
          }
        ],
        &quot;starring&quot;:[
          {
            &quot;name&quot;:&quot;Han Solo&quot;
          },
          {
            &quot;name&quot;:&quot;Luke Skywalker&quot;
          },
          {
            &quot;name&quot;:&quot;Princess Leia&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>就是这样！在这四个步骤中，我们设置了<code>Dgraph</code>、添加了一些数据、设置了一个<code>Schema</code>并查询了该数据。</p>
<p><strong>下一步该做什么</strong></p>
<ul>
<li>转到Clients查看如何从应用程序与Dgraph通信。</li>
<li>请参阅本教程，了解如何在Dgraph中编写查询。</li>
<li>查询语言参考中还可以找到更广泛的查询。</li>
<li>如果希望在集群中运行Dgraph，请参阅部署。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="dql-基础"><a class="header" href="#dql-基础">DQL 基础</a></h1>
<p>Dgraph Query Language, DQL查询语言（旧称GraphQL+-），是一门基于<code>GraphQL</code>的查询语言。<code>GraphQL</code>不是专门为图数据库而设计的，但是它的解析规则和图查询非常相似（查询语法的解析，schema的校验，子图塑型返回等），所以我们就直接在<code>GraphQL</code>的基础上增删一些特性，创造了<code>DQL</code>。</p>
<p><code>DQL</code>目前还在开发中，我们在未来可以会增加一些新特性，以及简化目前的版本。</p>
<h3 id="一个小示例"><a class="header" href="#一个小示例">一个小示例</a></h3>
<p>这个小例子使用了一个包含2.1千万条元组的电影和戏子的数据库。负载这个数据库的<code>Dgraph</code>是跑在云<a href="https://play.dgraph.io/">https://play.dgraph.io/</a>上面的。你也可以选择<a href="dql/query_language/../get_started.html">本地运行</a></p>
<h4 id="定义数据库的数据结构"><a class="header" href="#定义数据库的数据结构">定义数据库的数据结构</a></h4>
<p>本例子使用下面的<code>schema</code>定义数据库的结构:</p>
<pre><code class="language-graphql"># Define Directives and index

director.film: [uid] @reverse .
actor.film: [uid] @count .
genre: [uid] @reverse .
initial_release_date: dateTime @index(year) .
name: string @index(exact, term) @lang .
starring: [uid] .
performance.film: [uid] .
performance.character_note: string .
performance.character: [uid] .
performance.actor: [uid] .
performance.special_performance_type: [uid] .
type: [uid] .

# Define Types

type Person {
    name
    director.film
    actor.film
}

type Movie {
    name
    initial_release_date
    genre
    starring
}

type Genre {
    name
}

type Performance {
    performance.film
    performance.character
    performance.actor
}
</code></pre>
<h3 id="开始查询"><a class="header" href="#开始查询">开始查询</a></h3>
<p>对一些<code>node</code>进行的查询是建立在图数据库的搜索规则，匹配模式上的，返回一个图作为查询结果。
一个查询是由几个查询块组成的：先由一个根的查询块查询到一系列符合查询规则的<code>nodes</code>，然后再在这些<code>nodes</code>上面应用图匹配和图过滤。</p>
<blockquote>
<p>更多的查询列子可以参照<a href="dql/query_language/../design_concepts/concepts.html">查询设计原则</a></p>
</blockquote>
<h4 id="错误码"><a class="header" href="#错误码">错误码</a></h4>
<p>当你使用<code>DQL</code>查询的时候，服务端可能会返回一个查询错误。在服务端返回的错误对象<code>JSON</code>中有一个<code>code</code>属性，<code>code</code>通常有两个取值</p>
<ol>
<li><code>ErrorInvalidRequest</code>: 可能是错误的请求(400)或者是服务器内部的错误(500)</li>
<li><code>Error</code>: 服务器内部的错误(500)</li>
</ol>
<p>例如，当你提交请求解析错误时，服务端返回:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;while lexing {\nq(func: has(\&quot;test)){\nuid\n}\n} at line 2 column 12: Unexpected end of input.&quot;,
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;ErrorInvalidRequest&quot;
      }
    }
  ],
  &quot;data&quot;: null
}
</code></pre>
<h5 id="error"><a class="header" href="#error">Error</a></h5>
<p>这是一个很少见的错误，一般是服务器序列化<code>GO</code>struct到<code>JSON</code>对象时发生错误导致</p>
<h5 id="errorinvalidrequst"><a class="header" href="#errorinvalidrequst">ErrorInvalidRequst</a></h5>
<h3 id="返回值"><a class="header" href="#返回值">返回值</a></h3>
<p>每一个查询都有一个名字，和你发送给后端的查询的位于根块的名字一致。
如果一条边是一个值类型，那么这条边将直接返回。
在本例子的数据库中，边(<code>edges</code>)连接电影<code>movies</code>到导演<code>directors</code>和戏子<code>actors</code>，<code>movies</code>拥有<code>name</code>，<code>release date</code>更新时间，还有它在出名的影视数据库的<code>id</code>
下面是一个名为<code>bladerunner</code>的请求：通过比对电影的名字<code>Blade Runner</code>获取电影信息</p>
<pre><code class="language-graphql">{
  bladerunner(func: eq(name@en, &quot;Blade Runner&quot;)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>它将会返回</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      }
    ]
  }
}
</code></pre>
<p>上面的请求首先通过索引找到<code>name</code>边等于<code>Blade Runner</code>的<code>node</code>，然后返回该<code>node</code>的出边属性。每一个<code>node</code>都有一个唯一的64位的<code>id</code>，上面的请求中，<code>uid</code>边返回了该<code>node</code>的<code>id</code>，如果一个<code>node</code>的<code>id</code>已知，可以通过<code>uid</code>函数直接查找该节点。</p>
<pre><code class="language-graphql">{
  bladerunner(func: uid(0x394c)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>上面的请求将返回</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      }
    ]
  }
}
</code></pre>
<p>一个查询可能匹配到多个<code>node</code>，下面查询所有名字含有<code>Blade</code>或<code>Runner</code>的节点。</p>
<pre><code class="language-graphql">{
  bladerunner(func: anyofterms(name@en, &quot;Blade Runner&quot;)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0xd5f&quot;,
        &quot;name@en&quot;: &quot;The Runner&quot;
      },
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      },
      ....
    ]
  }
}
</code></pre>
<p><code>uid</code>函数也能同时指定多个<code>id</code></p>
<pre><code class="language-graphql">{
  movies(func: uid(0xb5849, 0x394c)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>返回</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;movies&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      },
      {
        &quot;uid&quot;: &quot;0xb5849&quot;,
        &quot;name@en&quot;: &quot;James Cameron's Explorers: From the Titanic to the Moon&quot;,
        &quot;initial_release_date&quot;: &quot;2006-01-01T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70058064&quot;
      }
    ]
  }
}
</code></pre>
<h3 id="展开图节点的边"><a class="header" href="#展开图节点的边">展开图节点的边</a></h3>
<p>一个查询能通过嵌套查询块<code>{}</code>从一个节点扩展到另一个节点
下面查询<code>Blade Runner</code>中的演员和人物：该查询首先查询出拥有名字为<code>Blade Runner</code>这条边的节点，然后从这个节点沿着向外的主演边<code>starring</code>找到演员饰演的角色的节点。从这些节点里面再沿着<code>perfromance.actor</code>边和<code>performance.character</code>边展开，找到演员的名字和在剧中饰演的角色的名字。</p>
<pre><code class="language-graphql">{
  brCharacters(func: eq(name@en, &quot;Blade Runner&quot;)) {
    name@en
    initial_release_date
    starring {
      performance.actor {
        name@en  # actor name
      }
      performance.character {
        name@en  # character name
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;brCharacters&quot;: [
      {
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;John Edward Allen&quot;
              }
            ],
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Kaiser&quot;
              }
            ]
          },
          {
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Joanna Cassidy&quot;
              }
            ],
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Zhora&quot;
              }
            ]
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<p>所有在 <code>#</code>后面的都是注释</p>
<h3 id="使用过滤"><a class="header" href="#使用过滤">使用过滤</a></h3>
<p>查询根查找一组初始节点，查询通过返回值并沿着边继续查询————查询中到达的任何节点都是在根处搜索之后遍历找到的。找到的节点可以通过应用<code>@filter</code>过滤，可以在根节点之后或任何边进行过滤。</p>
<p>查询示例:《银翼杀手》导演雷德利·斯科特在2000年之前发行的电影：</p>
<pre><code class="language-graphql">{
  scott(func: eq(name@en, &quot;Ridley Scott&quot;)) {
    name@en
    initial_release_date
    director.film @filter(le(initial_release_date, &quot;2000&quot;)) {
      name@en
      initial_release_date
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;scott&quot;: [
      {
        &quot;name@en&quot;: &quot;Ridley Scott&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Blade Runner&quot;,
            &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Alien&quot;,
            &quot;initial_release_date&quot;: &quot;1979-05-25T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Black Rain&quot;,
            &quot;initial_release_date&quot;: &quot;1989-09-22T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;White Squall&quot;,
            &quot;initial_release_date&quot;: &quot;1996-02-02T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Thelma &amp; Louise&quot;,
            &quot;initial_release_date&quot;: &quot;1991-05-24T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;G.I. Jane&quot;,
            &quot;initial_release_date&quot;: &quot;1997-08-22T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;1492 Conquest of Paradise&quot;,
            &quot;initial_release_date&quot;: &quot;1992-10-08T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;The Duellists&quot;,
            &quot;initial_release_date&quot;: &quot;1977-12-01T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Someone to Watch Over Me&quot;,
            &quot;initial_release_date&quot;: &quot;1987-10-09T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Legend&quot;,
            &quot;initial_release_date&quot;: &quot;1985-08-28T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Boy and Bicycle&quot;,
            &quot;initial_release_date&quot;: &quot;1997-09-07T00:00:00Z&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Ridley Scott&quot;
      }
    ]
  }
}
</code></pre>
<p>查询示例:2000年之前上映的片名为“刀锋战士”或“奔跑者”的电影：</p>
<pre><code class="language-graphql">{
  bladerunner(func: anyofterms(name@en, &quot;Blade Runner&quot;)) @filter(le(initial_release_date, &quot;2000&quot;)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      },
      {
        &quot;uid&quot;: &quot;0x7160&quot;,
        &quot;name@en&quot;: &quot;Blade&quot;,
        &quot;initial_release_date&quot;: &quot;1973-12-01T00:00:00Z&quot;
      },
      {
        &quot;uid&quot;: &quot;0x15adb&quot;,
        &quot;name@en&quot;: &quot;Lone Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1986-01-01T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70146965&quot;
      },
      {
        &quot;uid&quot;: &quot;0x16f0c&quot;,
        &quot;name@en&quot;: &quot;Revenge of the Bushido Blade&quot;,
        &quot;initial_release_date&quot;: &quot;1980-01-01T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70100967&quot;
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="多语言支持"><a class="header" href="#多语言支持">多语言支持</a></h3>
<blockquote>
<p>注意：必须在<code>Schema</code>中指定<code>@lang</code>指令来查询或修改带有语言标记的谓词。</p>
</blockquote>
<p><code>Dgraph</code>支持<code>UTF-8</code></p>
<p>使用以下规则指定返回语言的优先顺序：</p>
<ul>
<li>最多只会返回一个结果(除了语言列表被设置为*的情况)。</li>
<li>从左到右考虑首选项列表：如果没有找到给定语言的值，则考虑列表中的下一种语言。</li>
<li>如果在任何指定的语言中没有值，则不返回值。</li>
<li>最后一个<code>.</code>表示返回没有指定语言的值，或者如果没有没有语言的值，则返回<code>some</code>语言的值。</li>
<li>将语言列表值设置为<code>*</code>将返回该谓词的所有值及其语言。也会返回没有语言标记的值。
例如：</li>
<li><code>name</code>: 查找一个<code>untagged</code>的字符串;如果没有<code>untagged</code>的值存在，则不返回任何值。</li>
<li><code>name@.</code>: 查找一个未标记的字符串，然后是任何语言。</li>
<li><code>name@en</code>: 查找<code>zh</code>标记的字符串；如果不存在带<code>en</code>标记的字符串，则不返回任何内容。</li>
<li><code>name@en:.</code>: 查找<code>en</code>，然后<code>untagged</code>，然后是任何语言。</li>
<li><code>name@en:pl</code>: 查找<code>en</code>，然后是<code>pl</code>，否则什么都不返回。</li>
<li><code>name@*</code>: 查找该谓词的所有值，并返回它们及其语言。例如，如果有两个语言为<code>en</code>和<code>hi</code>的值，则该查询将返回两个名为<code>name@en</code>和<code>name@hi</code>的键。</li>
</ul>
<blockquote>
<p>注意，在函数中，语言列表(包括<code>@*</code>符号)是不允许的。无标记谓词、单语言标记和<code>.</code>符号如上所述。
在全文搜索函数(<code>alloftext</code>、<code>anyoftext</code>)中，当没有指定语言(<code>untagged</code>或<code>@.</code>)时，将使用默认的(英文)全文标记器。这并不意味着在查询无标记值时将搜索带有en标记的值，而是将无标记值视为英语文本。如果您不希望出现这种情况，可以为所需的语言使用适当的标记，用于修改和查询值。</p>
</blockquote>
<p>查询示例:宝莱坞导演和演员法尔汉·阿赫塔尔(Farhan Akhtar)的一些电影有俄语、印地语和英语的名字，其他的没有：</p>
<pre><code class="language-graphql">{
  q(func: allofterms(name@en, &quot;Farhan Akhtar&quot;)) {
    name@.
    director.film {
      name@ru:hi:en
      name@en
      name@hi
      name@ru
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [
      {
        &quot;name@.&quot;: &quot;Farhan Akhtar&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@ru:hi:en&quot;: &quot;दिल चाहता है&quot;,
            &quot;name@en&quot;: &quot;Dil Chahta Hai&quot;,
            &quot;name@hi&quot;: &quot;दिल चाहता है&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;Дон. Главарь мафии 2&quot;,
            &quot;name@en&quot;: &quot;Don 2&quot;,
            &quot;name@hi&quot;: &quot;डॉन २&quot;,
            &quot;name@ru&quot;: &quot;Дон. Главарь мафии 2&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;पोज़िटिव&quot;,
            &quot;name@en&quot;: &quot;Positive&quot;,
            &quot;name@hi&quot;: &quot;पोज़िटिव&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;लक्ष्य&quot;,
            &quot;name@en&quot;: &quot;Lakshya&quot;,
            &quot;name@hi&quot;: &quot;लक्ष्य&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;Дон. Главарь мафии&quot;,
            &quot;name@en&quot;: &quot;Don: The Chase Begins Again&quot;,
            &quot;name@hi&quot;: &quot;डॉन&quot;,
            &quot;name@ru&quot;: &quot;Дон. Главарь мафии&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dql-基础-1"><a class="header" href="#dql-基础-1">DQL 基础</a></h1>
<p>Dgraph Query Language, DQL查询语言（旧称GraphQL+-），是一门基于<code>GraphQL</code>的查询语言。<code>GraphQL</code>不是专门为图数据库而设计的，但是它的解析规则和图查询非常相似（查询语法的解析，schema的校验，子图塑型返回等），所以我们就直接在<code>GraphQL</code>的基础上增删一些特性，创造了<code>DQL</code>。</p>
<p><code>DQL</code>目前还在开发中，我们在未来可以会增加一些新特性，以及简化目前的版本。</p>
<h3 id="一个小示例-1"><a class="header" href="#一个小示例-1">一个小示例</a></h3>
<p>这个小例子使用了一个包含2.1千万条元组的电影和戏子的数据库。负载这个数据库的<code>Dgraph</code>是跑在云<a href="https://play.dgraph.io/">https://play.dgraph.io/</a>上面的。你也可以选择<a href="dql/query_language/../get_started.html">本地运行</a></p>
<h4 id="定义数据库的数据结构-1"><a class="header" href="#定义数据库的数据结构-1">定义数据库的数据结构</a></h4>
<p>本例子使用下面的<code>schema</code>定义数据库的结构:</p>
<pre><code class="language-graphql"># Define Directives and index

director.film: [uid] @reverse .
actor.film: [uid] @count .
genre: [uid] @reverse .
initial_release_date: dateTime @index(year) .
name: string @index(exact, term) @lang .
starring: [uid] .
performance.film: [uid] .
performance.character_note: string .
performance.character: [uid] .
performance.actor: [uid] .
performance.special_performance_type: [uid] .
type: [uid] .

# Define Types

type Person {
    name
    director.film
    actor.film
}

type Movie {
    name
    initial_release_date
    genre
    starring
}

type Genre {
    name
}

type Performance {
    performance.film
    performance.character
    performance.actor
}
</code></pre>
<h3 id="开始查询-1"><a class="header" href="#开始查询-1">开始查询</a></h3>
<p>对一些<code>node</code>进行的查询是建立在图数据库的搜索规则，匹配模式上的，返回一个图作为查询结果。
一个查询是由几个查询块组成的：先由一个根的查询块查询到一系列符合查询规则的<code>nodes</code>，然后再在这些<code>nodes</code>上面应用图匹配和图过滤。</p>
<blockquote>
<p>更多的查询列子可以参照<a href="dql/query_language/../design_concepts/concepts.html">查询设计原则</a></p>
</blockquote>
<h4 id="错误码-1"><a class="header" href="#错误码-1">错误码</a></h4>
<p>当你使用<code>DQL</code>查询的时候，服务端可能会返回一个查询错误。在服务端返回的错误对象<code>JSON</code>中有一个<code>code</code>属性，<code>code</code>通常有两个取值</p>
<ol>
<li><code>ErrorInvalidRequest</code>: 可能是错误的请求(400)或者是服务器内部的错误(500)</li>
<li><code>Error</code>: 服务器内部的错误(500)</li>
</ol>
<p>例如，当你提交请求解析错误时，服务端返回:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;while lexing {\nq(func: has(\&quot;test)){\nuid\n}\n} at line 2 column 12: Unexpected end of input.&quot;,
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;ErrorInvalidRequest&quot;
      }
    }
  ],
  &quot;data&quot;: null
}
</code></pre>
<h5 id="error-1"><a class="header" href="#error-1">Error</a></h5>
<p>这是一个很少见的错误，一般是服务器序列化<code>GO</code>struct到<code>JSON</code>对象时发生错误导致</p>
<h5 id="errorinvalidrequst-1"><a class="header" href="#errorinvalidrequst-1">ErrorInvalidRequst</a></h5>
<h3 id="返回值-1"><a class="header" href="#返回值-1">返回值</a></h3>
<p>每一个查询都有一个名字，和你发送给后端的查询的位于根块的名字一致。
如果一条边是一个值类型，那么这条边将直接返回。
在本例子的数据库中，边(<code>edges</code>)连接电影<code>movies</code>到导演<code>directors</code>和戏子<code>actors</code>，<code>movies</code>拥有<code>name</code>，<code>release date</code>更新时间，还有它在出名的影视数据库的<code>id</code>
下面是一个名为<code>bladerunner</code>的请求：通过比对电影的名字<code>Blade Runner</code>获取电影信息</p>
<pre><code class="language-graphql">{
  bladerunner(func: eq(name@en, &quot;Blade Runner&quot;)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>它将会返回</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      }
    ]
  }
}
</code></pre>
<p>上面的请求首先通过索引找到<code>name</code>边等于<code>Blade Runner</code>的<code>node</code>，然后返回该<code>node</code>的出边属性。每一个<code>node</code>都有一个唯一的64位的<code>id</code>，上面的请求中，<code>uid</code>边返回了该<code>node</code>的<code>id</code>，如果一个<code>node</code>的<code>id</code>已知，可以通过<code>uid</code>函数直接查找该节点。</p>
<pre><code class="language-graphql">{
  bladerunner(func: uid(0x394c)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>上面的请求将返回</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      }
    ]
  }
}
</code></pre>
<p>一个查询可能匹配到多个<code>node</code>，下面查询所有名字含有<code>Blade</code>或<code>Runner</code>的节点。</p>
<pre><code class="language-graphql">{
  bladerunner(func: anyofterms(name@en, &quot;Blade Runner&quot;)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0xd5f&quot;,
        &quot;name@en&quot;: &quot;The Runner&quot;
      },
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      },
      ....
    ]
  }
}
</code></pre>
<p><code>uid</code>函数也能同时指定多个<code>id</code></p>
<pre><code class="language-graphql">{
  movies(func: uid(0xb5849, 0x394c)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>返回</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;movies&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      },
      {
        &quot;uid&quot;: &quot;0xb5849&quot;,
        &quot;name@en&quot;: &quot;James Cameron's Explorers: From the Titanic to the Moon&quot;,
        &quot;initial_release_date&quot;: &quot;2006-01-01T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70058064&quot;
      }
    ]
  }
}
</code></pre>
<h3 id="展开图节点的边-1"><a class="header" href="#展开图节点的边-1">展开图节点的边</a></h3>
<p>一个查询能通过嵌套查询块<code>{}</code>从一个节点扩展到另一个节点
下面查询<code>Blade Runner</code>中的演员和人物：该查询首先查询出拥有名字为<code>Blade Runner</code>这条边的节点，然后从这个节点沿着向外的主演边<code>starring</code>找到演员饰演的角色的节点。从这些节点里面再沿着<code>perfromance.actor</code>边和<code>performance.character</code>边展开，找到演员的名字和在剧中饰演的角色的名字。</p>
<pre><code class="language-graphql">{
  brCharacters(func: eq(name@en, &quot;Blade Runner&quot;)) {
    name@en
    initial_release_date
    starring {
      performance.actor {
        name@en  # actor name
      }
      performance.character {
        name@en  # character name
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;brCharacters&quot;: [
      {
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;John Edward Allen&quot;
              }
            ],
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Kaiser&quot;
              }
            ]
          },
          {
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Joanna Cassidy&quot;
              }
            ],
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Zhora&quot;
              }
            ]
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<h3 id="注释-1"><a class="header" href="#注释-1">注释</a></h3>
<p>所有在 <code>#</code>后面的都是注释</p>
<h3 id="使用过滤-1"><a class="header" href="#使用过滤-1">使用过滤</a></h3>
<p>查询根查找一组初始节点，查询通过返回值并沿着边继续查询————查询中到达的任何节点都是在根处搜索之后遍历找到的。找到的节点可以通过应用<code>@filter</code>过滤，可以在根节点之后或任何边进行过滤。</p>
<p>查询示例:《银翼杀手》导演雷德利·斯科特在2000年之前发行的电影：</p>
<pre><code class="language-graphql">{
  scott(func: eq(name@en, &quot;Ridley Scott&quot;)) {
    name@en
    initial_release_date
    director.film @filter(le(initial_release_date, &quot;2000&quot;)) {
      name@en
      initial_release_date
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;scott&quot;: [
      {
        &quot;name@en&quot;: &quot;Ridley Scott&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Blade Runner&quot;,
            &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Alien&quot;,
            &quot;initial_release_date&quot;: &quot;1979-05-25T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Black Rain&quot;,
            &quot;initial_release_date&quot;: &quot;1989-09-22T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;White Squall&quot;,
            &quot;initial_release_date&quot;: &quot;1996-02-02T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Thelma &amp; Louise&quot;,
            &quot;initial_release_date&quot;: &quot;1991-05-24T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;G.I. Jane&quot;,
            &quot;initial_release_date&quot;: &quot;1997-08-22T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;1492 Conquest of Paradise&quot;,
            &quot;initial_release_date&quot;: &quot;1992-10-08T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;The Duellists&quot;,
            &quot;initial_release_date&quot;: &quot;1977-12-01T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Someone to Watch Over Me&quot;,
            &quot;initial_release_date&quot;: &quot;1987-10-09T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Legend&quot;,
            &quot;initial_release_date&quot;: &quot;1985-08-28T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Boy and Bicycle&quot;,
            &quot;initial_release_date&quot;: &quot;1997-09-07T00:00:00Z&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Ridley Scott&quot;
      }
    ]
  }
}
</code></pre>
<p>查询示例:2000年之前上映的片名为“刀锋战士”或“奔跑者”的电影：</p>
<pre><code class="language-graphql">{
  bladerunner(func: anyofterms(name@en, &quot;Blade Runner&quot;)) @filter(le(initial_release_date, &quot;2000&quot;)) {
    uid
    name@en
    initial_release_date
    netflix_id
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bladerunner&quot;: [
      {
        &quot;uid&quot;: &quot;0x394c&quot;,
        &quot;name@en&quot;: &quot;Blade Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1982-06-25T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70083726&quot;
      },
      {
        &quot;uid&quot;: &quot;0x7160&quot;,
        &quot;name@en&quot;: &quot;Blade&quot;,
        &quot;initial_release_date&quot;: &quot;1973-12-01T00:00:00Z&quot;
      },
      {
        &quot;uid&quot;: &quot;0x15adb&quot;,
        &quot;name@en&quot;: &quot;Lone Runner&quot;,
        &quot;initial_release_date&quot;: &quot;1986-01-01T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70146965&quot;
      },
      {
        &quot;uid&quot;: &quot;0x16f0c&quot;,
        &quot;name@en&quot;: &quot;Revenge of the Bushido Blade&quot;,
        &quot;initial_release_date&quot;: &quot;1980-01-01T00:00:00Z&quot;,
        &quot;netflix_id&quot;: &quot;70100967&quot;
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="多语言支持-1"><a class="header" href="#多语言支持-1">多语言支持</a></h3>
<blockquote>
<p>注意：必须在<code>Schema</code>中指定<code>@lang</code>指令来查询或修改带有语言标记的谓词。</p>
</blockquote>
<p><code>Dgraph</code>支持<code>UTF-8</code></p>
<p>使用以下规则指定返回语言的优先顺序：</p>
<ul>
<li>最多只会返回一个结果(除了语言列表被设置为*的情况)。</li>
<li>从左到右考虑首选项列表：如果没有找到给定语言的值，则考虑列表中的下一种语言。</li>
<li>如果在任何指定的语言中没有值，则不返回值。</li>
<li>最后一个<code>.</code>表示返回没有指定语言的值，或者如果没有没有语言的值，则返回<code>some</code>语言的值。</li>
<li>将语言列表值设置为<code>*</code>将返回该谓词的所有值及其语言。也会返回没有语言标记的值。
例如：</li>
<li><code>name</code>: 查找一个<code>untagged</code>的字符串;如果没有<code>untagged</code>的值存在，则不返回任何值。</li>
<li><code>name@.</code>: 查找一个未标记的字符串，然后是任何语言。</li>
<li><code>name@en</code>: 查找<code>zh</code>标记的字符串；如果不存在带<code>en</code>标记的字符串，则不返回任何内容。</li>
<li><code>name@en:.</code>: 查找<code>en</code>，然后<code>untagged</code>，然后是任何语言。</li>
<li><code>name@en:pl</code>: 查找<code>en</code>，然后是<code>pl</code>，否则什么都不返回。</li>
<li><code>name@*</code>: 查找该谓词的所有值，并返回它们及其语言。例如，如果有两个语言为<code>en</code>和<code>hi</code>的值，则该查询将返回两个名为<code>name@en</code>和<code>name@hi</code>的键。</li>
</ul>
<blockquote>
<p>注意，在函数中，语言列表(包括<code>@*</code>符号)是不允许的。无标记谓词、单语言标记和<code>.</code>符号如上所述。
在全文搜索函数(<code>alloftext</code>、<code>anyoftext</code>)中，当没有指定语言(<code>untagged</code>或<code>@.</code>)时，将使用默认的(英文)全文标记器。这并不意味着在查询无标记值时将搜索带有en标记的值，而是将无标记值视为英语文本。如果您不希望出现这种情况，可以为所需的语言使用适当的标记，用于修改和查询值。</p>
</blockquote>
<p>查询示例:宝莱坞导演和演员法尔汉·阿赫塔尔(Farhan Akhtar)的一些电影有俄语、印地语和英语的名字，其他的没有：</p>
<pre><code class="language-graphql">{
  q(func: allofterms(name@en, &quot;Farhan Akhtar&quot;)) {
    name@.
    director.film {
      name@ru:hi:en
      name@en
      name@hi
      name@ru
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [
      {
        &quot;name@.&quot;: &quot;Farhan Akhtar&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@ru:hi:en&quot;: &quot;दिल चाहता है&quot;,
            &quot;name@en&quot;: &quot;Dil Chahta Hai&quot;,
            &quot;name@hi&quot;: &quot;दिल चाहता है&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;Дон. Главарь мафии 2&quot;,
            &quot;name@en&quot;: &quot;Don 2&quot;,
            &quot;name@hi&quot;: &quot;डॉन २&quot;,
            &quot;name@ru&quot;: &quot;Дон. Главарь мафии 2&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;पोज़िटिव&quot;,
            &quot;name@en&quot;: &quot;Positive&quot;,
            &quot;name@hi&quot;: &quot;पोज़िटिव&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;लक्ष्य&quot;,
            &quot;name@en&quot;: &quot;Lakshya&quot;,
            &quot;name@hi&quot;: &quot;लक्ष्य&quot;
          },
          {
            &quot;name@ru:hi:en&quot;: &quot;Дон. Главарь мафии&quot;,
            &quot;name@en&quot;: &quot;Don: The Chase Begins Again&quot;,
            &quot;name@hi&quot;: &quot;डॉन&quot;,
            &quot;name@ru&quot;: &quot;Дон. Главарь мафии&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>函数允许基于节点或变量的属性进行筛选。函数可以应用于根查询或过滤器中。</p>
<blockquote>
<p>Dgraph v1.2.0添加了对非索引谓词上的过滤器的支持。</p>
</blockquote>
<p>根查询(又名<code>func:</code>)中的比较函数(<code>eq</code>, <code>ge</code>, <code>gt</code>, <code>le</code>, <code>lt</code>)只能应用于索引谓词。从<code>v1.2</code>开始，现在可以在<code>@filter</code>指令上使用比较函数，甚至可以在没有索引的谓词上使用比较函数。对于大型数据集，在非索引谓词上进行筛选可能会很慢，因为它们需要在使用筛选器的级别上迭代所有可能的值。</p>
<p>根查询或筛选器中的所有其他函数只能应用于索引谓词。</p>
<p>对于字符串值谓词上的函数，如果没有给出语言首选项，则该函数将应用于所有没有语言标记的语言和字符串；如果给定了语言首选项，则该函数只应用于给定语言的字符串。</p>
<h2 id="词匹配"><a class="header" href="#词匹配">词匹配</a></h2>
<h3 id="allofterms"><a class="header" href="#allofterms">allofterms</a></h3>
<p>解析示例：<code>allofterms(predicate, &quot;空 格 分开 的词 列表&quot;)</code></p>
<p>Schema类型：<code>string</code></p>
<p>索引要求：<code>term</code></p>
<p>以任意顺序匹配具有所有指定项的字符串；不区分大小写。</p>
<h4 id="用在根查询中"><a class="header" href="#用在根查询中">用在根查询中</a></h4>
<p>查询示例：所有名称中包含词条<code>indiana</code>和<code>jones</code>的节点，以英文返回英文名称和流派：</p>
<pre><code class="language-graphql">{
  me(func: allofterms(name@en, &quot;jones indiana&quot;)) {
    name@en
    genre {
      name@en
    }
  }
}
</code></pre>
<p>这将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;The Adventures of Young Indiana Jones: Passion for Life&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;History&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;The Young Indiana Jones Chronicles 2&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;The Adventures of Young Indiana Jones: Travels with Father&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Family&quot;
          },
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h4 id="用在过滤器中"><a class="header" href="#用在过滤器中">用在过滤器中</a></h4>
<p>查询示例：史蒂芬·斯皮尔伯格所有包含印第安纳和琼斯字样的电影。<code>@filter(has(director.film))</code>删除了名字为<code>Steven Spielberg</code>但不是导演的节点————数据还包含了一部名为<code>Steven Spielberg</code>的电影中的一个角色。</p>
<pre><code class="language-graphql">{
  me(func: eq(name@en, &quot;Steven Spielberg&quot;)) @filter(has(director.film)) {
    name@en
    director.film @filter(allofterms(name@en, &quot;jones indiana&quot;))  {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Indiana Jones and the Temple of Doom&quot;
          },
          {
            &quot;name@en&quot;: &quot;Indiana Jones and the Raiders of the Lost Ark&quot;
          },
          {
            &quot;name@en&quot;: &quot;Indiana Jones and the Kingdom of the Crystal Skull&quot;
          },
          {
            &quot;name@en&quot;: &quot;Indiana Jones and the Last Crusade&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<h3 id="anyofterms"><a class="header" href="#anyofterms">anyofterms</a></h3>
<p>解析示例：<code>anyofterms(predicate, &quot;space-separated term list&quot;)</code>
Schema类型：<code>string</code>
索引要求：<code>term</code></p>
<p>以任意顺序匹配具有任何指定术语的字符串；不区分大小写。</p>
<h4 id="用在根查询中-1"><a class="header" href="#用在根查询中-1">用在根查询中</a></h4>
<p>查询示例:所有名称包含<code>poison</code>或<code>peacock</code>的节点。许多返回的节点都是电影，但像<code>Joan Peacock</code>这样的人也满足搜索条件，因为没有级联指令，查询就不需要类型：</p>
<pre><code class="language-graphql">{
  me(func:anyofterms(name@en, &quot;poison peacock&quot;)) {
    name@en
    genre {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;The Peacock Spring&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Drama&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;David Peacock&quot;
      },
      {
        &quot;name@en&quot;: &quot;Harry Peacock&quot;
      },
      {
        &quot;name@en&quot;: &quot;Poison Apple&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Family&quot;
          },
          {
            &quot;name@en&quot;: &quot;Fantasy&quot;
          },
          {
            &quot;name@en&quot;: &quot;Short Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Backstage Musical&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h4 id="用在过滤器中-1"><a class="header" href="#用在过滤器中-1">用在过滤器中</a></h4>
<p>查询示例：所有史蒂文·斯皮尔伯格的战争或间谍电影。<code>@filter(has(director.film))</code>删除了名字为<code>Steven Spielberg</code>但不是导演的节点————数据还包含了一部名为<code>Steven Spielberg</code>的电影中的一个角色：</p>
<pre><code class="language-graphql">{
  me(func: eq(name@en, &quot;Steven Spielberg&quot;)) @filter(has(director.film)) {
    name@en
    director.film @filter(anyofterms(name@en, &quot;war spies&quot;))  {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;War Horse&quot;
          },
          {
            &quot;name@en&quot;: &quot;War of the Worlds&quot;
          },
          {
            &quot;name@en&quot;: &quot;Bridge of Spies&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<h3 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h3>
<p>解析示例：<code>regexp(predicate, /regular-expression/)</code> 或者不区分大小写<code>regexp(predicate, /regular-expression/i)</code>
Schema类型：<code>string</code>
索引要求：<code>trigram</code></p>
<p>通过正则表达式匹配字符串。正则表达式语言是<code>go</code>正则表达式的语言。</p>
<p>查询示例：在根节点，在名称开头匹配Steven Sp，后面跟着任意字符。对于每个这样匹配的uid，匹配包含ryan的影片。注意allofterms的不同之处，它只匹配ryan，但是正则表达式搜索也会在terms内匹配，比如bryan：</p>
<pre><code class="language-graphql">{
  directors(func: regexp(name@en, /^Steven Sp.*$/)) {
    name@en
    director.film @filter(regexp(name@en, /ryan/i)) {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;directors&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spencer&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Saving Private Ryan&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg And The Return To Film School&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spohn&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spieldal&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Sperling&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spencer&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spurrier&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spurrier&quot;
      }
    ]
  }
}
</code></pre>
<p><strong>技术细节：</strong>
<code>Trigram</code>是由三个连续的符文组成的子串。例如，Dgraph有三元组合Dgr, gra, rap, aph。
为了保证正则表达式匹配的效率，Dgraph使用了三元组索引。也就是说，Dgraph将正则表达式转换为trigram查询，使用trigram索引和trigram查询来查找可能的匹配，并仅对可能的匹配项应用完整的正则表达式搜索。</p>
<h4 id="dgraph中正则表达式的高效使用和限制"><a class="header" href="#dgraph中正则表达式的高效使用和限制">Dgraph中正则表达式的高效使用和限制</a></h4>
<p>** TODO **</p>
<h3 id="模糊匹配"><a class="header" href="#模糊匹配">模糊匹配</a></h3>
<p>解析规则：<code>match(predicate, string, distance)</code>
Schema类型：<code>string</code>
索引类型：<code>trigram</code></p>
<p>通过计算到字符串的<a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein</a>距离来匹配谓词值，也称为模糊匹配。距离参数必须大于零(0)。使用更大的距离值可以产生更多但不太精确的结果。</p>
<p>查询示例：在根查询处，模糊匹配节点类似于<code>Stephen</code>，距离值小于等于8：</p>
<pre><code class="language-graphql">{
  directors(func: match(name@en, Stephen, 8)) {
    name@en
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;directors&quot;: [
      {
        &quot;name@en&quot;: &quot;Stephen Chen&quot;
      },
      {
        &quot;name@en&quot;: &quot;Step Up 3D&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Bauer&quot;
      },
      {
        &quot;name@en&quot;: &quot;Stephen Chow&quot;
      },
      {
        &quot;name@en&quot;: &quot;Joseph&quot;
      },
      {
        &quot;name@en&quot;: &quot;Ron Steinman&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Blum&quot;
      },
      {
        &quot;name@en&quot;: &quot;The Chef&quot;
      },
    ]
  }
}
</code></pre>
<h3 id="全文搜索"><a class="header" href="#全文搜索">全文搜索</a></h3>
<p>解析规则：<code>alloftext(predicate, &quot;space-separated text&quot;)</code>或者<code>anyoftext(predicate, &quot;space-separated text&quot;)</code>
Schema类型：<code>string</code>
索引要求：<code>fulltext</code></p>
<p>应用带有词干分析和停止词的全文本搜索，以查找与所有或任何给定文本匹配的字符串。</p>
<p>以下步骤在索引生成和处理全文搜索参数时应用：</p>
<ol>
<li>标记化(根据Unicode单词边界)。</li>
<li>转换为小写的。</li>
<li>unicode规范化(到<a href="https://unicode.org/reports/tr15/#Norm_Forms">正规化形式KC</a>)。</li>
<li>词干分析使用特定于语言的词干分析器(如果语言支持的话)。</li>
<li>停止单词删除(如果语言支持)。</li>
</ol>
<p><code>Dgraph</code>使用<a href="https://github.com/blevesearch/bleve">bleve</a>进行全文搜索索引。请参阅bleve语言特定的<a href="https://github.com/blevesearch/bleve/tree/master/analysis/lang">停止单词列表</a>。</p>
<p>下表包含所有支持的语言，相应的国家代码，词干和停止词过滤支持：</p>
<blockquote>
<p>todo</p>
</blockquote>
<p>查询示例：所有包含<code>dog</code>, <code>dogs</code>, <code>bark</code>, <code>bark</code>, <code>bark</code>等的名称。停止字删除消除和<code>which</code>：</p>
<pre><code class="language-graphql">{
  movie(func:alloftext(name@en, &quot;the dog which barks&quot;)) {
    name@en
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;movie&quot;: [
      {
        &quot;name@en&quot;: &quot;Black Dogs Barking&quot;
      },
      {
        &quot;name@en&quot;: &quot;Elliott Erwitt: 'I Bark at Dogs&quot;
      },
      {
        &quot;name@en&quot;: &quot;Barking Dogs&quot;
      },
      {
        &quot;name@en&quot;: &quot;Barking Dogs Never Bite&quot;
      },
      {
        &quot;name@en&quot;: &quot;Do You Hear the Dogs Barking?&quot;
      },
      {
        &quot;name@en&quot;: &quot;But The Word Dog Doesn’t Bark&quot;
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="等于"><a class="header" href="#等于">等于</a></h3>
<p>解析示例：</p>
<ul>
<li><code>eq(predicate, value)</code></li>
<li><code>eq(val(varName), value)</code></li>
<li><code>eq(predicate, val(varName))</code></li>
<li><code>eq(count(predicate), value)</code></li>
<li><code>eq(predicate, [val1, val2, val3])</code></li>
<li><code>eq(predicate, [$var1, &quot;value2&quot;, ..., $varN])</code></li>
</ul>
<p>Schema类型：<code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code>, <code>dateTime</code>
索引要求：在查询根处使用<code>eq(predicate, ...)</code>形式时需要索引(见下表)。对于查询根的<code>count</code>(谓词)，需要<code>@count</code>索引。对于变量，值是作为查询的一部分计算的，因此不需要索引：</p>
<table><thead><tr><th>类型</th><th>索引要求</th></tr></thead><tbody>
<tr><td>int</td><td>int</td></tr>
<tr><td>float</td><td>float</td></tr>
<tr><td>bool</td><td>bool</td></tr>
<tr><td>string</td><td>exact hash term fulltext</td></tr>
<tr><td>dateTime</td><td>dateTime</td></tr>
<tr><td>布尔常量分别为<code>true</code>和<code>false</code>，因此使用<code>eq</code>时，就变成了，例如，<code>eq(boolPred, true)</code>。</td><td></td></tr>
</tbody></table>
<p>查询示例：查询具有十三种流派的电影，并返回十三种流派的名字：</p>
<pre><code class="language-graphql">{
  me(func: eq(count(genre), 13)) {
    name@en
    genre {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Stay Tuned&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Horror&quot;
          },
          {
            &quot;name@en&quot;: &quot;Science Fiction&quot;
          },
          {
            &quot;name@en&quot;: &quot;Thriller&quot;
          },
          {
            &quot;name@en&quot;: &quot;Family&quot;
          }
          ...
        ]
      },
       {
        &quot;name@en&quot;: &quot;Trollhunters&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Horror&quot;
          },
        ]
       }
       ...
    ]
  }
}
</code></pre>
<p>查询示例：导演叫史蒂文，他曾经导演过1、2或3部电影：</p>
<pre><code class="language-graphql">{
  steve as var(func: allofterms(name@en, &quot;Steven&quot;)) {
    films as count(director.film)
  }
  stevens(func: uid(steve)) @filter(eq(val(films), [1,2,3])) {
    name@en
    numFilms: val(films)
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;stevens&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Wilsey&quot;,
        &quot;numFilms&quot;: 1
      },
      {
        &quot;name@en&quot;: &quot;Steven Bratter&quot;,
        &quot;numFilms&quot;: 1
      },
      {
        &quot;name@en&quot;: &quot;Steven Saussey&quot;,
        &quot;numFilms&quot;: 1
      },
      {
        &quot;name@en&quot;: &quot;Steven Ray Morris&quot;,
        &quot;numFilms&quot;: 1
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="小于小于或等于大于大于或等于"><a class="header" href="#小于小于或等于大于大于或等于">小于、小于或等于、大于、大于或等于</a></h3>
<p>解析示例：(假设不等号是<code>IE</code>)</p>
<ul>
<li>IE(predicate, value)</li>
<li>IE(val(varName), value)</li>
<li>IE(predicate, val(varName))</li>
<li>IE(count(predicate), value)</li>
</ul>
<p><code>IE</code>的可能取值：</p>
<ul>
<li><code>le</code>: 小于或等于(less than or equal to)</li>
<li><code>lt</code>: 小于(less than)</li>
<li><code>ge</code>: 大于或等于(greater than or equal to)</li>
<li><code>gt</code>: 大于(greater than)</li>
</ul>
<p>Schema类型：<code>int</code>, <code>float</code>, <code>string</code>, <code>dateTime</code></p>
<p>索引要求：当不等式查询<code>IE</code>用在根查询时，需要下表的索引要求。对于用在根查询的<code>count(predicate)</code>，则需要<code>@count</code>索引。对于变量，因为变量是在查询中计算的一部分，所以不需要索引。
类型|索引要求
---| ---
int|int
float| float
string|string
dateTime|dateTime</p>
<p>查询示例：列举<code>Ridley Scott</code>在1980年之前导演的电影：</p>
<pre><code class="language-graphql">{
  me(func: eq(name@en, &quot;Ridley Scott&quot;)) {
    name@en
    director.film @filter(lt(initial_release_date, &quot;1980-01-01&quot;))  {
      initial_release_date
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Ridley Scott&quot;,
        &quot;director.film&quot;: [
          {
            &quot;initial_release_date&quot;: &quot;1979-05-25T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;Alien&quot;
          },
          {
            &quot;initial_release_date&quot;: &quot;1977-12-01T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;The Duellists&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Ridley Scott&quot;
      }
    ]
  }
}
</code></pre>
<p>查询示例：以史蒂文为导演的同名电影，曾执导过100多名演员。</p>
<pre><code class="language-graphql">{
  ID as var(func: allofterms(name@en, &quot;Steven&quot;)) {
    director.film {
      num_actors as count(starring)
    }
    total as sum(val(num_actors))
  }

  dirs(func: uid(ID)) @filter(gt(val(total), 100)) {
    name@en
    total_actors : val(total)
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;dirs&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Conrad&quot;,
        &quot;total_actors&quot;: 122
      },
      {
        &quot;name@en&quot;: &quot;Steven Knight&quot;,
        &quot;total_actors&quot;: 102
      },
      {
        &quot;name@en&quot;: &quot;Steven Zaillian&quot;,
        &quot;total_actors&quot;: 123
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;total_actors&quot;: 1665
      },
      {
        &quot;name@en&quot;: &quot;Steven Brill&quot;,
        &quot;total_actors&quot;: 417
      }
      ...
    ]
  }
}
</code></pre>
<p>查询示例：每类电影超过30000部的电影。因为在类型上没有指定顺序，所以顺序将通过UID。<code>count</code>索引记录节点的边数，并使这样的查询更多：</p>
<pre><code class="language-graphql">{
  genre(func: gt(count(~genre), 30000)){
    name@en
    ~genre (first:1) {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;genre&quot;: [
      {
        &quot;name@en&quot;: &quot;Documentary film&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Wild Things&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Drama&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;José María y María José: Una pareja de hoy&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Comedy&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;José María y María José: Una pareja de hoy&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Short Film&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Side Effects&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>查询示例：叫<code>Steven</code>的导演和他们的电影<code>initial_release_date</code>大于电影<code>Minority Report</code>的电影：</p>
<pre><code class="language-graphql">{
  var(func: eq(name@en,&quot;Minority Report&quot;)) {
    d as initial_release_date
  }
  me(func: eq(name@en, &quot;Steven Spielberg&quot;)) {
    name@en
    director.film @filter(ge(initial_release_date, val(d))) {
      initial_release_date
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;director.film&quot;: [
          {
            &quot;initial_release_date&quot;: &quot;2012-10-08T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;Lincoln&quot;
          },
          {
            &quot;initial_release_date&quot;: &quot;2011-12-04T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;War Horse&quot;
          },
          {
            &quot;initial_release_date&quot;: &quot;2005-06-13T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;War of the Worlds&quot;
          },
          {
            &quot;initial_release_date&quot;: &quot;2002-06-17T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;Minority Report&quot;
          }
          ...
        ]
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;
      }
    ]
  }
}
</code></pre>
<h3 id="between"><a class="header" href="#between">between</a></h3>
<p>解析规则：<code>between(predicate, startDateValue, endDateValue)</code>
Schema类型：<code>Scalar Type</code>, <code>dateTime</code>, <code>int</code>, <code>float</code>, <code>string</code>
索引要求：<code>dateTime</code>, <code>int</code>, <code>float</code>, <code>exact</code></p>
<p>返回与索引值的包含范围相匹配的节点。<code>between</code>关键字对索引执行范围检查，以提高查询效率，有助于防止对大数据集进行大范围查询时运行缓慢。</p>
<p><code>between</code>关键字的一个常见用例是在由<code>dateTime</code>索引的数据集中进行搜索。下面的示例查询演示了这个用例。</p>
<p>查询示例：1977年首次上映的电影，按类型列出：</p>
<pre><code class="language-graphql">{
  me(func: between(initial_release_date, &quot;1977-01-01&quot;, &quot;1977-12-31&quot;)) {
    name@en
    genre {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;SST: Death Flight&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Drama&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Lucio Flavio&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Crime Fiction&quot;
          },
          {
            &quot;name@en&quot;: &quot;Drama&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Uyarnthavargal&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;World cinema&quot;
          },
          {
            &quot;name@en&quot;: &quot;Drama&quot;
          },
          {
            &quot;name@en&quot;: &quot;Musical Drama&quot;
          },
          {
            &quot;name@en&quot;: &quot;Backstage Musical&quot;
          },
          {
            &quot;name@en&quot;: &quot;Tamil cinema&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="uid"><a class="header" href="#uid">uid</a></h3>
<p>解析示例：</p>
<ul>
<li><code>q(func:uid(&lt;uid&gt;))</code></li>
<li><code>predicate @filter(uid(&lt;uid1&gt;, ..., &lt;uidn&gt;))</code></li>
<li><code>predicate @filter(uid(a))</code> 对变量<code>a</code>使用</li>
<li><code>q(func:uid(a, b))</code> 对变量<code>a</code>和<code>b</code>使用</li>
<li><code>q(func:uid($uids))</code> 对一组uid使用，例如<code>[0x1, 0x2, 0x3, ..., 0xn]</code></li>
</ul>
<p>仅将当前查询级别的节点过滤为给定<code>uid</code>集合中的节点。</p>
<p>对于查询变量<code>a</code>, <code>uid(a)</code>表示存储在<code>a</code>中的<code>uid</code>集合，对于值变量<code>b</code>, <code>uid(b)</code>表示<code>uid</code>到<code>value</code>映射的<code>uid</code>集合。对于两个或多个变量，<code>uid(a,b，…)</code>表示所有变量的并集。</p>
<p><code>uid(&lt;uid&gt;)</code>与标识函数一样，即使节点没有任何边，也将返回所请求的<code>uid</code>。</p>
<p>查询示例：按已知<code>UID</code>查询<code>Priyanka Chopra</code>的胶片：</p>
<pre><code class="language-graphql">{
  films(func: uid(0x2c964)) {
    name@hi
    actor.film {
      performance.film {
        name@hi
      }
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;films&quot;: [
      {
        &quot;name@hi&quot;: &quot;प्रियंका चोपड़ा&quot;,
        &quot;actor.film&quot;: [
          {
            &quot;performance.film&quot;: [
              {
                &quot;name@hi&quot;: &quot;यकीन&quot;
              }
            ]
          },
          {
            &quot;performance.film&quot;: [
              {
                &quot;name@hi&quot;: &quot;सलाम-ए-इश्क़&quot;
              }
            ]
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<p>查询示例：塔拉吉·汉森的电影按类型分类：</p>
<pre><code class="language-graphql">{
  var(func: allofterms(name@en, &quot;Taraji Henson&quot;)) {
    actor.film {
      F as performance.film {
        G as genre
      }
    }
  }

  Taraji_films_by_genre(func: uid(G)) {
    genre_name : name@en
    films : ~genre @filter(uid(F)) {
      film_name : name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;Taraji_films_by_genre&quot;: [
      {
        &quot;genre_name&quot;: &quot;War film&quot;,
        &quot;films&quot;: [
          {
            &quot;film_name&quot;: &quot;Talk to Me&quot;
          }
        ]
      },
      {
        &quot;genre_name&quot;: &quot;Horror&quot;,
        &quot;films&quot;: [
          {
            &quot;film_name&quot;: &quot;Satan's School for Girls&quot;
          }
        ]
      },
      {
        &quot;genre_name&quot;: &quot;Indie film&quot;,
        &quot;films&quot;: [
          {
            &quot;film_name&quot;: &quot;Once Fallen&quot;
          },
          {
            &quot;film_name&quot;: &quot;Peep World&quot;
          },
          {
            &quot;film_name&quot;: &quot;Hustle &amp; Flow&quot;
          },
          {
            &quot;film_name&quot;: &quot;All or Nothing&quot;
          },
          {
            &quot;film_name&quot;: &quot;Hair Show&quot;
          }
        ]
      },
      {
        &quot;genre_name&quot;: &quot;Crime&quot;,
        &quot;films&quot;: [
          {
            &quot;film_name&quot;: &quot;Term Life&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<p>查询示例：<code>Taraji Henson</code>的电影按体裁数量排序，体裁列表按<code>Taraji</code>在每个体裁中制作的电影数量排序：</p>
<pre><code class="language-graphql">{
  var(func: allofterms(name@en, &quot;Taraji Henson&quot;)) {
    actor.film {
      F as performance.film {
        G as count(genre)
        genre {
          C as count(~genre @filter(uid(F)))
        }
      }
    }
  }
  Taraji_films_by_genre_count(func: uid(G), orderdesc: val(G)) {
    film_name : name@en
    genres : genre (orderdesc: val(C)) {
      genre_name : name@en
    }
  }
}

</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;Taraji_films_by_genre_count&quot;: [
      {
        &quot;film_name&quot;: &quot;Date Night&quot;,
        &quot;genres&quot;: [
          {
            &quot;genre_name&quot;: &quot;Comedy&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Crime Fiction&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Romance Film&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Thriller&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Action Film&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Romantic comedy&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Action/Adventure&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Action Comedy&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Chase Movie&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Screwball comedy&quot;
          }
        ]
      },
      {
        &quot;film_name&quot;: &quot;I Can Do Bad All by Myself&quot;,
        &quot;genres&quot;: [
          {
            &quot;genre_name&quot;: &quot;Drama&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Comedy&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Romance Film&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Romantic comedy&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Comedy-drama&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Musical Drama&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Backstage Musical&quot;
          },
          {
            &quot;genre_name&quot;: &quot;Musical comedy&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="uid_in"><a class="header" href="#uid_in">uid_in</a></h3>
<p>解析示例：</p>
<ul>
<li><code>q(func: ...) @filter(uid_in(predicate, &lt;uid&gt;))</code></li>
<li><code>predicate1 @filter(uid_in(predicate2, &lt;uid&gt;))</code></li>
<li><code>predicate1 @filter(uid_in(predicate2, [&lt;uid1&gt;, ..., &lt;uid2&gt;]))</code></li>
<li><code>predicate1 @filter(uid_in(predicate2, uid(myVariable)))</code>
Schema类型：UID
索引要求：无</li>
</ul>
<p>虽然<code>uid</code>函数基于<code>uid</code>在当前级别上过滤节点，但<code>uid_in</code>函数允许沿着边缘向前查找，以检查它是否指向特定的<code>uid</code>。这通常可以节省额外的查询块，并避免返回边缘。</p>
<p><code>uid_in</code>不能在根查询下使用。它接受多个<code>UID</code>作为它的参数，并接受一个<code>UID</code>变量(它可以包含<code>UID</code>的映射)。</p>
<p>查询示例：<code>Marc Caro</code>和<code>Jean-Pierre Jeunet</code>的协作关系<code>(UID 0x99706)</code>。如果<code>Jean-Pierre Jeunet</code>的<code>UID</code>是已知的，那么以这种方式查询就不需要用一个块将他的<code>UID</code>提取到一个变量中，也不需要对<code>~director.film</code>进行额外的边遍历和过滤器：</p>
<pre><code class="language-graphql">{
  caro(func: eq(name@en, &quot;Marc Caro&quot;)) {
    name@en
    director.film @filter(uid_in(~director.film, 0x99706)) {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;caro&quot;: [
      {
        &quot;name@en&quot;: &quot;Marc Caro&quot;
      }
    ]
  }
}
</code></pre>
<p>如果不知道<code>Jean-Pierre Jeunet</code>的<code>UID</code>，还可以查询他的<code>UID</code>，并在<code>UID</code>变量中使用它：</p>
<pre><code class="language-graphql">{
  getJeunet as q(func: eq(name@fr, &quot;Jean-Pierre Jeunet&quot;))

  caro(func: eq(name@en, &quot;Marc Caro&quot;)) {
    name@en
    director.film @filter(uid_in(~director.film, uid(getJeunet) )) {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [],
    &quot;caro&quot;: [
      {
        &quot;name@en&quot;: &quot;Marc Caro&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;The City of Lost Children&quot;
          },
          {
            &quot;name@en&quot;: &quot;Delicatessen&quot;
          },
          {
            &quot;name@en&quot;: &quot;The Bunker of the Last Gunshots&quot;
          },
          {
            &quot;name@en&quot;: &quot;L'évasion&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<h3 id="has"><a class="header" href="#has">has</a></h3>
<p>解析规则：<code>has(predicate)</code></p>
<p>Schema使用类型：所有</p>
<p>确定节点是否具有特定谓词。</p>
<p>查询示例：前五位导演和他们所有的电影都有一个上映日期记录。导演已经指导了至少一个电影————等效语义<code>gt(count(director.film), 0)</code>：</p>
<pre><code class="language-graphql">{
  me(func: has(director.film), first: 5) {
    name@en
    director.film @filter(has(initial_release_date))  {
      initial_release_date
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Zehra Yiğit&quot;
      },
      {
        &quot;name@en&quot;: &quot;Charlton Heston&quot;,
        &quot;director.film&quot;: [
          {
            &quot;initial_release_date&quot;: &quot;1982-09-23T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;Mother Lode&quot;
          },
          {
            &quot;initial_release_date&quot;: &quot;1972-03-02T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;Antony and Cleopatra&quot;
          },
          {
            &quot;initial_release_date&quot;: &quot;1988-12-21T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;A Man for All Seasons&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Rajeev Sharma&quot;,
        &quot;director.film&quot;: [
          {
            &quot;initial_release_date&quot;: &quot;2012-01-01T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;Nabar&quot;
          },
          {
            &quot;initial_release_date&quot;: &quot;2014-05-30T00:00:00Z&quot;,
            &quot;name@en&quot;: &quot;47 to 84&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="geolocation-地理位置"><a class="header" href="#geolocation-地理位置">Geolocation 地理位置</a></h3>
<h4 id="变更"><a class="header" href="#变更">变更</a></h4>
<p>要使用geo函数，您需要谓词上的索引。</p>
<pre><code class="language-schema">loc: geo @index(geo) .
</code></pre>
<p>下面是如何添加一个点：</p>
<pre><code class="language-dql">{
  set {
    &lt;_:0xeb1dde9c&gt; &lt;loc&gt; &quot;{'type':'Point','coordinates':[-122.4220186,37.772318]}&quot;^^&lt;geo:geojson&gt; .
    &lt;_:0xeb1dde9c&gt; &lt;name&gt; &quot;Hamon Tower&quot; .
    &lt;_:0xeb1dde9c&gt; &lt;dgraph.type&gt; &quot;Location&quot; .
  }
}
</code></pre>
<p>下面是如何将一个多边形与一个节点关联。添加多多边形也是类似的：</p>
<pre><code class="language-dql">{
  set {
    &lt;_:0xf76c276b&gt; &lt;loc&gt; &quot;{'type':'Polygon','coordinates':[[[-122.409869,37.7785442],[-122.4097444,37.7786443],[-122.4097544,37.7786521],[-122.4096334,37.7787494],[-122.4096233,37.7787416],[-122.4094004,37.7789207],[-122.4095818,37.7790617],[-122.4097883,37.7792189],[-122.4102599,37.7788413],[-122.409869,37.7785442]],[[-122.4097357,37.7787848],[-122.4098499,37.778693],[-122.4099025,37.7787339],[-122.4097882,37.7788257],[-122.4097357,37.7787848]]]}&quot;^^&lt;geo:geojson&gt; .
    &lt;_:0xf76c276b&gt; &lt;name&gt; &quot;Best Western Americana Hotel&quot; .
    &lt;_:0xf76c276b&gt; &lt;dgraph.type&gt; &quot;Location&quot; .
  }
}
</code></pre>
<p>以上的例子是从我们的<a href="https://github.com/dgraph-io/benchmarks/blob/master/data/sf.tourism.gz?raw=true">SF旅游数据集</a>中挑选出来的。</p>
<h4 id="查询"><a class="header" href="#查询">查询</a></h4>
<p><strong>near 附近查询</strong></p>
<p>解析示例：<code>near(predicate, [long, lat], distance)</code></p>
<p>Schema类型：<code>geo</code></p>
<p>索引要求：<code>geo</code></p>
<p>匹配所有由谓词给出的位置在距离geojson坐标<code>[long, lat]</code>米范围内的实体。</p>
<p>查询示例：旧金山金门公园某点1000米(1公里)以内的旅游目的地：</p>
<pre><code class="language-graphql">{
  tourist(func: near(loc, [-122.469829, 37.771935], 1000) ) {
    name
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;tourist&quot;: [
      {
        &quot;name&quot;: &quot;Peace Lantern&quot;
      },
      {
        &quot;name&quot;: &quot;De Young Museum&quot;
      },
      {
        &quot;name&quot;: &quot;Buddha&quot;
      },
      {
        &quot;name&quot;: &quot;Morrison Planetarium&quot;
      },
      {
        &quot;name&quot;: &quot;Chinese Pavillion&quot;
      },
      {
        &quot;name&quot;: &quot;Strawberry Hill&quot;
      }
      ...
    ]
  }
}
</code></pre>
<p><strong>within 在给定范围之内</strong></p>
<p><strong>contains 包含</strong></p>
<p><strong>intersects 相交</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-filters-联合过滤"><a class="header" href="#connecting-filters-联合过滤">Connecting Filters 联合过滤</a></h1>
<p>在<code>@filter</code>中，多个函数可以与布尔连接符一起使用。</p>
<h2 id="and与or或not非"><a class="header" href="#and与or或not非">AND(与)、OR(或)、NOT(非)</a></h2>
<p>连接词<code>AND</code>、<code>OR</code>和<code>NOT</code>连接过滤器，可以构建到任意复杂的过滤器中，如<code>(NOT A OR B)</code>和<code>(C AND NOT (D OR E))</code>。注意，<code>NOT</code>绑定比<code>AND</code>绑定更紧密，<code>AND</code>绑定比<code>OR</code>绑定更紧密。</p>
<p>查询示例：所有史蒂芬·斯皮尔伯格<code>(Steven Spielberg)</code>同时包含“indiana”和“jones”或“jurassic”和“park”的电影：</p>
<pre><code class="language-graphql">{
  me(func: eq(name@en, &quot;Steven Spielberg&quot;)) @filter(has(director.film)) {
    name@en
    director.film @filter(allofterms(name@en, &quot;jones indiana&quot;) OR allofterms(name@en, &quot;jurassic park&quot;))  {
      uid
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;director.film&quot;: [
          {
            &quot;uid&quot;: &quot;0x9a41&quot;,
            &quot;name@en&quot;: &quot;Indiana Jones and the Temple of Doom&quot;
          },
          {
            &quot;uid&quot;: &quot;0x1cde3&quot;,
            &quot;name@en&quot;: &quot;Jurassic Park&quot;
          },
          {
            &quot;uid&quot;: &quot;0x2868c&quot;,
            &quot;name@en&quot;: &quot;Indiana Jones and the Raiders of the Lost Ark&quot;
          },
          {
            &quot;uid&quot;: &quot;0x42164&quot;,
            &quot;name@en&quot;: &quot;Indiana Jones and the Kingdom of the Crystal Skull&quot;
          },
          {
            &quot;uid&quot;: &quot;0x483f3&quot;,
            &quot;name@en&quot;: &quot;The Lost World: Jurassic Park&quot;
          },
          {
            &quot;uid&quot;: &quot;0x54387&quot;,
            &quot;name@en&quot;: &quot;Indiana Jones and the Last Crusade&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases-别名"><a class="header" href="#aliases-别名">Aliases 别名</a></h1>
<p>解析示例：</p>
<ul>
<li>aliasName: predicate</li>
<li>aliasName: predicate { ... }</li>
<li>aliasName: varName as ...</li>
<li>aliasName: count(predicate)</li>
<li>aliasName: max(val(varName))</li>
</ul>
<p>别名在结果中提供替代名称。谓词、变量和聚合可以通过以别名和:作为前缀来别名。别名不必与原始谓词名不同，但是，在一个块中，别名必须与谓词名和同一块中返回的其他别名不同。别名可用于在一个块内多次返回相同的谓词。</p>
<p>查询示例：姓名匹配词<code>Steven</code>的导演，他们的<code>UID</code>，英文名，每部电影的平均演员人数，电影总数，以及每部电影的英文和法文名称：</p>
<pre><code class="language-graphql">{
  ID as var(func: allofterms(name@en, &quot;Steven&quot;)) @filter(has(director.film)) {
    director.film {
      num_actors as count(starring)
    }
    average as avg(val(num_actors))
  }

  films(func: uid(ID)) {
    director_id : uid
    english_name : name@en
    average_actors : val(average)
    num_films : count(director.film)

    films : director.film {
      name : name@en
      english_name : name@en
      french_name : name@fr
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;films&quot;: [
      {
        &quot;director_id&quot;: &quot;0x33a6&quot;,
        &quot;english_name&quot;: &quot;Steven Wilsey&quot;,
        &quot;average_actors&quot;: 0,
        &quot;num_films&quot;: 1,
        &quot;films&quot;: [
          {
            &quot;name&quot;: &quot;At Night I Was Beautiful&quot;,
            &quot;english_name&quot;: &quot;At Night I Was Beautiful&quot;
          }
        ]
      },
      {
        &quot;director_id&quot;: &quot;0x3ce3&quot;,
        &quot;english_name&quot;: &quot;Steven Bratter&quot;,
        &quot;average_actors&quot;: 10,
        &quot;num_films&quot;: 1,
        &quot;films&quot;: [
          {
            &quot;name&quot;: &quot;First Strike&quot;,
            &quot;english_name&quot;: &quot;First Strike&quot;
          }
        ]
      },
      {
        &quot;director_id&quot;: &quot;0x57c8&quot;,
        &quot;english_name&quot;: &quot;Steven Saussey&quot;,
        &quot;average_actors&quot;: 3,
        &quot;num_films&quot;: 1,
        &quot;films&quot;: [
          {
            &quot;name&quot;: &quot;Whisker&quot;,
            &quot;english_name&quot;: &quot;Whisker&quot;
          }
        ]
      },
      {
        &quot;director_id&quot;: &quot;0x9740&quot;,
        &quot;english_name&quot;: &quot;Steven Ray Morris&quot;,
        &quot;average_actors&quot;: 8,
        &quot;num_films&quot;: 1,
        &quot;films&quot;: [
          {
            &quot;name&quot;: &quot;The Premiere&quot;,
            &quot;english_name&quot;: &quot;The Premiere&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pagination-分页"><a class="header" href="#pagination-分页">Pagination 分页</a></h1>
<p>分页允许你只获取一部分而不是整个结果集。这对于<code>top-k</code>样式的查询以及减少客户端处理的结果集的大小或允许对结果进行分页访问都很有用。</p>
<p>分页通常与排序一起使用。</p>
<blockquote>
<p>如果没有指定排序顺序，结果将按照uid进行排序，uid是随机分配的。因此，虽然顺序是确定的，但可能不是你所期望的。</p>
</blockquote>
<h2 id="first-参数"><a class="header" href="#first-参数">First 参数</a></h2>
<p>解析示例：</p>
<ul>
<li><code>q(func: ..., first: N)</code></li>
<li><code>predicate (first: N) { ... }</code></li>
<li><code>predicate @filter(...) (first: N) { ... }</code></li>
</ul>
<p>对于<code>N &gt; 0</code>, <code>first: N</code>按排序或<code>UID</code>顺序检索前<code>N</code>个结果。</p>
<p>对于<code>N &lt; 0</code>, <code>first: N</code>按排序或<code>UID</code>顺序检索最后<code>N</code>个结果。目前，只有当没有应用顺序时，才支持负数。为了在排序中获得负数的效果，颠倒排序的顺序并使用正的<code>N</code>。</p>
<p>查询示例：最后两部电影，按UID排序，由史蒂文·斯皮尔伯格执导，前三种类型的电影，按英文名的字母顺序排序：</p>
<pre><code class="language-graphql">{
  me(func: allofterms(name@en, &quot;Steven Spielberg&quot;)) {
    director.film (first: -2) {
      name@en
      initial_release_date
      genre (orderasc: name@en) (first: 3) {
          name@en
      }
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Firelight&quot;,
            &quot;initial_release_date&quot;: &quot;1964-03-24T00:00:00Z&quot;,
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Science Fiction&quot;
              },
              {
                &quot;name@en&quot;: &quot;Thriller&quot;
              }
            ]
          },
          {
            &quot;name@en&quot;: &quot;Amazing Stories: Book One&quot;,
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Comedy&quot;
              },
              {
                &quot;name@en&quot;: &quot;Drama&quot;
              }
            ]
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>查询例：在所有叫史蒂文的导演中，导演演员最多的三位叫史蒂文的导演：</p>
<pre><code class="language-graphql">{
  ID as var(func: allofterms(name@en, &quot;Steven&quot;)) @filter(has(director.film)) {
    director.film {
      stars as count(starring)
    }
    totalActors as sum(val(stars))
  }

  mostStars(func: uid(ID), orderdesc: val(totalActors), first: 3) {
    name@en
    stars : val(totalActors)

    director.film {
      name@en
    }
  }
}
</code></pre>
<p>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;mostStars&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;stars&quot;: 1665,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Hook&quot;
          },
          {
            &quot;name@en&quot;: &quot;The Color Purple&quot;
          },
          {
            &quot;name@en&quot;: &quot;Schindler's List&quot;
          },
          {
            &quot;name@en&quot;: &quot;Amistad&quot;
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="offset-参数"><a class="header" href="#offset-参数">Offset 参数</a></h2>
<p>语法示例：</p>
<ul>
<li><code>q(func: ..., offset: N)</code></li>
<li><code>predicate (offset: N) { ... }</code></li>
<li><code>predicate (first: M, offset: N) { ... }</code></li>
<li><code>predicate @filter(...) (offset: N) { ... }</code></li>
</ul>
<p>通过指定<code>offset: N</code>，查询结果的前<code>N</code>就不会返回在结果集中。结合前面介绍的<code>first: M</code>使用，例如<code>first: M, offset: N</code>，就能跳过前面<code>N</code>个结果，只返回接下来的<code>M</code>个结果。</p>
<p>查询示例：查询英文名字为<code>Hark Tsui</code>的影片，跳过前面<code>4</code>个，返回接下来的<code>6</code>个。</p>
<pre><code class="language-dql">{
  me(func: allofterms(name@en, &quot;Hark Tsui&quot;)) {
    name@zh
    name@en
    director.film (orderasc: name@en) (first:6, offset:4)  {
      genre {
        name@en
      }
      name@zh
      name@en
      initial_release_date
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@zh&quot;: &quot;徐克&quot;,
        &quot;name@en&quot;: &quot;Tsui Hark&quot;,
        &quot;director.film&quot;: [
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Science Fiction&quot;
              },
              {
                &quot;name@en&quot;: &quot;Superhero movie&quot;
              },
              {
                &quot;name@en&quot;: &quot;World cinema&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action/Adventure&quot;
              },
              {
                &quot;name@en&quot;: &quot;Chinese Movies&quot;
              },
              {
                &quot;name@en&quot;: &quot;Martial Arts Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action Film&quot;
              }
            ],
            &quot;name@en&quot;: &quot;Black Mask 2: City of Masks&quot;,
            &quot;initial_release_date&quot;: &quot;2002-01-01T00:00:00Z&quot;
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Adventure game&quot;
              },
              {
                &quot;name@en&quot;: &quot;Drama&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action Film&quot;
              }
            ],
            &quot;name@zh&quot;: &quot;狄仁杰之通天帝国&quot;,
            &quot;name@en&quot;: &quot;Detective Dee: Mystery of the Phantom Flame&quot;,
            &quot;initial_release_date&quot;: &quot;2010-09-05T00:00:00Z&quot;
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Thriller&quot;
              },
              {
                &quot;name@en&quot;: &quot;Crime Fiction&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action Film&quot;
              }
            ],
            &quot;name@en&quot;: &quot;Don't Play with Fire&quot;,
            &quot;initial_release_date&quot;: &quot;1980-12-04T00:00:00Z&quot;
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Thriller&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action/Adventure&quot;
              },
              {
                &quot;name@en&quot;: &quot;Martial Arts Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action Thriller&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Buddy film&quot;
              }
            ],
            &quot;name@en&quot;: &quot;Double Team&quot;,
            &quot;initial_release_date&quot;: &quot;1997-04-04T00:00:00Z&quot;
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Adventure Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Drama&quot;
              },
              {
                &quot;name@en&quot;: &quot;Martial Arts Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action Film&quot;
              }
            ],
            &quot;name@zh&quot;: &quot;龙门飞甲&quot;,
            &quot;name@en&quot;: &quot;Flying Swords of Dragon Gate&quot;,
            &quot;initial_release_date&quot;: &quot;2011-12-15T00:00:00Z&quot;
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;World cinema&quot;
              },
              {
                &quot;name@en&quot;: &quot;Adventure Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Romance Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Action/Adventure&quot;
              },
              {
                &quot;name@en&quot;: &quot;Drama&quot;
              },
              {
                &quot;name@en&quot;: &quot;Fantasy&quot;
              },
              {
                &quot;name@en&quot;: &quot;Chinese Movies&quot;
              },
              {
                &quot;name@en&quot;: &quot;Romantic fantasy&quot;
              },
              {
                &quot;name@en&quot;: &quot;Costume Adventure&quot;
              },
              {
                &quot;name@en&quot;: &quot;Fantasy Adventure&quot;
              }
            ],
            &quot;name@zh&quot;: &quot;青蛇&quot;,
            &quot;name@en&quot;: &quot;Green Snake&quot;,
            &quot;initial_release_date&quot;: &quot;1993-01-01T00:00:00Z&quot;
          }
        ]
      },
      {
        &quot;name@zh&quot;: &quot;小倩&quot;,
        &quot;name@en&quot;: &quot;A Chinese Ghost Story: The Tsui Hark Animation&quot;
      },
      {
        &quot;name@en&quot;: &quot;Tsui Hark Movie Studio&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="after-参数"><a class="header" href="#after-参数">After 参数</a></h2>
<p>语法示例：</p>
<ul>
<li><code>q(func: ..., after: UID)</code></li>
<li><code>predicate (first: N, after: UID) { ... }</code></li>
<li><code>predicate @filter(...) (first: N, after: UID) { ... }</code></li>
</ul>
<p>另一个具有类似跳过功能的是使用默认<code>UID</code>排序时，能够直接指定<code>after: UID</code>，然后获取该<code>UID</code>之后的查询结果。例如，在一个常见的场景中，第一个查询是<code>predicate (after: 0x00, first: N)</code>或<code>predicate (first: N)</code>的形式，接下来的查询都用<code>predicate (after: &lt;上一次查询的结果中的uid&gt;, first: N)</code>。</p>
<p>查询示例：查询<code>Baz Luhrmann</code>的前<code>5</code>部影片，以<code>UID</code>排序：</p>
<pre><code class="language-dql">{
  me(func: allofterms(name@en, &quot;Baz Luhrmann&quot;)) {
    name@en
    director.film (first:5) {
      uid
      name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Baz Luhrmann&quot;,
        &quot;director.film&quot;: [
          {
            &quot;uid&quot;: &quot;0x434&quot;,
            &quot;name@en&quot;: &quot;The Great Gatsby&quot;
          },
          {
            &quot;uid&quot;: &quot;0x1e0d&quot;,
            &quot;name@en&quot;: &quot;Strictly Ballroom&quot;
          },
          {
            &quot;uid&quot;: &quot;0x11bdb&quot;,
            &quot;name@en&quot;: &quot;Moulin Rouge!&quot;
          },
          {
            &quot;uid&quot;: &quot;0x27c60&quot;,
            &quot;name@en&quot;: &quot;Romeo + Juliet&quot;
          },
          {
            &quot;uid&quot;: &quot;0x2e760&quot;,
            &quot;name@en&quot;: &quot;Australia&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>第五部电影是澳大利亚经典电影<code>Strictly Ballroom</code>。它的<code>UID</code>是<code>0x99e44</code>。在<code>Strictly Ballroom</code>影片之后的电影可以通过携带<code>after: N</code>参数的查询获取：</p>
<pre><code class="language-dql">{
  me(func: allofterms(name@en, &quot;Baz Luhrmann&quot;)) {
    name@en
    director.film (first:5, after: 0x99e44) {
      uid
      name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Baz Luhrmann&quot;,
        &quot;director.film&quot;: [
          {
            &quot;uid&quot;: &quot;0xce247&quot;,
            &quot;name@en&quot;: &quot;Puccini: La Boheme (Sydney Opera)&quot;
          },
          {
            &quot;uid&quot;: &quot;0xe40e5&quot;,
            &quot;name@en&quot;: &quot;No. 5 the Film&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count-计数"><a class="header" href="#count-计数">Count 计数</a></h1>
<p>语法示例：</p>
<ul>
<li><code>count(predicate)</code></li>
<li><code>count(uid)</code></li>
</ul>
<p><code>count(predicate)</code>计算节点的边的数量。</p>
<p><code>count(uid)</code>统计在封闭块中匹配的<code>uid</code>的数量。</p>
<p>查询示例：每个演员以<code>Orlando</code>的名义出演的电影数量：</p>
<pre><code class="language-dql">{
  me(func: allofterms(name@en, &quot;Orlando&quot;)) @filter(has(actor.film)) {
    name@en
    count(actor.film)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Orlando Seale&quot;,
        &quot;count(actor.film)&quot;: 13
      },
      {
        &quot;name@en&quot;: &quot;Antonio Orlando&quot;,
        &quot;count(actor.film)&quot;: 5
      },
      {
        &quot;name@en&quot;: &quot;Orlando Viera&quot;,
        &quot;count(actor.film)&quot;: 1
      },
      {
        &quot;name@en&quot;: &quot;Silvio Orlando&quot;,
        &quot;count(actor.film)&quot;: 32
      }
      ...
    ]
  }
}
</code></pre>
<p><code>Count</code> 能用在根查询和<a href="dql/query_language/./aliases.html">别名</a><code>Aliase</code>中。</p>
<p>查询示例：导演超过5部电影的导演数。在查询根处使用时，需要<a href="dql/query_language/./schema.html#count-indices">count索引</a>：</p>
<pre><code class="language-dql">{
  directors(func: gt(count(director.film), 5)) {
    totalDirectors : count(uid)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;directors&quot;: [
      {
        &quot;totalDirectors&quot;: 7712
      }
    ]
  }
}
</code></pre>
<p>可以将<code>Count</code>赋值给<a href="dql/query_language/./value_variables.html">值变量</a>：</p>
<p>查询示例：<code>Ang Lee</code>的<code>Eat Drink Man Woman</code>的演员按电影的数量返回结果：</p>
<pre><code class="language-dql">{
  var(func: allofterms(name@en, &quot;eat drink man woman&quot;)) {
    starring {
      actors as performance.actor {
        totalRoles as count(actor.film)
      }
    }
  }

  edmw(func: uid(actors), orderdesc: val(totalRoles)) {
    name@en
    name@zh
    totalRoles : val(totalRoles)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;edmw&quot;: [
      {
        &quot;name@en&quot;: &quot;Sylvia Chang&quot;,
        &quot;name@zh&quot;: &quot;张艾嘉&quot;,
        &quot;totalRoles&quot;: 35
      },
      {
        &quot;name@en&quot;: &quot;Chien-lien Wu&quot;,
        &quot;name@zh&quot;: &quot;吴倩莲&quot;,
        &quot;totalRoles&quot;: 20
      },
      {
        &quot;name@en&quot;: &quot;Yang Kuei-mei&quot;,
        &quot;name@zh&quot;: &quot;杨贵媚&quot;,
        &quot;totalRoles&quot;: 14
      },
      {
        &quot;name@en&quot;: &quot;Winston Chao&quot;,
        &quot;name@zh&quot;: &quot;赵文瑄&quot;,
        &quot;totalRoles&quot;: 11
      }
      ...
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shorting-排序"><a class="header" href="#shorting-排序">Shorting 排序</a></h1>
<p>语法示例：</p>
<ul>
<li><code>q(func: ..., orderasc: predicate)</code></li>
<li><code>q(func: ..., orderdesc: val(name))</code></li>
<li><code>predicate (orderdesc: predicate) { ... }</code></li>
<li><code>predicate @filter(...) (orderasc: N) { ... }</code></li>
<li><code>q(func: ..., orderasc: predicate1, orderdesc: predicate2)</code></li>
</ul>
<p>可排序类型：<code>int</code>, <code>float</code>, <code>String</code>, <code>dateTime</code>, <code>default</code></p>
<p>结果可以按谓词(predicate)或变量(variable)的升序(<code>orderasc</code>)或降序(<code>orderdesc</code>)排序。</p>
<p>对于具有<a href="dql/query_language/./schema.html#sortable-indices">可排序索引</a>的谓词的排序，<code>Dgraph</code>并行地对值(value)和索引(index)进行排序，并返回先计算完的结果。</p>
<blockquote>
<p>注意，<code>Dgraph</code>在结果的末尾返回<code>null</code>，而不考虑其类型。这种行为在索引排序和非索引排序中是一致的。</p>
</blockquote>
<blockquote>
<p>默认情况下，排序查询最多可检索1000个结果。这可以用<code>first</code>更改。</p>
</blockquote>
<p>查询示例：法国导演<code>Jean-Pierre Jeunet</code>按上映日期排序的电影：</p>
<pre><code class="language-dql">{
  me(func: allofterms(name@en, &quot;Jean-Pierre Jeunet&quot;)) {
    name@fr
    director.film(orderasc: initial_release_date) {
      name@fr
      name@en
      initial_release_date
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@fr&quot;: &quot;Jean-Pierre Jeunet&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@fr&quot;: &quot;L'Évasion&quot;,
            &quot;name@en&quot;: &quot;L'évasion&quot;,
            &quot;initial_release_date&quot;: &quot;1978-01-01T00:00:00Z&quot;
          },
          {
            &quot;name@fr&quot;: &quot;Le Manège&quot;,
            &quot;name@en&quot;: &quot;Le manège&quot;,
            &quot;initial_release_date&quot;: &quot;1980-01-01T00:00:00Z&quot;
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<p>排序可以在根查询或值变量上进行。</p>
<p>查询示例：所有流派按字母表排序，每个类型中类型最多的5部电影：</p>
<pre><code class="language-dql">{
  genres as var(func: has(~genre)) {
    ~genre {
      numGenres as count(genre)
    }
  }

  genres(func: uid(genres), orderasc: name@en) {
    name@en
    ~genre (orderdesc: val(numGenres), first: 5) {
      name@en
      genres : val(numGenres)
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;genres&quot;: [
      {
        &quot;name@en&quot;: &quot;/m/04rlf&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Bookin'&quot;,
            &quot;genres&quot;: 3
          },
          {
            &quot;name@en&quot;: &quot;La brune et moi&quot;,
            &quot;genres&quot;: 3
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;3D film&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Mr. X&quot;,
            &quot;genres&quot;: 4
          },
          {
            &quot;name@en&quot;: &quot;Sly Cooper&quot;,
            &quot;genres&quot;: 4
          },
          {
            &quot;name@en&quot;: &quot;Everest&quot;,
            &quot;genres&quot;: 3
          },
          {
            &quot;name@en&quot;: &quot;Aqaye Alef&quot;,
            &quot;genres&quot;: 1
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Abstract animation&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;The Heart of the World&quot;,
            &quot;genres&quot;: 7
          },
          {
            &quot;name@en&quot;: &quot;Outside Out&quot;,
            &quot;genres&quot;: 6
          },
          {
            &quot;name@en&quot;: &quot;11 x 14&quot;,
            &quot;genres&quot;: 5
          },
          {
            &quot;name@en&quot;: &quot;Acousticity&quot;,
            &quot;genres&quot;: 4
          },
          {
            &quot;name@en&quot;: &quot;The Garden of Earthly Delights&quot;,
            &quot;genres&quot;: 4
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<p>排序也可以同时对多个谓语进行，如下所示。如果第一个谓词的值相等，则按第二个谓词对它们进行排序，以此类推。</p>
<p>查询示例：查找所有具有<code>Person</code>类型的节点，按<code>first_name</code>对其进行排序，<code>first_name</code>相同的节点按<code>last_name</code>降序进行排序。</p>
<pre><code class="language-dql">{
  me(func: type(&quot;Person&quot;), orderasc: first_name, orderdesc: last_name) {
    first_name
    last_name
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多查询块"><a class="header" href="#多查询块">多查询块</a></h1>
<p>在单个查询中，可以设置多个不同名字的查询块，这些查询块之间并行执行，它们之间不需要任何关联。</p>
<p>查询示例：自<code>2008</code>年以来<code>Angelina Jolie</code>所有类型的电影，以及<code>Peter Jackson</code>的电影：</p>
<pre><code class="language-dql">{
 AngelinaInfo(func:allofterms(name@en, &quot;angelina jolie&quot;)) {
  name@en
   actor.film {
    performance.film {
      genre {
        name@en
      }
    }
   }
  }

 DirectorInfo(func: eq(name@en, &quot;Peter Jackson&quot;)) {
    name@en
    director.film @filter(ge(initial_release_date, &quot;2008&quot;))  {
        Release_date: initial_release_date
        Name: name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;AngelinaInfo&quot;: [
      {
        &quot;name@en&quot;: &quot;Angelina Jolie&quot;,
        &quot;actor.film&quot;: [
          {
            &quot;performance.film&quot;: [
              {
                &quot;genre&quot;: [
                  {
                    &quot;name@en&quot;: &quot;Short Film&quot;
                  }
                ]
              }
            ]
          },
          {
            &quot;performance.film&quot;: [
              {
                &quot;genre&quot;: [
                  {
                    &quot;name@en&quot;: &quot;Slice of life&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Romance Film&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;LGBT&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Drama&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Comedy&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Comedy-drama&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Ensemble Film&quot;
                  }
                ]
              }
            ]
          },
          {
            &quot;performance.film&quot;: [
              {
                &quot;genre&quot;: [
                  {
                    &quot;name@en&quot;: &quot;Animation&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Romance Film&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Drama&quot;
                  },
                  {
                    &quot;name@en&quot;: &quot;Comedy&quot;
                  }
                ]
              }
            ]
          }
          ...
        ]
      },
      {
        &quot;name@en&quot;: &quot;Angelina Jolie&quot;
      },
      {
        &quot;name@en&quot;: &quot;Angelina Jolie Look-a-Like&quot;
      }
    ],
    &quot;DirectorInfo&quot;: [
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;,
        &quot;director.film&quot;: [
          {
            &quot;Release_date&quot;: &quot;2012-11-28T00:00:00Z&quot;,
            &quot;Name&quot;: &quot;The Hobbit: An Unexpected Journey&quot;
          },
          {
            &quot;Release_date&quot;: &quot;2009-11-24T00:00:00Z&quot;,
            &quot;Name&quot;: &quot;The Lovely Bones&quot;
          }
          ... 
        ]
      },
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;
      },
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;
      },
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;
      }
    ]
  }
}
</code></pre>
<p>即使查询的答案中包含一些重叠部分，查询的结果集仍然是独立的。</p>
<p>查询示例：<code>Mackenzie Crook</code>演过的电影和<code>Jack Davenport</code>演过的电影，
两个结果集重叠，因为它们都在<code>Pirates of the Caribbean</code>电影中出演过，但结果是独立的，并且都包含完整的结果集：</p>
<pre><code class="language-dql">{
  Mackenzie(func:allofterms(name@en, &quot;Mackenzie Crook&quot;)) {
    name@en
    actor.film {
      performance.film {
        uid
        name@en
      }
      performance.character {
        name@en
      }
    }
  }

  Jack(func:allofterms(name@en, &quot;Jack Davenport&quot;)) {
    name@en
    actor.film {
      performance.film {
        uid
        name@en
      }
      performance.character {
        name@en
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;Mackenzie&quot;: [
      {
        &quot;name@en&quot;: &quot;Mackenzie Crook&quot;,
        &quot;actor.film&quot;: [
          {
            &quot;performance.film&quot;: [
              {
                &quot;uid&quot;: &quot;0x7f33f&quot;,
                &quot;name@en&quot;: &quot;Sex Lives of the Potato Men&quot;
              }
            ]
          },
          {
            &quot;performance.film&quot;: [
              {
                &quot;uid&quot;: &quot;0x5643&quot;,
                &quot;name@en&quot;: &quot;Still Crazy&quot;
              }
            ],
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Dutch Kid&quot;
              }
            ]
          },
          {
            &quot;performance.film&quot;: [
              {
                &quot;uid&quot;: &quot;0x842bf&quot;,
                &quot;name@en&quot;: &quot;Solomon Kane&quot;
              }
            ],
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Father Michael&quot;
              }
            ]
          }
          ...
        ]
      }
    ],
    &quot;Jack&quot;: [
      {
        &quot;name@en&quot;: &quot;Jack Davenport&quot;,
        &quot;actor.film&quot;: [
          {
            &quot;performance.film&quot;: [
              {
                &quot;uid&quot;: &quot;0x9367&quot;,
                &quot;name@en&quot;: &quot;The Libertine&quot;
              }
            ],
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Harris&quot;
              }
            ]
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="变量块-var-block"><a class="header" href="#变量块-var-block">变量块 <code>var block</code></a></h2>
<p>变量块由<code>var</code>关键字定义，不会返回在结果集，也不会影响查询的结果内容。</p>
<p>查询示例：<code>Angelina Jolie</code>的电影，通过流派排序：</p>
<pre><code class="language-graphql">{
  var(func: allofterms(name@en, &quot;angelina jolie&quot;)) {
    name@en
    actor.film {
      A AS performance.film {
        B AS genre
      }
    }
  }

  films(func: uid(B), orderasc: name@en) {
    name@en
    ~genre @filter(uid(A)) {
      name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;films&quot;: [
      {
        &quot;name@en&quot;: &quot;Action Film&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Gone in 60 Seconds&quot;
          },
          {
            &quot;name@en&quot;: &quot;Alexander&quot;
          }
          ...
        ]
      },
      {
        &quot;name@en&quot;: &quot;Action/Adventure&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Gone in 60 Seconds&quot;
          },
          {
            &quot;name@en&quot;: &quot;The Bone Collector&quot;
          }
          ...
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h2 id="多变量块-multiple-var-block"><a class="header" href="#多变量块-multiple-var-block">多变量块 <code>multiple var block</code></a></h2>
<p>您还可以在单个查询操作中使用多个<code>var</code>块。你可以在任何后续的块中使用一个<code>var</code>块中的变量，但不能在同一个块中使用。</p>
<p>查询示例：包含<code>angelina jolie</code>和<code>morgan freeman</code>的电影(按名字排序)：</p>
<pre><code class="language-dql">{
  var(func:allofterms(name@en, &quot;angelina jolie&quot;)) {
    name@en
    actor.film {
      A AS performance.film
    }
  }
  var(func:allofterms(name@en, &quot;morgan freeman&quot;)) {
    name@en
    actor.film {
      B as performance.film @filter(uid(A))
    }
  }
  
  films(func: uid(B), orderasc: name@en) {
    name@en
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;films&quot;: [
      {
        &quot;name@en&quot;: &quot;Wanted&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="在查询中组合使用多个变量块"><a class="header" href="#在查询中组合使用多个变量块">在查询中组合使用多个变量块</a></h2>
<p>你可以像下面这样在单个查询中使用逻辑连词组合多个变量块：</p>
<pre><code class="language-dql">{
  var(func:allofterms(name@en, &quot;angelina jolie&quot;)) {
    name@en
    actor.film {
      A AS performance.film
    }
  }
  var(func:allofterms(name@en, &quot;morgan freeman&quot;)) {
    name@en
    actor.film {
      B as performance.film
    }
  }
  films(func: uid(A,B), orderasc: name@en) @filter(uid(A) AND uid(B)) {
    name@en
  }
}
</code></pre>
<p>根查询<code>uid</code>函数将<code>var</code> <code>A</code>和<code>B</code>中的<code>uid</code>合并，因此您需要一个过滤器来与<code>var</code> <code>A</code>和<code>B</code>中的<code>uid</code>相交。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询变量"><a class="header" href="#查询变量">查询变量</a></h1>
<p>解析规则：</p>
<ul>
<li><code>varName as q(func: ...) { ... }</code></li>
<li><code>varName as var(func: ...) { ... }</code></li>
<li><code>varName as predicate { ... }</code></li>
<li><code>varName as predicate @filter(...) { ... }</code></li>
</ul>
<p>类型: uid</p>
<p>在查询中一个位置匹配的节点的<code>uid</code>可以存储在一个变量中，并在其它地方使用。查询变量可以在其他查询块中使用，也可以在定义块的子节点中使用。</p>
<p>查询变量在定义点不会影响查询的语义。查询变量被计算为所有与定义块匹配的节点。</p>
<p>通常，查询块是并行执行的，但是变量对一些块施加了计算顺序。由变量相关引起的循环是不允许的。</p>
<p>如果定义了变量，则必须在查询的其他地方使用它。</p>
<p>查询变量通过<code>uid(var-name)</code>提取其中的<code>uid</code>来使用。</p>
<p>语法<code>func: uid(A, B)</code>或<code>@filter(uid(A, B))</code>表示变量<code>A</code>和<code>B</code>的<code>uid</code>的并集。</p>
<p>查询示例：安吉丽娜·朱莉和布拉德·皮特都出演过同一类型的电影。请注意，B和D匹配所有电影的所有类型，而不是每部电影的类型：</p>
<pre><code class="language-graphql">{
 var(func:allofterms(name@en, &quot;angelina jolie&quot;)) {
   actor.film {
    A AS performance.film {  # All films acted in by Angelina Jolie
     B As genre  # Genres of all the films acted in by Angelina Jolie
    }
   }
  }

 var(func:allofterms(name@en, &quot;brad pitt&quot;)) {
   actor.film {
    C AS performance.film {  # All films acted in by Brad Pitt
     D as genre  # Genres of all the films acted in by Brad Pitt
    }
   }
  }

 films(func: uid(D)) @filter(uid(B)) {   # Genres from both Angelina and Brad
  name@en
   ~genre @filter(uid(A, C)) {  # Movies in either A or C.
     name@en
   }
 }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;films&quot;: [
      {
        &quot;name@en&quot;: &quot;War film&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Two-Fisted Tales&quot;
          },
          {
            &quot;name@en&quot;: &quot;Alexander&quot;
          }
          ...
        ]
      },
      {
        &quot;name@en&quot;: &quot;Indie film&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Babel&quot;
          },
          {
            &quot;name@en&quot;: &quot;Seven&quot;
          },
          {
            &quot;name@en&quot;: &quot;The Tree of Life&quot;
          }
          ...
        ]
      }
      ...
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="值变量"><a class="header" href="#值变量">值变量</a></h1>
<p>解析示例：</p>
<ul>
<li><code>varName as scalarPredicate</code></li>
<li><code>varName as count(predicate)</code></li>
<li><code>varName as avg(...)</code></li>
<li><code>varName as math(...)</code></li>
</ul>
<p>支持的类型：<code>int</code>, <code>float</code>, <code>String</code>, <code>dateTime</code>, <code>geo</code>, <code>default</code>, <code>bool</code></p>
<p>值变量存储标量值。值变量是从封闭块的<code>uid</code>到相应值的映射。</p>
<p>因此，只有在匹配相同<code>uid</code>的上下文中使用值变量的值才有意义————如果在匹配不同<code>uid</code>的块中使用值变量是未定义的。</p>
<p>定义值变量而不在查询的其他地方使用它是错误的。</p>
<p>值变量是通过使用<code>val(var-name)</code>提取值，或使用<code>uid(var-name)</code>提取<code>uid</code>来使用的。</p>
<p><a href="https://dgraph.io/docs/query-language/facets/">Facet</a>值可以存储在值变量中。</p>
<p>查询示例：80年代经典电影《公主新娘》中，演员所扮演的电影角色数量。查询变量pbActors匹配电影中所有演员的uid。因此，值变量角色是一个从actor UID到角色数量的映射。值变量角色可以在totalRoles查询块中使用，因为该查询块也匹配pbActors uid，因此actor到角色数量的映射是可用的：</p>
<pre><code class="language-graphql">{
  var(func:allofterms(name@en, &quot;The Princess Bride&quot;)) {
    starring {
      pbActors as performance.actor {
        roles as count(actor.film)
      }
    }
  }
  totalRoles(func: uid(pbActors), orderasc: val(roles)) {
    name@en
    numRoles : val(roles)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;totalRoles&quot;: [
      {
        &quot;name@en&quot;: &quot;Mark Knopfler&quot;,
        &quot;numRoles&quot;: 1
      },
      {
        &quot;name@en&quot;: &quot;Annie Dyson&quot;,
        &quot;numRoles&quot;: 2
      },
      {
        &quot;name@en&quot;: &quot;André the Giant&quot;,
        &quot;numRoles&quot;: 7
      }
      ...
    ]
  }
}
</code></pre>
<p>值变量可以通过从映射中提取<code>UID</code>列表来代替<code>UID</code>变量。</p>
<p>查询示例：与前面的示例相同的查询，但是使用值变量角色来匹配<code>totalRoles</code>查询块中的<code>uid</code>：</p>
<pre><code class="language-graphql">{
  var(func:allofterms(name@en, &quot;The Princess Bride&quot;)) {
    starring {
      performance.actor {
        roles as count(actor.film)
      }
    }
  }
  totalRoles(func: uid(roles), orderasc: val(roles)) {
    name@en
    numRoles : val(roles)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;totalRoles&quot;: [
      {
        &quot;name@en&quot;: &quot;Mark Knopfler&quot;,
        &quot;numRoles&quot;: 1
      },
      {
        &quot;name@en&quot;: &quot;Annie Dyson&quot;,
        &quot;numRoles&quot;: 2
      },
      {
        &quot;name@en&quot;: &quot;André the Giant&quot;,
        &quot;numRoles&quot;: 7
      }
      ...
    ]
  }
}
</code></pre>
<h2 id="变量传播"><a class="header" href="#变量传播">变量传播</a></h2>
<p>与查询变量一样，值变量可以在其他查询块中使用，也可以在定义块内嵌套的块中使用。当在定义变量的块内嵌套的块中使用时，该值作为父节点到使用点的所有路径上的变量的和计算。这叫做变量传播：</p>
<pre><code class="language-graphql">{
  q(func: uid(0x01)) {
    myscore as math(1)          # A
    friends {                   # B
      friends {                 # C
        ...myscore...
      }
    }
  }
}
</code></pre>
<p>在第A行，一个值变量<code>myscore</code>被定义为<code>UID</code>为<code>0x01</code>的节点映射到值<code>1</code>。在B处，每个朋友的值仍然是<code>1</code>:每个朋友只有一条路径。穿过朋友的边缘两次，就会到达朋友的朋友。变量<code>myscore</code>将被传播，这样每个朋友的朋友将收到它的父母值的总和:如果一个朋友的朋友只能从一个朋友处到达，那么这个值仍然是1，如果他们可以从两个朋友处到达，那么这个值是2，以此类推。也就是说，标记为C的块中每个朋友的朋友的<code>myscore</code>值将是到他们的路径数。</p>
<p><strong>节点接收到的传播变量的值是其所有父节点值的和。</strong></p>
<p>这种传播是有用的，例如，在标准化用户之间的和、查找节点之间的路径数量和通过图积累一个和时。</p>
<p>查询示例：每一部《哈利·波特》电影中，沃里克·戴维斯扮演的角色数量：</p>
<pre><code class="language-graphql">{
    num_roles(func: eq(name@en, &quot;Warwick Davis&quot;)) @cascade @normalize {

    paths as math(1)  # records number of paths to each character

    actor : name@en

    actor.film {
      performance.film @filter(allofterms(name@en, &quot;Harry Potter&quot;)) {
        film_name : name@en
        characters : math(paths)  # how many paths (i.e. characters) reach this film
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;num_roles&quot;: [
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Prisoner of Azkaban&quot;,
        &quot;characters&quot;: 1
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Goblet of Fire&quot;,
        &quot;characters&quot;: 1
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Deathly Hallows – Part 2&quot;,
        &quot;characters&quot;: 2
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Deathly Hallows - Part I&quot;,
        &quot;characters&quot;: 1
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Order of the Phoenix&quot;,
        &quot;characters&quot;: 1
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Philosopher's Stone&quot;,
        &quot;characters&quot;: 2
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Philosopher's Stone&quot;,
        &quot;characters&quot;: 2
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Half-Blood Prince&quot;,
        &quot;characters&quot;: 1
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Deathly Hallows – Part 2&quot;,
        &quot;characters&quot;: 2
      },
      {
        &quot;actor&quot;: &quot;Warwick Davis&quot;,
        &quot;film_name&quot;: &quot;Harry Potter and the Chamber of Secrets&quot;,
        &quot;characters&quot;: 1
      }
    ]
  }
}
</code></pre>
<p>查询示例：在彼得·杰克逊的电影中出演过的每个演员以及他们在彼得·杰克逊的电影中出演的比例：</p>
<pre><code class="language-graphql">{
    movie_fraction(func:eq(name@en, &quot;Peter Jackson&quot;)) @normalize {

    paths as math(1)
    total_films : num_films as count(director.film)
    director : name@en

    director.film {
      starring {
        performance.actor {
          fraction : math(paths / (num_films/paths))
          actor : name@en
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;movie_fraction&quot;: [
      {
        &quot;total_films&quot;: 19,
        &quot;director&quot;: &quot;Peter Jackson&quot;,
        &quot;fraction&quot;: 0,
        &quot;actor&quot;: &quot;Pete O'Herne&quot;
      },
      {
        &quot;total_films&quot;: 19,
        &quot;director&quot;: &quot;Peter Jackson&quot;,
        &quot;fraction&quot;: 0,
        &quot;actor&quot;: &quot;Peter Jackson&quot;
      },
      {
        &quot;total_films&quot;: 19,
        &quot;director&quot;: &quot;Peter Jackson&quot;,
        &quot;fraction&quot;: 0,
        &quot;actor&quot;: &quot;Peter Jackson&quot;
      }
      ...
    ]
  }
}
</code></pre>
<p>更多的例子可以在两篇<code>Dgraph</code>博客文章中找到(<a href="https://open.dgraph.io/post/recommendation/">post1</a>, <a href="https://open.dgraph.io/post/recommendation2/">post2</a>)，这两篇文章是关于为推荐引擎使用变量传播的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="聚合操作-aggregation"><a class="header" href="#聚合操作-aggregation">聚合操作 Aggregation</a></h1>
<p>解析规则：</p>
<ul>
<li><code>AG(val(varName))</code></li>
</ul>
<p><code>AG</code>的可能取值是：</p>
<ul>
<li><code>min</code>: 在值变量<code>varName</code>里选择最小值</li>
<li><code>max</code>: 在值变量<code>varName</code>里选择最大值</li>
<li><code>sum</code>: 计算总和</li>
<li><code>avg</code>: 计算<code>varName</code>的平均数</li>
</ul>
<p>Schema类型：</p>
<table><thead><tr><th>操作</th><th>Schema类型</th></tr></thead><tbody>
<tr><td>min/max</td><td>int float string dateTime default</td></tr>
<tr><td>sum/avg</td><td>int float</td></tr>
</tbody></table>
<p>聚合操作只能用在值变量上，不需要索引。</p>
<p>在包含变量定义的查询块上应用聚合。与查询变量和值变量(它们是全局的)不同，聚合是在本地计算的。例如:</p>
<pre><code class="language-graphql">A as predicateA {
  ...
  B as predicateB {
    x as ...some value...
  }
  min(val(x))
}
</code></pre>
<h2 id="min"><a class="header" href="#min">Min</a></h2>
<h3 id="用在根查询中-2"><a class="header" href="#用在根查询中-2">用在根查询中</a></h3>
<h3 id="其他用法"><a class="header" href="#其他用法">其他用法</a></h3>
<p>查询示例：<code>Steven</code>导演的，并按第一部电影的上映日期升序排列的电影：</p>
<pre><code class="language-graphql">{
  stevens as var(func: allofterms(name@en, &quot;steven&quot;)) {
    director.film {
      ird as initial_release_date
      # ird is a value variable mapping a film UID to its release date
    }
    minIRD as min(val(ird))
    # minIRD is a value variable mapping a director UID to their first release date
  }

  byIRD(func: uid(stevens), orderasc: val(minIRD)) {
    name@en
    firstRelease: val(minIRD)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;byIRD&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven McMillan&quot;,
        &quot;firstRelease&quot;: &quot;0214-02-28T00:00:00Z&quot;
      },
      {
        &quot;name@en&quot;: &quot;J. Steven Edwards&quot;,
        &quot;firstRelease&quot;: &quot;1929-01-01T00:00:00Z&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;firstRelease&quot;: &quot;1964-03-24T00:00:00Z&quot;
      }
      ...
    ]
  }
}
</code></pre>
<h2 id="max"><a class="header" href="#max">Max</a></h2>
<h3 id="用在根查询中-3"><a class="header" href="#用在根查询中-3">用在根查询中</a></h3>
<p>查询示例：获取名字包含<code>Harry Potter</code>的最新更新的电影，
更新日期被映射到一个变量(d)，然后被聚合操作(max)，最后附加到一个空的查询块中：</p>
<pre><code class="language-graphql">{
  var(func: allofterms(name@en, &quot;Harry Potter&quot;)) {
    d as initial_release_date
  }
  me() {
    max(val(d))
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;max(val(d))&quot;: &quot;2011-07-27T00:00:00Z&quot;
      }
    ]
  }
}
</code></pre>
<h3 id="其它用法"><a class="header" href="#其它用法">其它用法</a></h3>
<p>查询示例：<code>Quentin Tarantino</code>发布的电影，按时间最新的排列：</p>
<pre><code class="language-graphql">{
  director(func: allofterms(name@en, &quot;Quentin Tarantino&quot;)) {
    director.film {
      name@en
      x as initial_release_date
    }
    max(val(x))
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;director&quot;: [
      {
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Kill Bill Volume 1&quot;,
            &quot;initial_release_date&quot;: &quot;2003-10-10T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Django Unchained&quot;,
            &quot;initial_release_date&quot;: &quot;2012-12-25T00:00:00Z&quot;
          },
          {
            &quot;name@en&quot;: &quot;Sin City&quot;,
            &quot;initial_release_date&quot;: &quot;2005-03-28T00:00:00Z&quot;
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="总和和平均数-sum-avg"><a class="header" href="#总和和平均数-sum-avg">总和和平均数 <code>Sum</code>, <code>Avg</code></a></h2>
<h3 id="用在根查询中-4"><a class="header" href="#用在根查询中-4">用在根查询中</a></h3>
<h3 id="其它用法-1"><a class="header" href="#其它用法-1">其它用法</a></h3>
<h2 id="aggregating-aggregates"><a class="header" href="#aggregating-aggregates">Aggregating Aggregates</a></h2>
<p>可以将聚合分配给值变量，因此可以依次对这些变量进行聚合。</p>
<p>查询示例：对于彼得·杰克逊电影中的每个演员，找出在任何电影中扮演的角色的数量。把这些数字加起来，就能算出所有演员在这部电影中所扮演的角色总数。然后把这些数字加起来，就能算出演员们在彼得·杰克逊的电影中扮演过的角色总数。注意，这演示了如何聚合聚合；不过，这个问题的答案并不十分精确，因为在彼得·杰克逊的多部电影中出现的演员被计算了不止一次。</p>
<pre><code class="language-graphql">{
  PJ as var(func:allofterms(name@en, &quot;Peter Jackson&quot;)) {
    director.film {
      starring {  # starring an actor
        performance.actor {
          movies as count(actor.film)
          # number of roles for this actor
        }
        perf_total as sum(val(movies))
      }
      movie_total as sum(val(perf_total))
      # total roles for all actors in this movie
    }
    gt as sum(val(movie_total))
  }

  PJmovies(func: uid(PJ)) {
    name@en
    director.film (orderdesc: val(movie_total), first: 5) {
      name@en
      totalRoles : val(movie_total)
    }
    grandTotal : val(gt)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;PJmovies&quot;: [
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;The Lord of the Rings: The Two Towers&quot;,
            &quot;totalRoles&quot;: 1565
          },
          {
            &quot;name@en&quot;: &quot;The Lord of the Rings: The Return of the King&quot;,
            &quot;totalRoles&quot;: 1518
          },
          {
            &quot;name@en&quot;: &quot;The Lord of the Rings: The Fellowship of the Ring&quot;,
            &quot;totalRoles&quot;: 1335
          },
          {
            &quot;name@en&quot;: &quot;The Hobbit: An Unexpected Journey&quot;,
            &quot;totalRoles&quot;: 1274
          },
          {
            &quot;name@en&quot;: &quot;The Hobbit: The Desolation of Smaug&quot;,
            &quot;totalRoles&quot;: 1261
          }
        ],
        &quot;grandTotal&quot;: 10592
      },
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;
      },
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;
      },
      {
        &quot;name@en&quot;: &quot;Peter Jackson&quot;
      },
      {
        &quot;name@en&quot;: &quot;Sam Peter Jackson&quot;
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="值变量上的数学操作"><a class="header" href="#值变量上的数学操作">值变量上的数学操作</a></h1>
<p>值变量可以用数学函数组合在一起。例如，这可以用于关联一个分数，然后该分数用于排序或执行其他操作，例如可能用于构建新闻提要、简单推荐系统等。</p>
<p><code>Math</code>语句必须包含在<code>Math(&lt;exp&gt;)</code>中，并且必须存储到值变量中。</p>
<p>支持的操作符如下：</p>
<table><thead><tr><th>操作</th><th>接受的类型</th><th>作用</th></tr></thead><tbody>
<tr><td><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></td><td>int float</td><td>进行相应的运算</td></tr>
<tr><td><code>min</code> <code>max</code></td><td>除了<code>geo</code> <code>bool</code></td><td>选择最大或最小值</td></tr>
<tr><td><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>==</code> <code>!=</code></td><td>除了<code>geo</code> <code>bool</code></td><td>返回 <code>true</code>或者<code>false</code></td></tr>
<tr><td><code>floor</code> <code>ceil</code> <code>ln</code> <code>exp</code> <code>sqrt</code></td><td><code>int</code> <code>float</code></td><td>进行相应的运算</td></tr>
<tr><td><code>since</code></td><td><code>dateTime</code></td><td>返回从指定时间开始的浮点数秒数</td></tr>
<tr><td><code>pow(a, b)</code></td><td><code>int</code> <code>float</code></td><td>返回a的b次方</td></tr>
<tr><td><code>logbase(a, b)</code></td><td><code>int</code> <code>float</code></td><td>将<code>log(a)</code>返回到基数<code>b</code></td></tr>
<tr><td><code>cond(a, b, c)</code></td><td>第一个操作数必须是<code>bool</code>值</td><td>如果a为真，选择b，否则选c</td></tr>
</tbody></table>
<blockquote>
<p>如果发生整数溢出，或将操作数传递给数学操作(如<code>ln</code>、<code>logbase</code>、<code>sqrt</code>、<code>pow</code>)导致非法操作，<code>Dgraph</code>将返回错误。</p>
</blockquote>
<p>查询示例：将史蒂芬·斯皮尔伯格的每一部电影的演员数量、类型数量和国家数量相加，得出分数。按得分递减的顺序列出这类电影的前五名：</p>
<pre><code class="language-graphql">{
	var(func:allofterms(name@en, &quot;steven spielberg&quot;)) {
		films as director.film {
			p as count(starring)
			q as count(genre)
			r as count(country)
			score as math(p + q + r)
		}
	}

	TopMovies(func: uid(films), orderdesc: val(score), first: 5){
		name@en
		val(score)
	}
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;TopMovies&quot;: [
      {
        &quot;name@en&quot;: &quot;Lincoln&quot;,
        &quot;val(score)&quot;: 179
      },
      {
        &quot;name@en&quot;: &quot;Minority Report&quot;,
        &quot;val(score)&quot;: 156
      },
      {
        &quot;name@en&quot;: &quot;Schindler's List&quot;,
        &quot;val(score)&quot;: 145
      },
      {
        &quot;name@en&quot;: &quot;The Terminal&quot;,
        &quot;val(score)&quot;: 118
      },
      {
        &quot;name@en&quot;: &quot;Saving Private Ryan&quot;,
        &quot;val(score)&quot;: 99
      }
    ]
  }
}
</code></pre>
<p>可以在过滤器中使用值变量及其聚合。</p>
<p>查询示例：为每一部史蒂文·斯皮尔伯格<code>Steven Spielberg</code>的电影计算一个分数，并带有上映日期的条件，以惩罚10年以上的电影，过滤结果分数：</p>
<pre><code class="language-graphql">{
  var(func:allofterms(name@en, &quot;steven spielberg&quot;)) {
    films as director.film {
      p as count(starring)
      q as count(genre)
      date as initial_release_date
      years as math(since(date)/(365*24*60*60))
      score as math(cond(years &gt; 10, 0, ln(p)+q-ln(years)))
    }
  }

  TopMovies(func: uid(films), orderdesc: val(score)) @filter(gt(val(score), 2)){
    name@en
    val(score)
    val(date)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;TopMovies&quot;: [
      {
        &quot;name@en&quot;: &quot;Lincoln&quot;,
        &quot;val(score)&quot;: 7.927418,
        &quot;val(date)&quot;: &quot;2012-10-08T00:00:00Z&quot;
      }
    ]
  }
}
</code></pre>
<p>通过数学操作计算的值存储在值变量中，因此可以聚合。</p>
<p>查询示例：为<code>Steven Spielberg</code>的每一部电影计算一个分数，然后将分数相加：</p>
<pre><code class="language-graphql">{
	steven as var(func:eq(name@en, &quot;Steven Spielberg&quot;)) @filter(has(director.film)) {
		director.film {
			p as count(starring)
			q as count(genre)
			r as count(country)
			score as math(p + q + r)
		}
		directorScore as sum(val(score))
	}

	score(func: uid(steven)){
		name@en
		val(directorScore)
	}
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;score&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;val(directorScore)&quot;: 1865
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分组-groupby"><a class="header" href="#分组-groupby">分组 GroupBy</a></h1>
<p>解析示例：</p>
<ul>
<li><code>q(func: ...) @groupBy(predicate) { min(...) }</code></li>
<li><code>predicate @groupBy(pred) { count(uid) }</code></li>
</ul>
<p><code>groupby</code>查询聚合给定一组属性的查询结果，在这些属性上对元素进行分组。例如，一个包含块好友<code>@groupby(age) {count(uid)}</code>的查询，查找沿好友边缘可到达的所有节点，根据年龄将这些节点划分为组，然后计算每个组中有多少个节点。返回的结果是分组的边和聚合。</p>
<p>在一个<code>groupby</code>块中，只允许聚合，并且<code>count</code>只能应用于<code>uid</code>。</p>
<p>如果<code>groupby</code>应用于<code>uid</code>谓词，则生成的聚合可以保存在一个变量中(将分组的<code>uid</code>映射到聚合值)，并在查询的其他地方使用它来提取分组或聚合的边缘以外的信息。</p>
<p>查询示例：对于<code>Steven Spielberg</code>的电影，计算每种类型的电影数量，并为每种类型返回类型名称和数量。名称不能在<code>groupby</code>中提取，因为它不是一个聚合，但是<code>uid(a)</code>可以用于从<code>uid</code>到值映射中提取<code>uid</code>，从而按类型<code>uid</code>组织<code>byGenre</code>查询：</p>
<pre><code class="language-graphql">{
  var(func:allofterms(name@en, &quot;steven spielberg&quot;)) {
    director.film @groupby(genre) {
      a as count(uid)
      # a is a genre UID to count value variable
    }
  }

  byGenre(func: uid(a), orderdesc: val(a)) {
    name@en
    total_movies : val(a)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;byGenre&quot;: [
      {
        &quot;name@en&quot;: &quot;Drama&quot;,
        &quot;total_movies&quot;: 21
      },
      {
        &quot;name@en&quot;: &quot;Adventure Film&quot;,
        &quot;total_movies&quot;: 14
      },
      {
        &quot;name@en&quot;: &quot;Thriller&quot;,
        &quot;total_movies&quot;: 13
      },
      {
        &quot;name@en&quot;: &quot;Action Film&quot;,
        &quot;total_movies&quot;: 12
      }
      ...
    ]
  }
}
</code></pre>
<p>查询示例：蒂姆·伯顿电影中的演员以及他们在蒂姆·伯顿的电影中扮演了多少角色：</p>
<pre><code class="language-graphql">{
  var(func:allofterms(name@en, &quot;Tim Burton&quot;)) {
    director.film {
      starring @groupby(performance.actor) {
        a as count(uid)
        # a is an actor UID to count value variable
      }
    }
  }

  byActor(func: uid(a), orderdesc: val(a)) {
    name@en
    val(a)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;byActor&quot;: [
      {
        &quot;name@en&quot;: &quot;Johnny Depp&quot;,
        &quot;val(a)&quot;: 8
      },
      {
        &quot;name@en&quot;: &quot;Helena Bonham Carter&quot;,
        &quot;val(a)&quot;: 7
      }
      ...
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expand-函数"><a class="header" href="#expand-函数">Expand 函数</a></h1>
<p>可以使用<code>expand()</code>函数在节点外展开谓词。要使用<code>expand()</code>，类型系统是必需的。请参阅关于类型系统的一节，以检查如何设置类型节点。本节的其余部分假设您熟悉该节。</p>
<p>使用<code>expand</code>函数有两种方法。</p>
<p>可以将类型传递给<code>expand()</code>以展开该类型中的所有谓词。</p>
<p>查询示例：列出哈利波特系列的电影：</p>
<pre><code class="language-graphql">{
  all(func: eq(name@en, &quot;Harry Potter&quot;)) @filter(type(Series)) {
    name@en
    expand(Series) {
      name@en
      expand(Film)
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;all&quot;: [
      {
        &quot;name@en&quot;: [
          &quot;Harry Potter&quot;,
          &quot;Harry Potter&quot;
        ],
        &quot;name@fi&quot;: &quot;Harry Potter (elokuvasarja)&quot;,
        &quot;name@hu&quot;: &quot;Harry Potter filmsorozat&quot;,
        &quot;name@sl&quot;: &quot;Filmska serija Harry Potter&quot;,
        &quot;name@da&quot;: &quot;Harry Potter-filmserien&quot;,
        &quot;name@ca&quot;: &quot;Saga de Harry Potter&quot;,
        &quot;series.films_in_series&quot;: [
          {
            &quot;name@en&quot;: [
              &quot;Harry Potter and the Chamber of Secrets&quot;,
              &quot;Harry Potter and the Chamber of Secrets&quot;
            ],
            &quot;name@fi&quot;: &quot;Harry Potter ja salaisuuksien kammio&quot;,
            &quot;name@zh&quot;: &quot;哈利·波特与密室&quot;,
            &quot;name@pt-BR&quot;: &quot;Harry Potter e a Câmara Secreta&quot;,
            &quot;name@hu&quot;: &quot;Harry Potter és a Titkok Kamrája&quot;,
            &quot;name@sl&quot;: &quot;Harry Potter in dvorana skrivnosti&quot;,
            &quot;name@et&quot;: &quot;Harry Potter ja saladuste kamber&quot;,
            &quot;name@lv&quot;: &quot;Harijs Poters un Noslēpumu kambaris&quot;,
            &quot;name@de&quot;: &quot;Harry Potter und die Kammer des Schreckens&quot;,
            &quot;tagline@en&quot;: &quot;Hogwarts is back in session.&quot;,
            &quot;netflix_id&quot;: &quot;60024925&quot;,
            &quot;initial_release_date&quot;: &quot;2002-11-03T00:00:00Z&quot;,
            &quot;rottentomatoes_id&quot;: &quot;harry_potter_and_the_chamber_of_secrets&quot;,
            &quot;traileraddict_id&quot;: &quot;harry-potter-and-the-chamber-of-secrets&quot;,
            &quot;metacritic_id&quot;: &quot;harrypotterandthechamberofsecrets&quot;
          },
          {
            &quot;name@en&quot;: [
              &quot;Harry Potter and the Deathly Hallows - Part I&quot;,
              &quot;Harry Potter and the Deathly Hallows - Part I&quot;
            ],
            &quot;name@fi&quot;: &quot;Harry Potter ja kuoleman varjelukset, osa 1&quot;,
            &quot;name@zh&quot;: &quot;哈利·波特与死亡圣器（上）&quot;,
            &quot;name@pt-BR&quot;: &quot;Harry Potter e as Relíquias da Morte – Parte 1&quot;,
            &quot;name@hu&quot;: &quot;Harry Potter és a Halál ereklyéi 1.&quot;,
            &quot;name@sl&quot;: &quot;Harry Potter in Svetinje smrti - 1. del&quot;,
            &quot;name@pt-PT&quot;: &quot;Harry Potter e os Talismãs da Morte: Parte 1&quot;,
            &quot;name@fr&quot;: &quot;Harry Potter et les reliques de la mort - 1ère partie&quot;,
            &quot;name@ja&quot;: &quot;ハリー・ポッターと死の秘宝 PART1&quot;,
            &quot;name@ro&quot;: &quot;Harry Potter și Talismanele Morții. Partea 1&quot;,
            &quot;name@uk&quot;: &quot;Гаррі Поттер і смертельні реліквії: частина 1&quot;,
            &quot;name@id&quot;: &quot;Harry Potter and the Deathly Hallows - Bagian 1&quot;,
            &quot;name@iw&quot;: &quot;הארי פוטר ואוצרות המוות&quot;,
            &quot;name@lt&quot;: &quot;Haris Poteris ir Mirties relikvijos. 1 dalis&quot;,
            &quot;name@zh-Hant&quot;: &quot;哈利波特－死神的聖物1&quot;,
            &quot;name@sr&quot;: &quot;Хари Потер и реликвије Смрти: Први део&quot;,
            &quot;name@el&quot;: &quot;Ο Χάρι Πότερ και οι Κλήροι του Θανάτου - Μέρος 1&quot;,
            &quot;name@sv&quot;: &quot;Harry Potter och dödsrelikerna&quot;,
            &quot;name@pl&quot;: &quot;Harry Potter i Insygnia Śmierci: Część I&quot;,
            &quot;name@ar&quot;: &quot;هاري بوتر ومقدسات الموت – الجزء 1&quot;,
            &quot;name@bg&quot;: &quot;Хари Потър и Даровете на Смъртта: Първа част&quot;,
            &quot;name@et&quot;: &quot;Harry Potter ja surma vägised: osa 1&quot;,
            &quot;name@lv&quot;: &quot;Harijs Poters un Nāves dāvesti: Pirmā daļa&quot;,
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>如果<code>_all_</code>作为参数传递给<code>expand()</code>，则要展开的谓词将是分配给给定节点的类型中的字段的联合。
<code>_all_</code>关键字要求节点具有类型。<code>Dgraph</code>将查找已分配给节点的所有类型，查询类型以检查它们具有哪些属性，并使用这些属性计算要展开的谓词列表。</p>
<p>例如，考虑一个具有<code>Animal</code>和<code>Pet</code>类型的节点，它们有以下定义：</p>
<pre><code class="language-dql">type Animal {
    name
    species
    dob
}

type Pet {
    owner
    veterinarian
}
</code></pre>
<p>当在这个节点上调用<code>expand(_all_)</code>时，<code>Dgraph</code>首先检查节点的类型<code>Animal</code>和<code>Pet</code>。然后，它将获得<code>Animal</code>和<code>Pet</code>的定义，并根据它们的类型定义构建谓词列表。</p>
<pre><code class="language-graphql">name
species
dob
owner
veterinarian
</code></pre>
<blockquote>
<p>注意：对于字符串谓词，展开只返回没有标记语言的值(参见语言首选项)。所以通常需要添加<code>name@fr</code>或<code>name@.</code>以及扩展查询。</p>
</blockquote>
<h2 id="在过滤中展开"><a class="header" href="#在过滤中展开">在过滤中展开</a></h2>
<p>在传出边缘的类型上展开查询支持筛选器。例如，<code>expand(_all_) @filter(type(Person))</code>将在所有谓词上展开，但只包含目标节点类型为<code>Person</code>的边。因为只有<code>uid</code>类型的节点可以具有类型，所以该查询将过滤掉任何标量值。</p>
<p>请注意，<code>expand</code>函数目前不支持其他类型的过滤器和指令。过滤器需要使用<code>type</code>函数来允许过滤器。支持逻辑与或操作。例如，<code>expand(_all_) @filter(type(Person) OR type(Animal))</code>将只扩展指向任一类型节点的边。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="级联指令"><a class="header" href="#级联指令">级联指令</a></h1>
<p>使用<code>@cascade</code>指令，没有在查询中指定所有谓词的节点将被删除。在应用了某些筛选器或节点可能没有列出所有谓词的情况下，这可能很有用。</p>
<p>查询例：《哈利波特》电影，每个演员和角色都扮演过。使用<code>cascade</code>，任何不是由名为沃里克的演员扮演的角色都会被删除，就像任何没有名为沃里克的演员的《哈利波特》电影一样。如果没有“级联”，所有角色都会回归，但只有那些由名为沃里克的演员扮演的角色才会有演员的名字：</p>
<pre><code class="language-graphql">{
  HP(func: allofterms(name@en, &quot;Harry Potter&quot;)) @cascade {
    name@en
    starring{
        performance.character {
          name@en
        }
        performance.actor @filter(allofterms(name@en, &quot;Warwick&quot;)){
            name@en
         }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;HP&quot;: [
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Chamber of Secrets&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Deathly Hallows - Part I&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Griphook&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Deathly Hallows – Part 2&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          },
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Griphook&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Prisoner of Azkaban&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Order of the Phoenix&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Goblet of Fire&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Half-Blood Prince&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Philosopher's Stone&quot;,
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Goblin Bank Teller&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          },
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>您也可以在内部查询块上应用<code>@cascade</code>：</p>
<pre><code class="language-graphql">{
  HP(func: allofterms(name@en, &quot;Harry Potter&quot;)) {
    name@en
    genre {
      name@en
    }
    starring @cascade {
        performance.character {
          name@en
        }
        performance.actor @filter(allofterms(name@en, &quot;Warwick&quot;)){
            name@en
         }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;HP&quot;: [
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Chamber of Secrets&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Family&quot;
          },
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Fantasy&quot;
          },
          {
            &quot;name@en&quot;: &quot;Mystery&quot;
          }
        ],
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Professor Filius Flitwick&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Harry Potter and the Deathly Hallows - Part I&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Fiction&quot;
          },
          {
            &quot;name@en&quot;: &quot;Family&quot;
          },
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Drama&quot;
          },
          {
            &quot;name@en&quot;: &quot;Fantasy&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Mystery&quot;
          }
        ],
        &quot;starring&quot;: [
          {
            &quot;performance.character&quot;: [
              {
                &quot;name@en&quot;: &quot;Griphook&quot;
              }
            ],
            &quot;performance.actor&quot;: [
              {
                &quot;name@en&quot;: &quot;Warwick Davis&quot;
              }
            ]
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h2 id="参数化cascade"><a class="header" href="#参数化cascade">参数化@cascade</a></h2>
<p><code>@cascade</code>指令可以选择一个字段列表作为参数。这将更改默认行为，只考虑提供的字段，而不是类型的所有字段。列出的字段自动级联为嵌套选择集的必需参数。参数化的级联作用于层次(例如根函数或更低的层次)，所以你需要在你想要应用它的确切层次上指定<code>@cascade(param)</code>。</p>
<blockquote>
<p>提示：<code>@cascade(predicate)</code>的规则是，谓词需要在查询中处于与<code>@cascade</code>相同的级别。</p>
</blockquote>
<p>以下查询为例：</p>
<pre><code class="language-graphql">{
  nodes(func: allofterms(name@en, &quot;jones indiana&quot;)) {
    name@en
    genre @filter(anyofterms(name@en, &quot;action adventure&quot;)) {
      name@en
    }
    produced_by {
      name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;nodes&quot;: [
      {
        &quot;name@en&quot;: &quot;The Adventures of Young Indiana Jones: Passion for Life&quot;
      },
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Temple of Doom&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action/Adventure&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Costume Adventure&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Robert Watts&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;The Adventures of Young Indiana Jones: The Perils of Cupid&quot;
      },
      {
        &quot;name@en&quot;: &quot;The Adventures of Young Indiana Jones: Daredevils of the Desert&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<p>该查询获取包含所有术语<code>jones indiana</code>的节点，然后遍历<code>genre</code>和<code>produced_by</code>。它还为游戏类型添加了一个额外的筛选条件，即只能获得名称中包含“动作”或“冒险”内容的游戏。结果包括没有类型的节点和没有类型和制作人的节点。</p>
<p>如果你使用没有参数的常规@级联，你就会失去那些有题材但没有制作人的游戏。</p>
<p>要获得具有遍历类型但可能没有<code>produced_by</code>的节点，你可以参数化级联：</p>
<pre><code class="language-graphql">{
  nodes(func: allofterms(name@en, &quot;jones indiana&quot;)) @cascade(genre) {
    name@en
    genre @filter(anyofterms(name@en, &quot;action adventure&quot;)) {
      name@en
    }
    produced_by {
      name@en
    }
    written_by {
      name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;nodes&quot;: [
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Temple of Doom&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action/Adventure&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Costume Adventure&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Robert Watts&quot;
          }
        ],
        &quot;written_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Gloria Katz&quot;
          },
          {
            &quot;name@en&quot;: &quot;Willard Huyck&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<p>如果您想检查多个字段，只需用逗号分隔它们。例如，级联produced_by和written_by:</p>
<pre><code class="language-graphql">{
  nodes(func: allofterms(name@en, &quot;jones indiana&quot;)) @cascade(produced_by,written_by) {
    name@en
    genre @filter(anyofterms(name@en, &quot;action adventure&quot;)) {
      name@en
    }
    produced_by {
      name@en
    }
    written_by {
      name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;nodes&quot;: [
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Temple of Doom&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action/Adventure&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Costume Adventure&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Robert Watts&quot;
          }
        ],
        &quot;written_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Gloria Katz&quot;
          },
          {
            &quot;name@en&quot;: &quot;Willard Huyck&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Raiders of the Lost Ark&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Frank Marshall&quot;
          }
        ],
        &quot;written_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Lawrence Kasdan&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Kingdom of the Crystal Skull&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Comedy&quot;
          },
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Costume Adventure&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Frank Marshall&quot;
          },
          {
            &quot;name@en&quot;: &quot;Flávio R. Tambellini&quot;
          }
        ],
        &quot;written_by&quot;: [
          {
            &quot;name@en&quot;: &quot;David Koepp&quot;
          }
        ]
      }
      ...
    ]
  }
}
</code></pre>
<h3 id="嵌套和参数化级联"><a class="header" href="#嵌套和参数化级联">嵌套和参数化级联</a></h3>
<p>字段选择的级联特性被嵌套的@cascade覆盖。</p>
<p>前面的示例也可以沿链级联，并根据需要在每个级别上重写。</p>
<p>例如，如果你只想要“由制作《侏罗纪世界》的同一个人制作的印第安纳·琼斯电影”:</p>
<pre><code class="language-graphql">{
  nodes(func: allofterms(name@en, &quot;jones indiana&quot;)) @cascade(produced_by) {
    name@en
    genre @filter(anyofterms(name@en, &quot;action adventure&quot;)) {
      name@en
    }
    produced_by @cascade(producer.film) {
      name@en
      producer.film @filter(allofterms(name@en, &quot;jurassic world&quot;)) {
        name@en
      }
    }
    written_by {
      name@en
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;nodes&quot;: [
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Raiders of the Lost Ark&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Frank Marshall&quot;,
            &quot;producer.film&quot;: [
              {
                &quot;name@en&quot;: &quot;Jurassic World&quot;
              }
            ]
          }
        ],
        &quot;written_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Lawrence Kasdan&quot;
          }
        ]
      },
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Kingdom of the Crystal Skull&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Comedy&quot;
          },
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Costume Adventure&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Frank Marshall&quot;,
            &quot;producer.film&quot;: [
              {
                &quot;name@en&quot;: &quot;Jurassic World&quot;
              }
            ]
          }
        ],
        &quot;written_by&quot;: [
          {
            &quot;name@en&quot;: &quot;David Koepp&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>另一个嵌套的例子：找到《星球大战》和《侏罗纪世界》的编剧和制片人是同一个人的《印第安纳琼斯》电影：</p>
<pre><code class="language-graphql">{
  nodes(func: allofterms(name@en, &quot;jones indiana&quot;)) @cascade(produced_by,written_by) {
    name@en
    genre @filter(anyofterms(name@en, &quot;action adventure&quot;)) {
      name@en
    }
    produced_by @cascade(producer.film) {
      name@en
      producer.film @filter(allofterms(name@en, &quot;jurassic world&quot;)) {
        name@en
      }
    }
    written_by @cascade(writer.film) {
      name@en
      writer.film @filter(allofterms(name@en, &quot;star wars&quot;)) {
        name@en
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;nodes&quot;: [
      {
        &quot;name@en&quot;: &quot;Indiana Jones and the Raiders of the Lost Ark&quot;,
        &quot;genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Adventure Film&quot;
          },
          {
            &quot;name@en&quot;: &quot;Action Film&quot;
          }
        ],
        &quot;produced_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Frank Marshall&quot;,
            &quot;producer.film&quot;: [
              {
                &quot;name@en&quot;: &quot;Jurassic World&quot;
              }
            ]
          }
        ],
        &quot;written_by&quot;: [
          {
            &quot;name@en&quot;: &quot;Lawrence Kasdan&quot;,
            &quot;writer.film&quot;: [
              {
                &quot;name@en&quot;: &quot;Star Wars Episode V: The Empire Strikes Back&quot;
              },
              {
                &quot;name@en&quot;: &quot;Star Wars: The Force Awakens&quot;
              }
            ]
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="规范指令"><a class="header" href="#规范指令">规范指令</a></h1>
<p>使用<code>@normalize</code>指令，只返回有别名的谓词，并将结果平化以删除嵌套。</p>
<p>查询示例：<code>Steven Spielberg</code>每部电影的电影名，国家和前两位演员(按<code>UID</code>顺序)，没有<code>initial_release_date</code>，因为没有给出别名并通过<code>@normalize</code>进行平化：</p>
<pre><code class="language-graphql">{
  director(func:allofterms(name@en, &quot;steven spielberg&quot;)) @normalize {
    director: name@en
    director.film {
      film: name@en
      initial_release_date
      starring(first: 2) {
        performance.actor {
          actor: name@en
        }
        performance.character {
          character: name@en
        }
      }
      country {
        country: name@en
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;director&quot;: [
      {
        &quot;director&quot;: &quot;Steven Spielberg&quot;,
        &quot;film&quot;: &quot;Hook&quot;,
        &quot;actor&quot;: &quot;John Michael&quot;,
        &quot;character&quot;: &quot;Doctor&quot;,
        &quot;country&quot;: &quot;United States of America&quot;
      },
      {
        &quot;director&quot;: &quot;Steven Spielberg&quot;,
        &quot;film&quot;: &quot;Hook&quot;,
        &quot;actor&quot;: &quot;Brad Parker&quot;,
        &quot;character&quot;: &quot;Jim&quot;,
        &quot;country&quot;: &quot;United States of America&quot;
      },
      {
        &quot;director&quot;: &quot;Steven Spielberg&quot;,
        &quot;film&quot;: &quot;The Color Purple&quot;,
        &quot;actor&quot;: &quot;Carl Anderson&quot;,
        &quot;country&quot;: &quot;United States of America&quot;
      },
      {
        &quot;director&quot;: &quot;Steven Spielberg&quot;,
        &quot;film&quot;: &quot;The Color Purple&quot;,
        &quot;actor&quot;: &quot;Oprah Winfrey&quot;,
        &quot;character&quot;: &quot;Sofia&quot;,
        &quot;country&quot;: &quot;United States of America&quot;
      }
      ...
    ]
  }
}
</code></pre>
<p>还可以在嵌套查询块上应用<code>@normalize</code>。它将以类似的方式工作，但只是使应用了<code>@normalize</code>的嵌套查询块的结果变平。<code>@normalize</code>将返回一个列表，不管它应用在哪个类型的属性上：</p>
<pre><code class="language-graphql">{
  director(func:allofterms(name@en, &quot;steven spielberg&quot;)) {
    director: name@en
    director.film {
      film: name@en
      initial_release_date
      starring(first: 2) @normalize {
        performance.actor {
          actor: name@en
        }
        performance.character {
          character: name@en
        }
      }
      country {
        country: name@en
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;director&quot;: [
      {
        &quot;director&quot;: &quot;Steven Spielberg&quot;,
        &quot;director.film&quot;: [
          {
            &quot;film&quot;: &quot;Hook&quot;,
            &quot;initial_release_date&quot;: &quot;1991-12-08T00:00:00Z&quot;,
            &quot;starring&quot;: [
              {
                &quot;actor&quot;: &quot;John Michael&quot;,
                &quot;character&quot;: &quot;Doctor&quot;
              },
              {
                &quot;actor&quot;: &quot;Brad Parker&quot;,
                &quot;character&quot;: &quot;Jim&quot;
              }
            ],
            &quot;country&quot;: [
              {
                &quot;country&quot;: &quot;United States of America&quot;
              }
            ]
          },
          {
            &quot;film&quot;: &quot;The Color Purple&quot;,
            &quot;initial_release_date&quot;: &quot;1985-12-16T00:00:00Z&quot;,
            &quot;starring&quot;: [
              {
                &quot;actor&quot;: &quot;Carl Anderson&quot;
              },
              {
                &quot;actor&quot;: &quot;Oprah Winfrey&quot;,
                &quot;character&quot;: &quot;Sofia&quot;
              }
            ],
            &quot;country&quot;: [
              {
                &quot;country&quot;: &quot;United States of America&quot;
              }
            ]
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ignorereflex-指令"><a class="header" href="#ignorereflex-指令">ignorereflex 指令</a></h1>
<p><code>@ignorereflex</code>指令强制通过查询结果中的任何路径删除作为父节点可访问的子节点</p>
<p>查询示例：<code>Rutger Hauer</code>的所有合作者。如果没有<code>@ignorereflex</code>，结果也会包括<code>Rutger Hauer</code>每一部电影：</p>
<pre><code class="language-graphql">{
  coactors(func: eq(name@en, &quot;Rutger Hauer&quot;)) @ignorereflex {
    actor.film {
      performance.film {
        starring {
          performance.actor {
            name@en
          }
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;coactors&quot;: [
      {
        &quot;actor.film&quot;: [
          {
            &quot;performance.film&quot;: [
              {
                &quot;starring&quot;: [
                  {
                    &quot;performance.actor&quot;: [
                      {
                        &quot;name@en&quot;: &quot;John de Lancie&quot;
                      }
                    ]
                  },
                  {
                    &quot;performance.actor&quot;: [
                      {
                        &quot;name@en&quot;: &quot;Lauren Lee Smith&quot;
                      }
                    ]
                  },
                  {
                    &quot;performance.actor&quot;: [
                      {
                        &quot;name@en&quot;: &quot;Dan Callahan&quot;
                      }
                    ]
                  }
                  ...
                ]
              }
            ]
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试"><a class="header" href="#调试">调试</a></h1>
<p>出于调试的目的，可以将查询参数<code>debug=true</code>附加到查询。附加这个参数可以让您在响应的扩展键下检索所有实体的<code>uid</code>属性以及<code>server_latency</code>和<code>start_ts</code>信息。</p>
<ul>
<li><code>parsing_ns</code>: 解析查询的延迟(以纳秒为单位)。</li>
<li><code>processing_ns</code>: 处理查询的延迟(以纳秒为单位)。</li>
<li><code>encoding_ns</code>: 对<code>JSON</code>响应进行编码的延迟(以纳秒为单位)。</li>
<li><code>start_ts</code>: 事务的逻辑开始时间戳。</li>
</ul>
<p>以debug作为查询参数的查询：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/dql&quot; http://localhost:8080/query?debug=true -XPOST -d $'{
  tbl(func: allofterms(name@en, &quot;The Big Lebowski&quot;)) {
    name@en
  }
}' | python -m json.tool | less
</code></pre>
<p>返回<code>uid</code>和<code>server_latency</code></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;tbl&quot;: [
      {
        &quot;uid&quot;: &quot;0x41434&quot;,
        &quot;name@en&quot;: &quot;The Big Lebowski&quot;
      },
      {
        &quot;uid&quot;: &quot;0x145834&quot;,
        &quot;name@en&quot;: &quot;The Big Lebowski 2&quot;
      },
      {
        &quot;uid&quot;: &quot;0x2c8a40&quot;,
        &quot;name@en&quot;: &quot;Jeffrey \&quot;The Big\&quot; Lebowski&quot;
      },
      {
        &quot;uid&quot;: &quot;0x3454c4&quot;,
        &quot;name@en&quot;: &quot;The Big Lebowski&quot;
      }
    ],
    &quot;extensions&quot;: {
      &quot;server_latency&quot;: {
        &quot;parsing_ns&quot;: 18559,
        &quot;processing_ns&quot;: 802990982,
        &quot;encoding_ns&quot;: 1177565
      },
      &quot;txn&quot;: {
        &quot;start_ts&quot;: 40010
      }
    }
  }
}
</code></pre>
<blockquote>
<p>注意<code>GraphQL+-</code>已重命名为<code>Dgraph</code>查询语言(<code>DQL</code>)。虽然<code>application/dql</code>是<code>Content-Type</code>头的首选值，但我们将继续支持<code>Content-Type: application/graphql+-</code>，以避免进行破坏性的更改。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>对于每个谓词，模式指定目标的类型。如果谓词<code>p</code>的类型为<code>T</code>，那么对于所有主语-谓词-对象三元组<code>s p o</code>，对象<code>o</code>的模式类型为<code>T</code>。</p>
<ul>
<li>在发生突变时，将检查标量类型，如果值不能转换为模式类型，则抛出错误。</li>
<li>在查询时，根据谓词的模式类型返回值结果。</li>
</ul>
<p>如果在突变为谓词添加三元组之前没有指定模式类型，则从第一次突变推断该类型。这种类型是:</p>
<ul>
<li>类型uid，如果谓词的第一个变异具有主语和宾语的节点，或者</li>
<li>如果对象是文字且RDF类型出现在第一个变体中，则从RDF类型派生，或者</li>
<li>默认类型</li>
</ul>
<h2 id="schema类型"><a class="header" href="#schema类型">Schema类型</a></h2>
<p><code>Dgraph</code>支持标量类型和<code>UID</code>类型。</p>
<h3 id="scalar-标量类型"><a class="header" href="#scalar-标量类型">Scalar 标量类型</a></h3>
<p>对于所有具有标量类型谓词的三元组，对象都是文字。</p>
<table><thead><tr><th><code>Dgraph</code>类型</th><th><code>Go</code>类型</th></tr></thead><tbody>
<tr><td>default</td><td>string</td></tr>
<tr><td>int</td><td>int64</td></tr>
<tr><td>float</td><td>float</td></tr>
<tr><td>string</td><td>string</td></tr>
<tr><td>bool</td><td>bool</td></tr>
<tr><td>dateTime</td><td>time.Time(RFC3399 时间格式[可选的时区] 例如： 2006-01-02T15:04:05.999999999+10:00 或者 2006-01-02T15:04:05.999999999)</td></tr>
<tr><td>geo</td><td><a href="https://github.com/twpayne/go-geom">go-geom</a></td></tr>
<tr><td>password</td><td>string(被加密的)</td></tr>
</tbody></table>
<blockquote>
<p>注意，只有当dateTime标量类型兼容RFC 3339时，Dgraph才支持日期和时间格式，这与ISO 8601(在RDF规范中定义)不同。在将值发送到Dgraph之前，应该将其转换为RFC 3339格式。</p>
</blockquote>
<h2 id="uid-类型"><a class="header" href="#uid-类型">UID 类型</a></h2>
<p>uid类型表示节点-节点边；在内部，每个节点都表示为一个<code>uint64 id</code>。</p>
<table><thead><tr><th><code>Dgraph</code> 类型</th><th><code>Go</code>类型</th></tr></thead><tbody>
<tr><td>uid</td><td>uint64</td></tr>
</tbody></table>
<h2 id="添加或者修改-schema"><a class="header" href="#添加或者修改-schema">添加或者修改 Schema</a></h2>
<p>通过指定模式为列表类型，还可以为标准普尔添加多个标量值。下面示例中的<code>occupation</code>可以存储每个<code>S P</code>的字符串列表。</p>
<p>索引是用<code>@index</code>指定的，用参数指定标记器。当为谓词指定索引时，必须指定索引的类型。例如：</p>
<pre><code class="language-schema">name: string @index(exact, fulltext) @count .
multiname: string @lang .
age: int @index(int) .
friend: [uid] @count .
dob: dateTime .
location: geo @index(geo) .
occupations: [string] @index(term) .
</code></pre>
<p>如果没有为谓词存储数据，模式突变将设置一个空模式，准备接收三元组。</p>
<p>如果数据在突变之前已经存储，则不会检查现有的值以符合新模式。在查询时，Dgraph尝试将现有值转换为新的模式类型，忽略任何转换失败的值。</p>
<p>如果数据存在，并且在模式变化中指定了新索引，则删除未在更新列表中的任何索引，并为每个指定的新标记器创建一个新索引。</p>
<p>如果由模式变异指定，反向边也会被计算。</p>
<blockquote>
<p>注意，不能定义以dgraph开头的谓词名称。，它保留为Dgraph的内部类型/谓词的名称空间。例如，将dgraph.name定义为谓词是无效的。</p>
</blockquote>
<h2 id="在后台处理索引"><a class="header" href="#在后台处理索引">在后台处理索引</a></h2>
<p>根据数据的大小，索引的计算时间可能会很长。从Dgraph版本20.03.0开始，索引可以在后台计算，因此索引可能在Alter操作返回后仍在运行。这要求您在运行需要新创建索引的查询之前等待索引完成。这样的查询将失败，并出现一个错误，通知给定谓词没有索引或没有反向边。</p>
<p>如果已经在修改一个错误架构，那么alter操作也会失败。请重试。不过，在索引进行时，突变可以成功执行。</p>
<p>例如，假设我们用下面的模式执行一个Alter操作：</p>
<pre><code class="language-schema">name: string @index(fulltext, term) .
age: int @index(int) @upsert .
friend: [uid] @count @reverse .
</code></pre>
<p>一旦Alter操作返回，Dgraph将报告以下模式，并启动后台任务来计算所有新的索引：</p>
<pre><code class="language-schema">name: string .
age: int @upsert .
friend: [uid] .
</code></pre>
<p>当索引计算完成后，Dgraph将开始报告模式中的索引。在多节点集群中，alpha可能会在不同的时间完成计算索引。在这种情况下，alpha可能会返回不同的模式，直到在所有alpha上完成所有索引的计算。</p>
<p>如果在计算索引时出现意外错误，可能导致后台索引任务失败。您应该重试Alter操作，以便更新架构，或跨所有alpha同步架构。</p>
<p>要了解如何检查后台索引状态，请参见<a href="https://dgraph.io/docs/master/deploy/dgraph-alpha/#querying-health">查询运行状况</a>。</p>
<h2 id="http-api"><a class="header" href="#http-api">HTTP API</a></h2>
<p><em>todo</em></p>
<h2 id="grpc-api"><a class="header" href="#grpc-api">Grpc API</a></h2>
<p><em>todo</em></p>
<h2 id="predicate-规则"><a class="header" href="#predicate-规则">Predicate 规则</a></h2>
<p><code>Predicate</code>允许任何字母数字组合。<code>Dgraph</code>还支持国际化资源标识符<a href="https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier">IRIs</a>。您可以在谓词<a href="https://dgraph.io/docs/query-language/schema/#predicates-i18n">i18n</a>中了解更多信息。</p>
<h3 id="允许特殊字符"><a class="header" href="#允许特殊字符">允许特殊字符</a></h3>
<p>不接受单个特殊字符，包括来自IRIs的特殊字符。它们必须以字母数字字符作为前缀/后缀：</p>
<pre><code class="language-schema">][&amp;*()_-+=!#$%
</code></pre>
<blockquote>
<p>注意：我们不会限制您使用@后缀，但是后缀字符将被忽略。</p>
</blockquote>
<h3 id="被禁止的特殊字符串"><a class="header" href="#被禁止的特殊字符串">被禁止的特殊字符串</a></h3>
<pre><code class="language-schema">^}|{`\~
</code></pre>
<h2 id="predicate-国际化"><a class="header" href="#predicate-国际化">Predicate 国际化</a></h2>
<p>如果<code>predicate</code>是<code>URI</code>或具有特定于语言的字符，则在执行模式更改时用尖括号&lt;&gt;将其括起来。</p>
<blockquote>
<p>注意，<code>Dgraph</code>支持谓词名称和值的国际化资源标识符(<code>IRIs</code>)。</p>
</blockquote>
<p>Schema 解析：</p>
<pre><code class="language-schema">&lt;职业&gt;: string @index(exact) .
&lt;年龄&gt;: int @index(int) .
&lt;地点&gt;: geo @index(geo) .
&lt;公司&gt;: string .
</code></pre>
<p>该语法允许国际化谓词名称，但全文索引默认仍为英语。要为您的语言使用正确的标记器，您需要使用<code>@lang</code>指令并使用语言标记输入值。</p>
<p>Schema:</p>
<pre><code class="language-schema">&lt;公司&gt;: string @index(fulltext) @lang .
</code></pre>
<p>变更数据：</p>
<pre><code class="language-schema">{
  set {
    _:a &lt;公司&gt; &quot;Dgraph Labs Inc&quot;@en .
    _:b &lt;公司&gt; &quot;夏新科技有限责任公司&quot;@zh .
    _:a &lt;dgraph.type&gt; &quot;Company&quot; .
  }
}
</code></pre>
<p>查询数据：</p>
<pre><code class="language-graphql">{
  q(func: alloftext(&lt;公司&gt;@zh, &quot;夏新科技有限责任公司&quot;)) {
    uid
    &lt;公司&gt;@.
  }
}
</code></pre>
<h2 id="插入指令-upsert-directive"><a class="header" href="#插入指令-upsert-directive">插入指令 Upsert directive</a></h2>
<p>要在<code>predicate</code>上使用<code>upsert</code>操作，请在模式中指定<code>@upsert</code>指令。当使用<code>@upsert</code>指令提交涉及<code>predicate</code>的事务时，<code>Dgraph</code>会检查索引键是否存在冲突，这有助于在运行并发<code>upsert</code>时执行唯一性约束。</p>
<p>这就是为<code>predicate</code>指定<code>upsert</code>指令的方法。</p>
<pre><code class="language-schema">email: string @index(exact) @upsert .
</code></pre>
<h2 id="noconflict-directive"><a class="header" href="#noconflict-directive">Noconflict directive</a></h2>
<p><code>NoConflict</code>指令防止在<code>predicate</code>级别进行冲突检测。这是一个实验性的特性，不是一个推荐的指令，但它的存在是为了帮助避免不具有高正确性要求的谓词的冲突。这可能会导致数据丢失，特别是当使用带有<code>count</code>索引的谓词时。</p>
<p>这就是为谓词指定<code>@noconflict</code>指令的方式：</p>
<pre><code class="language-schema">email: string @index(exact) @noconflict .
</code></pre>
<h2 id="rdf-类型"><a class="header" href="#rdf-类型">RDF 类型</a></h2>
<p><code>Dgraph</code>在变更中支持许多<code>RDF</code>类型。</p>
<p>除了在第一次更改时暗示模式类型外，<code>RDF</code>类型还可以覆盖用于存储的模式类型。</p>
<p>如果<code>predicate</code>具有模式类型，而变体具有具有不同基础<code>Dgraph</code>类型的<code>RDF</code>类型，则会检查模式类型的可转换性，如果它们不兼容，则会抛出错误，但值存储在<code>RDF</code>类型对应的<code>Dgraph</code>类型中。查询结果总是以模式类型返回。</p>
<p>例如，如果没有为年龄谓词设置模式。给出如下变更：</p>
<p><code>Dgraph</code>:</p>
<ul>
<li>将模式类型设置为<code>int</code>，正如前一个三元组所暗示的那样。</li>
<li>将<code>13</code>在存储上转换为<code>int</code>。</li>
<li>检查<code>14</code>可以转换为<code>int</code>，但存储为字符串。</li>
<li>为其余两个三元组抛出错误，因为<code>14.5</code>不能转换为<code>int</code>。</li>
</ul>
<h2 id="扩展类型-extended-types"><a class="header" href="#扩展类型-extended-types">扩展类型 Extended Types</a></h2>
<h3 id="password-类型"><a class="header" href="#password-类型">Password 类型</a></h3>
<p>通过将属性的模式设置为<code>password</code>类型来设置实体的密码。不能直接查询密码，只能通过<code>checkpwd</code>函数进行匹配检查。密码使用<code>bcrypt</code>加密。</p>
<p>例如：设置密码，首先设置<code>schema</code>，然后设置密码：</p>
<pre><code class="language-schema">pass: password .
</code></pre>
<p>使用变更设置密码：</p>
<pre><code class="language-graphql">{
  set {
    &lt;0x123&gt; &lt;name&gt; &quot;Password Example&quot; .
    &lt;0x123&gt; &lt;pass&gt; &quot;ThePassword&quot; .
  }
}
</code></pre>
<p>测试密码是否正确：</p>
<pre><code class="language-graphql">{
  check(func: uid(0x123)) {
    name
    checkpwd(pass, &quot;ThePassword&quot;)
  }
}
</code></pre>
<p>返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;check&quot;: [
      {
        &quot;name&quot;: &quot;Password Example&quot;,
        &quot;checkpwd(pass)&quot;: true
      }
    ]
  }
}
</code></pre>
<p>在<code>checkpwd</code>函数上使用别名：</p>
<pre><code class="language-graphql">{
  check(func: uid(0x123)) {
    name
    secret: checkpwd(pass, &quot;ThePassword&quot;)
  }
}
</code></pre>
<p>返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;check&quot;: [
      {
        &quot;name&quot;: &quot;Password Example&quot;,
        &quot;secret&quot;: true
      }
    ]
  }
}
</code></pre>
<h3 id="indexing-索引"><a class="header" href="#indexing-索引">Indexing 索引</a></h3>
<blockquote>
<p>在一个 predicate 上使用函数需要指定索引</p>
</blockquote>
<p>当通过应用函数进行筛选时，<code>Dgraph</code>使用索引来高效地搜索可能较大的数据集。</p>
<p>所有标量类型都可以被索引。</p>
<p>类型<code>int</code>, <code>float</code>, <code>bool</code>和<code>geo</code>都只有一个默认索引：带有命名为<code>int</code>, <code>float</code>, <code>bool</code>和<code>geo</code>的标记器。</p>
<p>类型<code>string</code>和<code>dateTime</code>有许多索引。</p>
<h4 id="string-indices"><a class="header" href="#string-indices">String Indices</a></h4>
<p><code>String</code>类型的值可用下表的索引进行检索：</p>
<table><thead><tr><th><code>Dgraph</code>函数</th><th>需要的索引或<code>tokenizer</code></th><th>标注</th></tr></thead><tbody>
<tr><td><code>eq</code></td><td><code>hash</code> <code>exact</code> <code>term</code> <code>fulltext</code></td><td>eq的最佳性能指标是哈希值。只有在您还需要术语或全文搜索时才使用<code>term</code>或<code>fulltext</code>。如果您已经在使用<code>term</code>，那么也不需要使用<code>hash</code>或<code>exact</code>。</td></tr>
<tr><td><code>le</code> <code>ge</code> <code>lt</code> <code>gt</code></td><td><code>exact</code></td><td>允许更快地查询</td></tr>
<tr><td><code>allofterms</code> <code>amyofterms</code></td><td><code>term</code></td><td>允许在一个句子中使用短语查询</td></tr>
<tr><td><code>alloftext</code> <code>anyoftext</code></td><td><code>fulltext</code></td><td>匹配特定语言的词干和停止词。</td></tr>
<tr><td><code>regexp</code></td><td><code>trigram</code></td><td>正则表达式匹配。也可用于相等检查。</td></tr>
</tbody></table>
<blockquote>
<p>错误的索引选择可能会导致性能损失和增加事务冲突率。只使用应用程序需要的最小数量和最简单的索引。</p>
</blockquote>
<h4 id="datetime-indices"><a class="header" href="#datetime-indices">DateTime Indices</a></h4>
<p><code>DateTime</code>类型的值可用下表地索引进行检索：</p>
<table><thead><tr><th>索引名字 <code>tokenizer</code></th><th>索引到的日期的部分</th></tr></thead><tbody>
<tr><td><code>year</code></td><td>索引到年份(默认)</td></tr>
<tr><td><code>month</code></td><td>索引年份和月份</td></tr>
<tr><td><code>day</code></td><td>索引年份、月份、天</td></tr>
<tr><td><code>hour</code></td><td>索引年份、月份、天、小时</td></tr>
</tbody></table>
<p><code>dateTime</code>索引的选择允许选择索引的精度。应用程序，如这些文档中的电影示例，需要搜索日期，但每年的节点相对较少，可能更喜欢年份标记器;依赖于细粒度日期搜索(如实时传感器读数)的应用程序可能更喜欢小时索引。</p>
<p>所有的<code>dateTime</code>索引都是可排序的。</p>
<h4 id="sortable-indices"><a class="header" href="#sortable-indices">Sortable Indices</a></h4>
<p>并不是所有的索引都在它们索引的值之间建立一个总的顺序。可排序索引允许不等式函数和排序。</p>
<ul>
<li>索引<code>int</code>和<code>float</code>是可排序的。</li>
<li>字符串索引精确是可排序的。</li>
<li>所有的<code>dateTime</code>索引都是可排序的。</li>
</ul>
<p>例如，给定一个字符串类型的边名，要按名称排序或对名称执行不等过滤，必须指定确切的索引。在这种情况下，模式查询将至少返回以下标记器：</p>
<pre><code class="language-json">{
  &quot;predicate&quot;: &quot;name&quot;,
  &quot;type&quot;: &quot;string&quot;,
  &quot;index&quot;: true,
  &quot;tokenizer&quot;: [
    &quot;exact&quot;
  ]
}
</code></pre>
<h4 id="count-indices"><a class="header" href="#count-indices">Count Indices</a></h4>
<p>对于具有<code>@count</code> 的<code>predicate</code>，将每个节点的边数索引为索引。这样可以快速查询表单：</p>
<pre><code class="language-graphql">{
  q(func: gt(count(pred), threshold)) {
    ...
  }
}
</code></pre>
<h3 id="list-类型"><a class="header" href="#list-类型">List 类型</a></h3>
<p>如果在Schema中指定，变量类型的<code>predicate</code>也可以存储值的<code>list</code>。标量类型需要包含在<code>[]</code>中，以表明它是一个<code>list</code>类型。</p>
<pre><code class="language-schema">occupations: [string] .
score: [int] .
</code></pre>
<ul>
<li><code>set</code>操作添加到值列表中。存储值的顺序是不确定的。</li>
<li><code>delete</code>操作从列表中删除值。</li>
<li>查询这些谓词将返回数组中的列表。</li>
<li>索引可以应用于具有列表类型的谓词，并且可以对其使用函数。</li>
<li>不允许使用这些谓词进行排序。</li>
<li>这些列表就像一个无序的集合。例如：[&quot;e1&quot;， &quot;e1&quot;， &quot;e2&quot;]可能会被存储为[&quot;e2&quot;， &quot;e1&quot;]，也就是说，重复的值将不会被存储，顺序也不会被保留。</li>
</ul>
<h4 id="在list中使用过滤函数"><a class="header" href="#在list中使用过滤函数">在List中使用过滤函数</a></h4>
<p><code>Dgraph</code>支持基于<code>list</code>的过滤。过滤的工作原理类似于它在<code>edge</code>上的工作原理，并且具有相同的可用函数。</p>
<p>例如，查询或父边的<code>@filter(eq(occupation，&quot;Teacher&quot;))</code>将显示数组中每个节点的列表中的所有职业，但只包含将<code>Teacher</code>作为职业之一的节点。但是，不支持值边过滤。</p>
<h3 id="反转一条边"><a class="header" href="#反转一条边">反转一条边</a></h3>
<p>图的边是单向的。对于节点-节点边，有时建模需要反向边。如果只有一些主-谓词-对象三元组有反向，则必须手动添加它们。但是如果一个谓词总是有反向，如果在模式中指定了<code>@reverse</code>，则<code>Dgraph</code>会计算反向边。</p>
<p><code>anEdge</code>的反向边是<code>~anEdge</code>。</p>
<p>对于现有数据，<code>Dgraph</code>计算所有反向边。对于schema变更后添加的数据，<code>Dgraph</code>计算并存储每个添加的三元组的反向边。</p>
<pre><code class="language-schema">type Person {
  name string
}
type Car {
  regnbr string
  owner Person
}
owner uid @reverse .
regnbr string @index(exact) .
name string @index(exact) .
</code></pre>
<p>这使得查询<code>person</code>和他们的车成为可能：</p>
<pre><code class="language-graphql">q(func type(Person)) {
  name
  ~owner { name }
}
</code></pre>
<p>为了在结果中得到一个不同于<code>~owner</code>的键，可以用想要的标签(在本例中是<code>cars</code>)来编写查询：</p>
<pre><code class="language-graphql">q(func type(Person)) {
  name
  cars: ~owner { name }
}
</code></pre>
<p>如果一辆车有多个“所有者”，这也适用：</p>
<pre><code class="language-schema">owner [uid] @reverse .

</code></pre>
<p>在这两种情况下，<code>owner</code>边都应该设置在<code>Car</code>上：</p>
<pre><code class="language-schema">_:p1 &lt;name&gt; &quot;Mary&quot; .
_:p1 &lt;dgraph.type&gt; &quot;Person&quot; .
_:c1 &lt;regnbr&gt; &quot;ABC123&quot; .
_:c1 &lt;dgraph.type&gt; &quot;Car&quot; .
_:c1 &lt;owner&gt; _:p1
</code></pre>
<h3 id="查询-schema"><a class="header" href="#查询-schema">查询 Schema</a></h3>
<p>你可以使用下面的<code>DQL</code>语句查询整个<code>Schema</code>： </p>
<pre><code class="language-dql">schema {}
</code></pre>
<blockquote>
<p>注意：与常规查询不同，模式查询没有被花括号包围。此外，模式查询和常规查询不能一起使用。</p>
</blockquote>
<p>您可以在查询体中查询特定的模式字段：</p>
<pre><code class="language-dql">schema {
  type
  index
  reverse
  tokenizer
  list
  count
  upsert
  lang
}
</code></pre>
<p>你也可以查询特定的谓词：</p>
<pre><code class="language-dql">schema(pred: [name, friend]) {
  type
  index
  reverse
  tokenizer
  list
  count
  upsert
  lang
}
</code></pre>
<blockquote>
<p>注意，如果启用了ACL，那么模式查询只返回登录的ACL用户具有读访问权限的谓词。</p>
</blockquote>
<p>类型也可以查询。下面是一些示例查询：</p>
<pre><code class="language-dql">schema(type: Movie) {}
schema(type: [Person, Animal]) {}
</code></pre>
<p>注意，类型查询不包含花括号之间的任何内容。输出将是请求类型的完整定义。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型系统"><a class="header" href="#类型系统">类型系统</a></h1>
<p><code>Dgraph</code>支持一个类型系统，该系统可用于对节点进行分类，并根据节点的类型查询节点。在展开(expand)查询期间也使用类型系统。</p>
<h2 id="类型定义"><a class="header" href="#类型定义">类型定义</a></h2>
<p>类型是使用类似<code>graphql</code>的语法定义的。例如：</p>
<pre><code class="language-dql">type Student {
  name
  dob
  home_address
  year
  friends
}
</code></pre>
<blockquote>
<p>注意，不能定义以dgraph开头的类型名。，它保留为<code>Dgraph</code>的内部类型/predicate的名称空间。例如，定义<code>dgraph.student</code>类型无效。</p>
</blockquote>
<p>类型与模式一起使用<code>Alter</code>端点声明。为了正确支持上述类型，还需要为该类型中的每个属性指定一个<code>predicate</code>，例如：</p>
<pre><code class="language-dql">name: string @index(term) .
dob: datetime .
home_address: string .
year: int .
friends: [uid] .
</code></pre>
<p>反向谓词也可以包含在类型定义中。例如，如果有一个具有反向边的谓词子谓词(谓词名称周围的括号需要正确理解特殊字符~)，那么上面的类型可以扩展为包含student的父谓词。</p>
<pre><code class="language-dql">children: [uid] @reverse .

type Student {
  name
  dob
  home_address
  year
  friends
  &lt;~children&gt;
}
</code></pre>
<p>边可以用于多种类型:例如，名字可以同时用于人和宠物。但是，有时需要为每种类型使用不同的谓词来表示类似的概念。例如，如果学生名和图书名需要不同的索引，那么谓词必须不同。</p>
<pre><code class="language-dql">type Student {
  student_name
}

type Textbook {
  textbook_name
}

student_name: string @index(exact) .
textbook_name: string @lang @index(fulltext) .
</code></pre>
<p>更改已经存在的类型的模式，将覆盖现有的定义。</p>
<h2 id="设置一个节点的类型"><a class="header" href="#设置一个节点的类型">设置一个节点的类型</a></h2>
<p>标量节点不能具有类型，因为它们只有一个属性，且其类型是节点的类型。<code>UID</code>节点可以有一个类型。通过设置<code>dgraph</code>的值来设置类型。该节点的类型<code>predicate</code>。一个节点可以有多个类型。下面是一个如何设置节点类型的例子：</p>
<pre><code class="language-dql">{
  set {
    _:a &lt;name&gt; &quot;Garfield&quot; .
    _:a &lt;dgraph.type&gt; &quot;Pet&quot; .
    _:a &lt;dgraph.type&gt; &quot;Animal&quot; .
  }
}
</code></pre>
<p><code>dgraph.type</code>是保留谓词，不能删除或修改。</p>
<h2 id="在查询过程中使用类型系统"><a class="header" href="#在查询过程中使用类型系统">在查询过程中使用类型系统</a></h2>
<p>可以在查询的顶层函数中使用类型系统：</p>
<pre><code class="language-dql">{
  q(func: type(Animal)) {
    uid
    name
  }
}
</code></pre>
<p>这个查询将只返回类型设置为<code>Animal</code>的节点。</p>
<p>类型还可以用于过滤查询内部的结果。例如：</p>
<pre><code class="language-dql">{
  q(func: has(parent)) {
    uid
    parent @filter(type(Person)) {
      uid
      name
    }
  }
}
</code></pre>
<p>该查询将返回具有父谓词且只具有<code>Person</code>类型的父谓词的节点。</p>
<p>您还可以查询<code>dgraph.type</code>获取实体类型。例如：</p>
<pre><code class="language-dql">{
   people(func: eq(dgraph.type, &quot;Person&quot;)) {
      name
      dgraph.type
   }
}
</code></pre>
<p>或者</p>
<pre><code class="language-dql">{
   people(func: type(Person)) {
      name
      dgraph.type
   }
}
</code></pre>
<h2 id="删除一个类型"><a class="header" href="#删除一个类型">删除一个类型</a></h2>
<p>可以使用<code>Alter</code>端点删除类型定义。所有需要做的就是发送一个带有字段<code>DropOp</code>(或<code>drop_op</code>，取决于客户端)的操作对象到<code>enum</code>值<code>TYPE</code>，并将字段<code>DropValue</code>(或<code>drop_value</code>)发送到要删除的类型。</p>
<p>下面是一个使用<code>Go</code>客户端删除<code>Person</code>类型的例子：</p>
<pre><code class="language-go">err := c.Alter(context.Background(), &amp;api.Operation {
    DropOp: api.Operation_TYPE,
    DropValue: &quot;Person&quot;})
</code></pre>
<h2 id="展开查询与类型系统"><a class="header" href="#展开查询与类型系统">展开查询与类型系统</a></h2>
<p>使用<code>expand</code>的查询(例如:<code>expand(_all_)</code>)要求要扩展的节点具有类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="facet和edge属性"><a class="header" href="#facet和edge属性">facet和Edge属性</a></h1>
<p><code>Dgraph</code>支持<code>facet</code>————edge上的键值对————是<code>RDF</code>三元组的扩展。也就是说，<code>facet</code>向边添加属性，而不是向节点添加属性。例如，两个节点之间的朋友边可能具有亲密友谊的<code>bool</code>属性。<code>facet</code>也可以用作边(edge)的权重。</p>
<p>虽然你可能会发现自己很多时候倾向于一些方面，但它们不应该被滥用。例如，给<code>friend</code>这条边(edge)添加一个<code>date_of_birth</code>属性可能不是一个正经的建模。对于<code>friend</code>这条边，你更应该添加比如<code>start_of_friendship</code>这个属性。然而，<code>facet</code>在<code>Dgraph</code>中并不像谓词(<code>predicate</code>)那样是一等公民。</p>
<p><code>Facet</code>键是字符串，值可以是<code>string</code>、<code>bool</code>、<code>int</code>、<code>float</code>和<code>dateTime</code>。对于<code>int</code>和<code>float</code>，只接受32位有符号整数和64位浮点数。</p>
<p>下面这些对于<code>facet</code>的变更将会贯穿整章。该变更(mutation)为一些人添加了数据，例如，在<code>mobile</code>和<code>car</code>中记录了<code>since</code> <code>facet</code>，以记录<code>Alice</code>购买汽车并开始使用手机号码的时间。</p>
<p>首先，我们添加一些<code>Schema</code>：</p>
<pre><code class="language-bash">curl localhost:8080/alter -XPOST -d $'
    name: string @index(exact, term) .
    rated: [uid] @reverse @count .
' | python -m json.tool | less
</code></pre>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; localhost:8080/mutate?commitNow=true -XPOST -d $'
{
  set {

    # -- Facets on scalar predicates
    _:alice &lt;name&gt; &quot;Alice&quot; .
    _:alice &lt;dgraph.type&gt; &quot;Person&quot; .
    _:alice &lt;mobile&gt; &quot;040123456&quot; (since=2006-01-02T15:04:05) .
    _:alice &lt;car&gt; &quot;MA0123&quot; (since=2006-02-02T13:01:09, first=true) .

    _:bob &lt;name&gt; &quot;Bob&quot; .
    _:bob &lt;dgraph.type&gt; &quot;Person&quot; .
    _:bob &lt;car&gt; &quot;MA0134&quot; (since=2006-02-02T13:01:09) .

    _:charlie &lt;name&gt; &quot;Charlie&quot; .
    _:charlie &lt;dgraph.type&gt; &quot;Person&quot; .
    _:dave &lt;name&gt; &quot;Dave&quot; .
    _:dave &lt;dgraph.type&gt; &quot;Person&quot; .


    # -- Facets on UID predicates
    _:alice &lt;friend&gt; _:bob (close=true, relative=false) .
    _:alice &lt;friend&gt; _:charlie (close=false, relative=true) .
    _:alice &lt;friend&gt; _:dave (close=true, relative=true) .


    # -- Facets for variable propagation
    _:movie1 &lt;name&gt; &quot;Movie 1&quot; .
    _:movie1 &lt;dgraph.type&gt; &quot;Movie&quot; .
    _:movie2 &lt;name&gt; &quot;Movie 2&quot; .
    _:movie2 &lt;dgraph.type&gt; &quot;Movie&quot; .
    _:movie3 &lt;name&gt; &quot;Movie 3&quot; .
    _:movie3 &lt;dgraph.type&gt; &quot;Movie&quot; .

    _:alice &lt;rated&gt; _:movie1 (rating=3) .
    _:alice &lt;rated&gt; _:movie2 (rating=2) .
    _:alice &lt;rated&gt; _:movie3 (rating=5) .

    _:bob &lt;rated&gt; _:movie1 (rating=5) .
    _:bob &lt;rated&gt; _:movie2 (rating=5) .
    _:bob &lt;rated&gt; _:movie3 (rating=5) .

    _:charlie &lt;rated&gt; _:movie1 (rating=2) .
    _:charlie &lt;rated&gt; _:movie2 (rating=5) .
    _:charlie &lt;rated&gt; _:movie3 (rating=1) .
  }
}' | python -m json.tool | less
</code></pre>
<h2 id="标量scalar谓词predicate上的facets"><a class="header" href="#标量scalar谓词predicate上的facets">标量(scalar)谓词(predicate)上的Facets</a></h2>
<p>查询<code>Alice</code>的<code>name</code>、<code>mobile</code>和<code>Car</code>与不查询<code>facet</code>的结果相同：</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
     name
     mobile
     car
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;mobile&quot;: &quot;040123456&quot;,
        &quot;car&quot;: &quot;MA0123&quot;
      }
    ]
  }
}
</code></pre>
<p>语法<code>@facet (facet-name)</code>用于查询<code>facet</code>数据。对于<code>Alice</code>, <code>mobile</code>和<code>car</code>的<code>since</code> facet被查询如下：</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
     name
     mobile @facets(since)
     car @facets(since)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;mobile|since&quot;: &quot;2006-01-02T15:04:05Z&quot;,
        &quot;mobile&quot;: &quot;040123456&quot;,
        &quot;car|since&quot;: &quot;2006-02-02T13:01:09Z&quot;,
        &quot;car&quot;: &quot;MA0123&quot;
      }
    ]
  }
}
</code></pre>
<p><code>facet</code>在与对应的边(edge)相同的级别返回，并具有像<code>edge|facet</code>这样的键。</p>
<p>边(edge)上的所有<code>facet</code>都使用<code>@facet</code>查询：</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
     name
     mobile @facets
     car @facets
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;mobile|since&quot;: &quot;2006-01-02T15:04:05Z&quot;,
        &quot;mobile&quot;: &quot;040123456&quot;,
        &quot;car|first&quot;: true,
        &quot;car|since&quot;: &quot;2006-02-02T13:01:09Z&quot;,
        &quot;car&quot;: &quot;MA0123&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="facets-国际化"><a class="header" href="#facets-国际化">Facets 国际化</a></h2>
<p><code>facet</code>键和值在发生变化时可以直接使用特定于语言的字符。但是在查询时，<code>facet</code>键需要括在尖括号&lt;&gt;中。这类似于谓词。有关更多信息，请参阅谓词(predicate)<a href="https://dgraph.io/docs/query-language/schema/#predicates-i18n">i18n</a>。</p>
<blockquote>
<p>注意，在查询时，Dgraph支持面向键的国际化资源标识符(IRIs)。</p>
</blockquote>
<pre><code class="language-dql">{
  set {
    _:person1 &lt;name&gt; &quot;Daniel&quot; (वंश=&quot;स्पेनी&quot;, ancestry=&quot;Español&quot;) .
    _:person1 &lt;dgraph.type&gt; &quot;Person&quot; .
    _:person2 &lt;name&gt; &quot;Raj&quot; (वंश=&quot;हिंदी&quot;, ancestry=&quot;हिंदी&quot;) .
    _:person2 &lt;dgraph.type&gt; &quot;Person&quot; .
    _:person3 &lt;name&gt; &quot;Zhang Wei&quot; (वंश=&quot;चीनी&quot;, ancestry=&quot;中文&quot;) .
    _:person3 &lt;dgraph.type&gt; &quot;Person&quot; .
  }
}
</code></pre>
<p>查询，注意<code>&lt;&gt;</code>：</p>
<pre><code class="language-dql">{
  q(func: has(name)) {
    name @facets(&lt;वंश&gt;)
  }
}
</code></pre>
<h2 id="在facets上使用别名"><a class="header" href="#在facets上使用别名">在Facets上使用别名</a></h2>
<p>可以在请求特定谓词(predicate)时指定别名。语法类似于为其他谓词请求别名的方式。<code>orderasc</code>和<code>orderdesc</code>不允许作为别名，因为它们有特殊的含义。除此之外，其他任何东西都可以设置为别名。</p>
<p>这里我们分别为<code>since</code>、<code>close</code> facet设置<code>car_since</code>、<code>close_friend</code>别名：</p>
<pre><code class="language-dql">{
   data(func: eq(name, &quot;Alice&quot;)) {
     name
     mobile
     car @facets(car_since: since)
     friend @facets(close_friend: close) {
       name
     }
   }
}
</code></pre>
<pre><code class="language-dql">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;mobile&quot;: &quot;040123456&quot;,
        &quot;car_since&quot;: &quot;2006-02-02T13:01:09Z&quot;,
        &quot;car&quot;: &quot;MA0123&quot;,
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Bob&quot;,
            &quot;close_friend&quot;: true
          },
          {
            &quot;name&quot;: &quot;Charlie&quot;,
            &quot;close_friend&quot;: false
          },
          {
            &quot;name&quot;: &quot;Dave&quot;,
            &quot;close_friend&quot;: true
          }
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="uid谓词predicate上的facets"><a class="header" href="#uid谓词predicate上的facets"><code>UID</code>谓词(predicate)上的Facets</a></h2>
<p><code>UID</code>边(edge)上的<code>facet</code>与值边(value edge)上的<code>facet</code>的工作方式类似。</p>
<p>例如，<code>friend</code>这条边拥有一个<code>close</code>的<code>edge</code>。<code>Alice</code>和<code>Bob</code>的<code>friend</code>边(edge)的<code>close``facet</code>被设置为true，<code>Alice</code>和<code>Charlie</code>之间被设置为<code>false</code>。</p>
<p>现在查询<code>Alice</code>的朋友：</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
    name
    friend {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Bob&quot;
          },
          {
            &quot;name&quot;: &quot;Charlie&quot;
          },
          {
            &quot;name&quot;: &quot;Dave&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>查询<code>Alice</code>的朋友这条边(edge)上的<code>close``facet</code>为<code>false</code>的朋友：</p>
<pre><code class="language-dql">{
   data(func: eq(name, &quot;Alice&quot;)) {
     name
     friend @facets(close) {
       name
     }
   }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Bob&quot;,
            &quot;friend|close&quot;: true
          },
          {
            &quot;name&quot;: &quot;Charlie&quot;,
            &quot;friend|close&quot;: false
          },
          {
            &quot;name&quot;: &quot;Dave&quot;,
            &quot;friend|close&quot;: true
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>对于像<code>friend</code>这样的<code>UID</code>边(edge)，<code>facet</code>会转到相应子元素下。在上面的示例中，您可以看到<code>Alice</code>和<code>Bob</code>之间的边(edge)上的<code>close``facet</code>。</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
    name
    friend @facets {
      name
      car @facets
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Bob&quot;,
            &quot;car|since&quot;: &quot;2006-02-02T13:01:09Z&quot;,
            &quot;car&quot;: &quot;MA0134&quot;,
            &quot;friend|close&quot;: true,
            &quot;friend|relative&quot;: false
          },
          {
            &quot;name&quot;: &quot;Charlie&quot;,
            &quot;friend|close&quot;: false,
            &quot;friend|relative&quot;: true
          },
          {
            &quot;name&quot;: &quot;Dave&quot;,
            &quot;friend|close&quot;: true,
            &quot;friend|relative&quot;: true
          }
        ]
      }
    ]
  }
}
</code></pre>
<p><code>Bob</code>有一辆车，它有一个<code>facet</code> <code>since</code>，在结果中，它是<code>key car|since</code>下<code>Bob</code>的同一个对象的一部分。此外，<code>Bob</code>和<code>Alice</code>之间的密切关系也是<code>Bob</code>的输出对象的一部分。<code>Charlie</code>没有<code>Car</code>边(edge)，因此只有<code>UID</code> <code>facets</code>。</p>
<h2 id="在facets上使用过滤"><a class="header" href="#在facets上使用过滤">在facets上使用过滤</a></h2>
<p><code>Dgraph</code>支持基于<code>facet</code>的边(edge)过滤。过滤的工作原理类似于它在没有<code>facet</code>的边(edge)上的工作原理，并且具有相同的可用函数。</p>
<p>找到爱丽丝的好朋友：</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
    friend @facets(eq(close, true)) {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Bob&quot;
          },
          {
            &quot;name&quot;: &quot;Dave&quot;
          }
        ]
      }
    ]
  }
}

</code></pre>
<p>要返回facet和过滤器，请向查询添加另一个<code>@facet (&lt;facetname&gt;)</code>：</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
    friend @facets(eq(close, true)) @facets(relative) { # filter close friends and give relative status
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Bob&quot;,
            &quot;friend|relative&quot;: false
          },
          {
            &quot;name&quot;: &quot;Dave&quot;,
            &quot;friend|relative&quot;: true
          }
        ]
      }
    ]
  }
}
</code></pre>
<p><code>Facet</code>查询能够和<code>AND</code>, <code>OR</code>, <code>NOT</code> 组合使用：</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
    friend @facets(eq(close, true) AND eq(relative, true)) @facets(relative) { # filter close friends in my relation
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Dave&quot;,
            &quot;friend|relative&quot;: true
          }
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="使用facet排序"><a class="header" href="#使用facet排序">使用<code>Facet</code>排序</a></h2>
<p>可以对<code>uid</code>边(edge)上的<code>facet</code>进行排序。在这里，我们将爱丽丝、鲍勃和查理对电影的评级进行分类，这是一个<code>facet</code>：</p>
<pre><code class="language-dql">{
  me(func: anyofterms(name, &quot;Alice Bob Charlie&quot;)) {
    name
    rated @facets(orderdesc: rating) {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name&quot;: &quot;Bob&quot;,
        &quot;rated&quot;: [
          {
            &quot;name&quot;: &quot;Movie 1&quot;,
            &quot;rated|rating&quot;: 5
          },
          {
            &quot;name&quot;: &quot;Movie 2&quot;,
            &quot;rated|rating&quot;: 5
          },
          {
            &quot;name&quot;: &quot;Movie 3&quot;,
            &quot;rated|rating&quot;: 5
          }
        ]
      },
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;rated&quot;: [
          {
            &quot;name&quot;: &quot;Movie 3&quot;,
            &quot;rated|rating&quot;: 5
          },
          {
            &quot;name&quot;: &quot;Movie 1&quot;,
            &quot;rated|rating&quot;: 3
          },
          {
            &quot;name&quot;: &quot;Movie 2&quot;,
            &quot;rated|rating&quot;: 2
          }
        ]
      },
      {
        &quot;name&quot;: &quot;Charlie&quot;,
        &quot;rated&quot;: [
          {
            &quot;name&quot;: &quot;Movie 2&quot;,
            &quot;rated|rating&quot;: 5
          },
          {
            &quot;name&quot;: &quot;Movie 1&quot;,
            &quot;rated|rating&quot;: 2
          },
          {
            &quot;name&quot;: &quot;Movie 3&quot;,
            &quot;rated|rating&quot;: 1
          }
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="将facet值赋值给变量"><a class="header" href="#将facet值赋值给变量">将<code>Facet</code>值赋值给变量</a></h2>
<p><code>UID</code>边(edge)上的<code>facet</code>可以存储在值变量(variables)中。这个变量是从边(edge)目标到<code>facet</code>的映射。</p>
<p>找到<code>Alice</code>被标记为<code>close</code>和<code>relative</code>的朋友：</p>
<pre><code class="language-dql">{
  var(func: eq(name, &quot;Alice&quot;)) {
    friend @facets(a as close, b as relative)
  }

  friend(func: uid(a)) {
    name
    val(a)
  }

  relative(func: uid(b)) {
    name
    val(b)
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;friend&quot;: [
      {
        &quot;name&quot;: &quot;Bob&quot;,
        &quot;val(a)&quot;: true
      },
      {
        &quot;name&quot;: &quot;Charlie&quot;,
        &quot;val(a)&quot;: false
      },
      {
        &quot;name&quot;: &quot;Dave&quot;,
        &quot;val(a)&quot;: true
      }
    ],
    &quot;relative&quot;: [
      {
        &quot;name&quot;: &quot;Bob&quot;,
        &quot;val(b)&quot;: false
      },
      {
        &quot;name&quot;: &quot;Charlie&quot;,
        &quot;val(b)&quot;: true
      },
      {
        &quot;name&quot;: &quot;Dave&quot;,
        &quot;val(b)&quot;: true
      }
    ]
  }
}
</code></pre>
<h2 id="facet和值传播"><a class="header" href="#facet和值传播">Facet和值传播</a></h2>
<p>可以将<code>int</code>和<code>float</code>的<code>Facet</code>值赋给变量，从而使这些值(variables)传播。</p>
<p>爱丽丝、鲍勃和查理都给每部电影打分。<code>facet</code>评级上的值变量将电影映射到评级。通过多条路径到达电影的查询将对每条路径的评级进行求和。下面总结了爱丽丝、鲍勃和查理对这三部电影的评分：</p>
<pre><code class="language-dql">{
  var(func: anyofterms(name, &quot;Alice Bob Charlie&quot;)) {
    num_raters as math(1)
    rated @facets(r as rating) {
      total_rating as math(r) # sum of the 3 ratings
      average_rating as math(total_rating / num_raters)
    }
  }
  data(func: uid(total_rating)) {
    name
    val(total_rating)
    val(average_rating)
  }

}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Movie 1&quot;,
        &quot;val(total_rating)&quot;: 10,
        &quot;val(average_rating)&quot;: 3
      },
      {
        &quot;name&quot;: &quot;Movie 2&quot;,
        &quot;val(total_rating)&quot;: 12,
        &quot;val(average_rating)&quot;: 4
      },
      {
        &quot;name&quot;: &quot;Movie 3&quot;,
        &quot;val(total_rating)&quot;: 11,
        &quot;val(average_rating)&quot;: 3
      }
    ]
  }
}
</code></pre>
<h2 id="facet-和聚合aggregation"><a class="header" href="#facet-和聚合aggregation">Facet 和聚合(aggregation)</a></h2>
<p>可以聚合分配给值变量的Facet值。</p>
<pre><code class="language-dql">{
  data(func: eq(name, &quot;Alice&quot;)) {
    name
    rated @facets(r as rating) {
      name
    }
    avg(val(r))
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;rated&quot;: [
          {
            &quot;name&quot;: &quot;Movie 1&quot;,
            &quot;rated|rating&quot;: 3
          },
          {
            &quot;name&quot;: &quot;Movie 2&quot;,
            &quot;rated|rating&quot;: 2
          },
          {
            &quot;name&quot;: &quot;Movie 3&quot;,
            &quot;rated|rating&quot;: 5
          }
        ],
        &quot;avg(val(r))&quot;: 3.333333
      }
    ]
  }
}
</code></pre>
<p>但是请注意，<code>r</code>是一个从电影到查询中到达电影的边缘上的评分总和的映射。因此，下面的代码不能正确地分别计算<code>Alice</code>和<code>Bob</code>的平均评级————它计算的是<code>Alice</code>和<code>Bob</code>评级平均值的2倍。</p>
<pre><code class="language-dql">{
  data(func: anyofterms(name, &quot;Alice Bob&quot;)) {
    name
    rated @facets(r as rating) {
      name
    }
    avg(val(r))
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Bob&quot;,
        &quot;rated&quot;: [
          {
            &quot;name&quot;: &quot;Movie 1&quot;,
            &quot;rated|rating&quot;: 5
          },
          {
            &quot;name&quot;: &quot;Movie 2&quot;,
            &quot;rated|rating&quot;: 5
          },
          {
            &quot;name&quot;: &quot;Movie 3&quot;,
            &quot;rated|rating&quot;: 5
          }
        ],
        &quot;avg(val(r))&quot;: 8.333333
      },
      {
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;rated&quot;: [
          {
            &quot;name&quot;: &quot;Movie 1&quot;,
            &quot;rated|rating&quot;: 3
          },
          {
            &quot;name&quot;: &quot;Movie 2&quot;,
            &quot;rated|rating&quot;: 2
          },
          {
            &quot;name&quot;: &quot;Movie 3&quot;,
            &quot;rated|rating&quot;: 5
          }
        ],
        &quot;avg(val(r))&quot;: 8.333333
      }
    ]
  }
}
</code></pre>
<p>计算用户的平均评级需要一个将用户映射到其评级总和的变量：</p>
<pre><code class="language-dql">{
  var(func: has(rated)) {
    num_rated as math(1)
    rated @facets(r as rating) {
      avg_rating as math(r / num_rated)
    }
  }

  data(func: uid(avg_rating)) {
    name
    val(avg_rating)
  }
}

</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;name&quot;: &quot;Movie 1&quot;,
        &quot;val(avg_rating)&quot;: 3
      },
      {
        &quot;name&quot;: &quot;Movie 2&quot;,
        &quot;val(avg_rating)&quot;: 4
      },
      {
        &quot;name&quot;: &quot;Movie 3&quot;,
        &quot;val(avg_rating)&quot;: 3
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路径查询"><a class="header" href="#最短路径查询">最短路径查询</a></h1>
<p>通过查询块名称的关键字最短，可以找到源(<code>from</code>)节点和目的(<code>to</code>)节点之间的最短路径。它要求必须考虑遍历的源节点<code>UID</code>、目标节点<code>UID</code>和谓词(predicate)(至少一个)。最短查询块在查询响应中返回<code>_path_</code>下的最短路径。该路径也可以存储在其他查询块中使用的变量中。</p>
<h2 id="k-最短路径查询"><a class="header" href="#k-最短路径查询">K-最短路径查询</a></h2>
<p>默认情况下，返回的是最短路径。使用<code>numpaths</code>: <code>k</code>和<code>k &gt; 1</code>，返回<code>k</code>最短路径。从<code>k</code>最短路径查询的结果中删除循环路径。对于<code>depth: n</code>，返回深度为<code>n</code>的路径。</p>
<blockquote>
<p>请注意：</p>
<ul>
<li>如果在最短的块中没有指定谓词，则不会获取路径，因为没有遍历边界。</li>
<li>如果查询需要很长时间，可以设置一个gRPC截止日期，在一段时间后停止查询。</li>
</ul>
</blockquote>
<p>例如：</p>
<pre><code class="language-bash">curl localhost:8080/alter -XPOST -d $'
    name: string @index(exact) .
' | python -m json.tool | less
</code></pre>
<pre><code class="language-dql">{
  set {
    _:a &lt;friend&gt; _:b (weight=0.1) .
    _:b &lt;friend&gt; _:c (weight=0.2) .
    _:c &lt;friend&gt; _:d (weight=0.3) .
    _:a &lt;friend&gt; _:d (weight=1) .
    _:a &lt;name&gt; &quot;Alice&quot; .
    _:a &lt;dgraph.type&gt; &quot;Person&quot; .
    _:b &lt;name&gt; &quot;Bob&quot; .
    _:b &lt;dgraph.type&gt; &quot;Person&quot; .
    _:c &lt;name&gt; &quot;Tom&quot; .
    _:c &lt;dgraph.type&gt; &quot;Person&quot; .
    _:d &lt;name&gt; &quot;Mallory&quot; .
    _:d &lt;dgraph.type&gt; &quot;Person&quot; .
  }
}
</code></pre>
<p><code>Alice</code>和<code>Mallory</code>之间的最短路径(假设<code>uid</code>分别为<code>0x2</code>和<code>0x5</code>)可以通过下面的查询找到：</p>
<pre><code class="language-dql">{
 path as shortest(from: 0x2, to: 0x5) {
  friend
 }
 path(func: uid(path)) {
   name
 }
}
</code></pre>
<blockquote>
<p>注意，不考虑facet，每条边的权值为1</p>
</blockquote>
<p>上面的<code>DQL</code>将返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;path&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;
      },
      {
        &quot;name&quot;: &quot;Mallory&quot;
      }
    ],
    &quot;_path_&quot;: [
      {
        &quot;uid&quot;: &quot;0x2&quot;,
        &quot;friend&quot;: [
          {
            &quot;uid&quot;: &quot;0x5&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>通过指定<code>numpaths</code>，可以返回更多路径。设置<code>numpaths: 2</code>返回最短的两条路径：</p>
<pre><code class="language-dql">{

 A as var(func: eq(name, &quot;Alice&quot;))
 M as var(func: eq(name, &quot;Mallory&quot;))

 path as shortest(from: uid(A), to: uid(M), numpaths: 2) {
  friend
 }
 path(func: uid(path)) {
   name
 }
}
</code></pre>
<blockquote>
<p>注意，在上面的查询中，我们使用<code>var</code>块和<code>UID()</code>函数来查询人，而不是使用<code>UID</code>字面量。还可以将它与<code>GraphQL</code>变量结合使用。</p>
</blockquote>
<h2 id="边的权重"><a class="header" href="#边的权重">边的权重</a></h2>
<p><code>Dgraph</code>中的最短路径实现依赖于<code>facet</code>来提供权重。使用边(edge)上的facet可以让你定义如下的边(edge)的权重：</p>
<blockquote>
<p>注意：在最短的查询块中，每个谓词(predicate)只允许有一个facet。</p>
</blockquote>
<pre><code class="language-dql">{
 path as shortest(from: 0x2, to: 0x5) {
  friend @facets(weight)
 }

 path(func: uid(path)) {
  name
 }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;path&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;
      },
      {
        &quot;name&quot;: &quot;Bob&quot;
      },
      {
        &quot;name&quot;: &quot;Tom&quot;
      },
      {
        &quot;name&quot;: &quot;Mallory&quot;
      }
    ],
    &quot;_path_&quot;: [
      {
        &quot;uid&quot;: &quot;0x2&quot;,
        &quot;friend&quot;: [
          {
            &quot;uid&quot;: &quot;0x3&quot;,
            &quot;friend|weight&quot;: 0.1,
            &quot;friend&quot;: [
              {
                &quot;uid&quot;: &quot;0x4&quot;,
                &quot;friend|weight&quot;: 0.2,
                &quot;friend&quot;: [
                  {
                    &quot;uid&quot;: &quot;0x5&quot;,
                    &quot;friend|weight&quot;: 0.3
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
}
</code></pre>
<h3 id="遍历的例子"><a class="header" href="#遍历的例子">遍历的例子</a></h3>
<p>下面是一个图遍历的例子，它允许您找到使用<code>Car</code>或<code>Bus</code>的朋友之间的最短路径：</p>
<blockquote>
<p>每个关系的<code>Car</code>和<code>Bus</code>移动被建模为<code>facet</code>，并在最短的查询中指定</p>
</blockquote>
<pre><code class="language-dql">{
  set {
    _:a &lt;friend&gt; _:b (weightCar=10, weightBus=1 ) .
    _:b &lt;friend&gt; _:c (weightCar=20, weightBus=1) .
    _:c &lt;friend&gt; _:d (weightCar=11, weightBus=1.1) .
    _:a &lt;friend&gt; _:d (weightCar=70, weightBus=2) .
    _:a &lt;name&gt; &quot;Alice&quot; .
    _:a &lt;dgraph.type&gt; &quot;Person&quot; .
    _:b &lt;name&gt; &quot;Bob&quot; .
    _:b &lt;dgraph.type&gt; &quot;Person&quot; .
    _:c &lt;name&gt; &quot;Tom&quot; .
    _:c &lt;dgraph.type&gt; &quot;Person&quot; .
    _:d &lt;name&gt; &quot;Mallory&quot; .
    _:d &lt;dgraph.type&gt; &quot;Person&quot; .
  }
}
</code></pre>
<p>依赖<code>Car</code>和<code>Bus</code>查询最短路径：</p>
<pre><code class="language-dql">{

 A as var(func: eq(name, &quot;Alice&quot;))
 M as var(func: eq(name, &quot;Mallory&quot;))

 sPathBus as shortest(from: uid(A), to: uid(M)) {  
  friend
  @facets(weightBus)
 }

 sPathCar as shortest(from: uid(A), to: uid(M)) {  
  friend
  @facets(weightCar)
 }  
  
 pathBus(func: uid(sPathBus)) {
   name   
 }
  
 pathCar(func: uid(sPathCar)) {
   name   
 }
}
</code></pre>
<p>响应包含以下符合指定权重的路径：</p>
<pre><code class="language-json"> &quot;pathBus&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;
      },
      {
        &quot;name&quot;: &quot;Mallory&quot;
      }
    ],
    &quot;pathCar&quot;: [
      {
        &quot;name&quot;: &quot;Alice&quot;
      },
      {
        &quot;name&quot;: &quot;Bob&quot;
      },
      {
        &quot;name&quot;: &quot;Tom&quot;
      },
      {
        &quot;name&quot;: &quot;Mallory&quot;
      }
    ]
</code></pre>
<h2 id="约束"><a class="header" href="#约束">约束</a></h2>
<p>可以对中间节点应用如下约束：</p>
<pre><code class="language-dql">{
  path as shortest(from: 0x2, to: 0x5) {
    friend @filter(not eq(name, &quot;Bob&quot;)) @facets(weight)
    relative @facets(liking)
  }

  relationship(func: uid(path)) {
    name
  }
}
</code></pre>
<p>k最短路径算法(在<code>numpaths &gt; 1</code>时使用)也接受参数<code>minweight</code>和<code>maxweight</code>，它们的值为一个浮点数。当传递它们时，只有权重范围<code>[minweight, maxweight]</code>内的路径将被视为有效路径。例如，这可以用于查询在2到4个节点之间的最短路径：</p>
<pre><code class="language-dql">{
 path as shortest(from: 0x2, to: 0x5, numpaths: 2, minweight: 2, maxweight: 4) {
  friend
 }
 path(func: uid(path)) {
   name
 }
}
</code></pre>
<h2 id="笔记"><a class="header" href="#笔记">笔记</a></h2>
<p>对于最短路径查询，需要记住以下几点:</p>
<ul>
<li>权值必须是非负的。Dijkstra算法用于计算最短路径。</li>
<li>在最短的查询块中，每个谓词只允许有一个facet。</li>
<li>每个查询只允许一个最短路径块。结果中只返回一个_path_。对于numpaths &gt; 1的查询，_path_包含所有路径。</li>
<li>循环路径不包含在k最短路径查询结果中。</li>
<li>对于k条最短路径(当numpaths &gt;为1时)，最短路径查询变量的结果将只返回一条路径，这将是k条路径中的最短路径。所有k条路径都以_path_形式返回。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="递归查询"><a class="header" href="#递归查询">递归查询</a></h1>
<p>递归查询允许您遍历一组谓词(predicate)(使用过滤器、facet等)，直到我们到达所有叶子节点，或者到达由<code>depth</code>参数指定的最大深度。</p>
<p>要从一个拥有超过30000部电影的类型中获得10部电影，然后为这些电影找两个演员，我们会做如下事情：</p>
<pre><code class="language-dql">{
	me(func: gt(count(~genre), 30000), first: 1) @recurse(depth: 5, loop: true) {
		name@en
		~genre (first:10) @filter(gt(count(starring), 2))
		starring (first: 2)
		performance.actor
	}
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Documentary film&quot;,
        &quot;~genre&quot;: [
          {
            &quot;name@en&quot;: &quot;Casting Crowns: The Altar and the Door Live&quot;,
            &quot;starring&quot;: [
              {
                &quot;performance.actor&quot;: [
                  {
                    &quot;name@en&quot;: &quot;Megan Garrett&quot;
                  }
                ]
              },
              {
                &quot;performance.actor&quot;: [
                  {
                    &quot;name@en&quot;: &quot;Chris Huffman&quot;
                  }
                ]
              }
            ]
          },
          {
            &quot;name@en&quot;: &quot;Heavy Water: A Film for Chernobyl&quot;,
            &quot;starring&quot;: [
              {
                &quot;performance.actor&quot;: [
                  {
                    &quot;name@en&quot;: &quot;David Bickerstaff&quot;
                  }
                ]
              },
              {
                &quot;performance.actor&quot;: [
                  {
                    &quot;name@en&quot;: &quot;Phil Grabsky&quot;
                  }
                ]
              }
            ]
          }
          ...
        ]
      }
    ]
  }
}
</code></pre>
<p><strong>使用递归查询时需要记住的几点是:</strong></p>
<ul>
<li>您只能在root之后指定一个级别的谓词。它们将被递归地遍历。标量和实体节点的处理是相似的。</li>
<li>建议每个查询只使用一个递归块。</li>
<li>要小心，因为结果的大小可能会很快爆炸，如果结果集变得太大，就会返回一个错误。在这种情况下，使用更多的过滤器，使用分页限制结果，或在根处提供深度参数，如上面的示例所示。</li>
<li><code>loop</code>参数可以设置为<code>false</code>，在这种情况下，导致循环的路径将在遍历时被忽略。</li>
<li>如果未指定，则<code>loop</code>参数的值默认为<code>false</code>。</li>
<li>如果<code>loop</code>参数的值为<code>false</code>并且没有指定<code>depth</code>, <code>depth</code>将默认为<code>math</code>。maxxuint64，这意味着可能遍历整个图，直到到达所有叶节点。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fragement-片段"><a class="header" href="#fragement-片段">Fragement 片段</a></h1>
<p><code>fragment</code>关键字允许您根据<code>GraphQL</code>规范的<code>fragments</code>部分定义可以在查询中引用的新片段。片段允许重用常见的重复字段选择，从而减少DQL文档中的重复文本。片段可以嵌套在片段中，但在这种情况下不允许循环。例如：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/dql&quot; localhost:8080/query -XPOST -d $'
query {
  debug(func: uid(1)) {
    name@en
    ...TestFrag
  }
}
fragment TestFrag {
  initial_release_date
  ...TestFragB
}
fragment TestFragB {
  country
}' | python -m json.tool | less
</code></pre>
<blockquote>
<p>注意GraphQL+-已重命名为Dgraph查询语言(DQL)。虽然application/dql是Content-Type头的首选值，但我们将继续支持Content-Type: application/graphql+-，以避免进行破坏性的更改。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-变量-1"><a class="header" href="#graphql-变量-1">GraphQL 变量</a></h1>
<p>解析规则(使用默认值)：</p>
<ul>
<li><code>query title($name: string = &quot;Bauman&quot;) { ... }</code></li>
<li><code>query title($age: int = &quot;95&quot;) { ... }</code></li>
<li><code>query title($uids: string = &quot;0x1&quot;) { ... }</code></li>
<li><code>query title($uids: string = &quot;[0x1, 0x2, 0x3]&quot;) { ... }</code></li>
</ul>
<p>可以在查询中定义和使用变量，这有助于查询重用，并通过传递单独的变量映射，避免运行时在客户端中构建代价高昂的字符串。变量以$符号开头。对于带有GraphQL变量的HTTP请求，我们必须使用<code>Content-Type: application/json</code>头，并通过包含查询和变量的json对象传递数据：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; localhost:8080/query -XPOST -d $'{
  &quot;query&quot;: &quot;query test($a: string) { test(func: eq(name, $a)) { \n uid \n name \n } }&quot;,
  &quot;variables&quot;: { &quot;$a&quot;: &quot;Alice&quot; }
}' | python -m json.tool | less
</code></pre>
<pre><code class="language-dql">query test($a: int, $b: int, $name: string) {
  me(func: allofterms(name@en, $name)) {
    name@en
    director.film (first: $a, offset: $b) {
      name @en
      genre(first: $a) {
        name@en
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;,
        &quot;director.film&quot;: [
          {
            &quot;name@en&quot;: &quot;Close Encounters of the Third Kind&quot;,
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Science Fiction&quot;
              },
              {
                &quot;name@en&quot;: &quot;Adventure Film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Drama&quot;
              }
            ]
          }
          ...
        ]
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg And The Return To Film School&quot;
      },
      {
        &quot;name@en&quot;: &quot;Directors: Steven Spielberg&quot;
      },
      {
        &quot;name@en&quot;: &quot;Steven Spielberg&quot;
      }
      ...
    ]
  }
}
</code></pre>
<ul>
<li>变量可以有默认值。在下面的例子中，$a的默认值为2。因为变量映射中没有提供$a的值，所以$a采用默认值。</li>
<li>类型以!不能有默认值，但必须有一个值作为变量映射的一部分。</li>
<li>变量的值必须对给定的类型具有可解析性，如果不能，则抛出错误。</li>
<li>目前支持的变量类型有:int、float、bool和string。</li>
<li>任何正在使用的变量都必须在开头的命名查询子句中声明。</li>
</ul>
<pre><code class="language-dql">query test($a: int = 2, $b: int!, $name: string) {
  me(func: allofterms(name@en, $name)) {
    director.film (first: $a, offset: $b) {
      genre(first: $a) {
        name@en
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;director.film&quot;: [
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Science Fiction&quot;
              },
              {
                &quot;name@en&quot;: &quot;Adventure Film&quot;
              }
            ]
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Horror&quot;
              },
              {
                &quot;name@en&quot;: &quot;Science Fiction&quot;
              }
            ]
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>你也可以使用数组与GraphQL变量：</p>
<pre><code class="language-dql">query test($a: int = 2, $b: int!, $aName: string, $bName: string) {
  me(func: eq(name@en, [$aName, $bName])) {
    director.film (first: $a, offset: $b) {
      genre(first: $a) {
        name@en
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;me&quot;: [
      {
        &quot;director.film&quot;: [
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Indie film&quot;
              },
              {
                &quot;name@en&quot;: &quot;Thriller&quot;
              }
            ]
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Farce&quot;
              },
              {
                &quot;name@en&quot;: &quot;Comedy&quot;
              }
            ]
          }
        ]
      },
      {
        &quot;director.film&quot;: [
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Science Fiction&quot;
              },
              {
                &quot;name@en&quot;: &quot;Adventure Film&quot;
              }
            ]
          },
          {
            &quot;genre&quot;: [
              {
                &quot;name@en&quot;: &quot;Horror&quot;
              },
              {
                &quot;name@en&quot;: &quot;Science Fiction&quot;
              }
            ]
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>我们还支持facet变量替换：</p>
<pre><code class="language-dql">query test($name: string = &quot;Alice&quot;, $IsClose: string = &quot;true&quot;) {
  data(func: eq(name, $name)) {
    friend @facets(eq(close, $IsClose)) {
      name
    }
      colleague : friend @facets(eq(close, false)) {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;data&quot;: [
      {
        &quot;friend&quot;: [
          {
            &quot;name&quot;: &quot;Bob&quot;
          },
          {
            &quot;name&quot;: &quot;Dave&quot;
          }
        ],
        &quot;colleague&quot;: [
          {
            &quot;name&quot;: &quot;Charlie&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用自定义-tokenizer-进行索引"><a class="header" href="#使用自定义-tokenizer-进行索引">使用自定义 <code>tokenizer</code> 进行索引</a></h1>
<p><code>Dgraph</code>自带一个内置索引的大工具箱，但有时对于小众用例来说，它们总是不够用。</p>
<p>为了填补空白，<code>Dgraph</code>允许你通过插件系统实现定制的标记器。</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>插件系统使用<code>Go</code>的<a href="https://golang.org/pkg/plugin/">pkg/plugin</a>。这给插件的使用带来了一些限制。</p>
<ul>
<li>插件必须用<code>Go</code>编写。</li>
<li>从1.9开始，<code>pkg/plugin</code>只能在<code>Linux</code>上工作。因此，插件只能在部署在<code>Linux</code>环境中的<code>Dgraph</code>实例上工作。</li>
<li>用于编译插件的<code>Go</code>版本应该与用于编译<code>Dgraph</code>本身的<code>Go</code>版本相同。<code>Dgraph</code>总是使用最新版本的<code>Go</code>(你也应该如此!)</li>
</ul>
<h3 id="实现一个插件"><a class="header" href="#实现一个插件">实现一个插件</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三元组-triples"><a class="header" href="#三元组-triples">三元组 (triples)</a></h1>
<p>一个变更通过<code>set</code>关键字添加三元组<code>triples</code>：</p>
<pre><code class="language-dql">{
  set {
    # 在这里添加三元组
  }
}
</code></pre>
<p>这里的三元组是W3C标准<a href="https://www.w3.org/TR/n-quads/">RDF N-Quad</a>格式的三元组。</p>
<p>每个三元组都有这样的格式：</p>
<pre><code class="language-dql">&lt;subject&gt; &lt;predicate&gt; &lt;object&gt; .
</code></pre>
<p>上面的格式表明由<code>subject</code>标识的每一个节点(node)都通过一条有向边(predicate)连接到一个对象<code>object</code>实体。三元组的<code>subject</code>总是<code>graph</code>图数据库中的节点<code>node</code>，<code>object</code>可以是一个值，也可以是一个节点(node)(字面量)。</p>
<p>比如，下面这些三元组：</p>
<pre><code class="language-dql">&lt;0x01&gt; &lt;name&gt; &quot;Alice&quot; .
&lt;0x01&gt; &lt;dgraph.type&gt; &quot;Person&quot; .
</code></pre>
<p>表示图上<code>ID</code>为<code>0x01</code>的节点(node)有一个值为<code>Alice</code>的属性<code>name</code></p>
<p>然后下面这个三元组：</p>
<pre><code class="language-dql">&lt;0x01&gt; &lt;friend&gt; &lt;0x02&gt; .
</code></pre>
<p>表示<code>ID</code>为<code>0x01</code>的节点<code>node</code>通过<code>friend</code>这条边(<code>edge</code>)连接到<code>ID</code>为<code>0x02</code>的节点(<code>node</code>)</p>
<p><code>Dgraph</code>为变更中的每个空白节点创建一个惟一的64位标识符————节点的<code>UID</code>。变更可以包含一个空白节点作为<code>subject</code>或对象实体(<code>object</code>)的标识符(即是<code>UID</code>)，或者一个来自先前变更的已知<code>UID</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三元组-triples-1"><a class="header" href="#三元组-triples-1">三元组 (triples)</a></h1>
<p>一个变更通过<code>set</code>关键字添加三元组<code>triples</code>：</p>
<pre><code class="language-dql">{
  set {
    # 在这里添加三元组
  }
}
</code></pre>
<p>这里的三元组是W3C标准<a href="https://www.w3.org/TR/n-quads/">RDF N-Quad</a>格式的三元组。</p>
<p>每个三元组都有这样的格式：</p>
<pre><code class="language-dql">&lt;subject&gt; &lt;predicate&gt; &lt;object&gt; .
</code></pre>
<p>上面的格式表明由<code>subject</code>标识的每一个节点(node)都通过一条有向边(predicate)连接到一个对象<code>object</code>实体。三元组的<code>subject</code>总是<code>graph</code>图数据库中的节点<code>node</code>，<code>object</code>可以是一个值，也可以是一个节点(node)(字面量)。</p>
<p>比如，下面这些三元组：</p>
<pre><code class="language-dql">&lt;0x01&gt; &lt;name&gt; &quot;Alice&quot; .
&lt;0x01&gt; &lt;dgraph.type&gt; &quot;Person&quot; .
</code></pre>
<p>表示图上<code>ID</code>为<code>0x01</code>的节点(node)有一个值为<code>Alice</code>的属性<code>name</code></p>
<p>然后下面这个三元组：</p>
<pre><code class="language-dql">&lt;0x01&gt; &lt;friend&gt; &lt;0x02&gt; .
</code></pre>
<p>表示<code>ID</code>为<code>0x01</code>的节点<code>node</code>通过<code>friend</code>这条边(<code>edge</code>)连接到<code>ID</code>为<code>0x02</code>的节点(<code>node</code>)</p>
<p><code>Dgraph</code>为变更中的每个空白节点创建一个惟一的64位标识符————节点的<code>UID</code>。变更可以包含一个空白节点作为<code>subject</code>或对象实体(<code>object</code>)的标识符(即是<code>UID</code>)，或者一个来自先前变更的已知<code>UID</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="空白节点和uid"><a class="header" href="#空白节点和uid">空白节点和<code>UID</code></a></h1>
<p>变更中的空白节点(node)，写作<code>_:identifier</code>，用于标识变更中的节点。<code>Dgraph</code>为每一个空白节点创建一个<code>UID</code>以标识这个空白节点，并且在最后<code>Dgraph</code>会返回这些创建的<code>UID</code>集作为返回结果，例如，对于以下变更：</p>
<pre><code class="language-dql">{
 set {
    _:class &lt;student&gt; _:x .
    _:class &lt;student&gt; _:y .
    _:class &lt;name&gt; &quot;awesome class&quot; .
    _:class &lt;dgraph.type&gt; &quot;Class&quot; .
    _:x &lt;name&gt; &quot;Alice&quot; .
    _:x &lt;dgraph.type&gt; &quot;Person&quot; .
    _:x &lt;dgraph.type&gt; &quot;Student&quot; .
    _:x &lt;planet&gt; &quot;Mars&quot; .
    _:x &lt;friend&gt; _:y .
    _:y &lt;name&gt; &quot;Bob&quot; .
    _:y &lt;dgraph.type&gt; &quot;Person&quot; .
    _:y &lt;dgraph.type&gt; &quot;Student&quot; .
 }
}
</code></pre>
<p>返回结果(实际的<code>uid</code>在每次执行该变更时都是不同的)：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {
      &quot;class&quot;: &quot;0x2712&quot;,
      &quot;x&quot;: &quot;0x2713&quot;,
      &quot;y&quot;: &quot;0x2714&quot;
    }
  }
}
</code></pre>
<p>至此，数据库就像存储了三元组一样被更新了：</p>
<pre><code class="language-dql">&lt;0x6bc818dc89e78754&gt; &lt;student&gt; &lt;0xc3bcc578868b719d&gt; .
&lt;0x6bc818dc89e78754&gt; &lt;student&gt; &lt;0xb294fb8464357b0a&gt; .
&lt;0x6bc818dc89e78754&gt; &lt;name&gt; &quot;awesome class&quot; .
&lt;0x6bc818dc89e78754&gt; &lt;dgraph.type&gt; &quot;Class&quot; .
&lt;0xc3bcc578868b719d&gt; &lt;name&gt; &quot;Alice&quot; .
&lt;0xc3bcc578868b719d&gt; &lt;dgraph.type&gt; &quot;Person&quot; .
&lt;0xc3bcc578868b719d&gt; &lt;dgraph.type&gt; &quot;Student&quot; .
&lt;0xc3bcc578868b719d&gt; &lt;planet&gt; &quot;Mars&quot; .
&lt;0xc3bcc578868b719d&gt; &lt;friend&gt; &lt;0xb294fb8464357b0a&gt; .
&lt;0xb294fb8464357b0a&gt; &lt;name&gt; &quot;Bob&quot; .
&lt;0xb294fb8464357b0a&gt; &lt;dgraph.type&gt; &quot;Person&quot; .
&lt;0xb294fb8464357b0a&gt; &lt;dgraph.type&gt; &quot;Student&quot; .
</code></pre>
<p>空节点标签<code>_:class</code>、<code>_:x</code>和<code>_:y</code>不再标识变更成功后的节点，因此可以安全地重用它们来标识以后发生变更时的新节点。</p>
<p>以后的变化可以更新现有<code>uid</code>的数据。例如，下面将向<code>uid</code>为<code>0x6bc818dc89e78754</code>这个班级<code>class</code>中添加一个新学生：</p>
<pre><code class="language-dql">{
 set {
    &lt;0x6bc818dc89e78754&gt; &lt;student&gt; _:x .
    _:x &lt;name&gt; &quot;Chris&quot; .
    _:x &lt;dgraph.type&gt; &quot;Person&quot; .
    _:x &lt;dgraph.type&gt; &quot;Student&quot; .
 }
}
</code></pre>
<p>查询也可以直接使用UID：</p>
<pre><code class="language-dql">{
 class(func: uid(0x6bc818dc89e78754)) {
  name
  student {
   name
   planet
   friend {
    name
   }
  }
 }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用外部id"><a class="header" href="#使用外部id">使用外部ID</a></h1>
<p><code>Dgraph</code>的输入语言<code>RDF</code>也支持<code>&lt;a_fixed_identifier&gt; &lt;predicate&gt; </code>literal/node<code>的三元组及其变体，其中标签</code>a_fixed_identifier`是一个节点的唯一标识符。例如，混合使用<a href="http://schema.org/">schema.org</a>标识符、<a href="https://www.themoviedb.org/">电影数据库</a>标识符和空节点：</p>
<pre><code class="language-rdf">_:userA &lt;http://schema.org/type&gt; &lt;http://schema.org/Person&gt; .
_:userA &lt;dgraph.type&gt; &quot;Person&quot; .
_:userA &lt;http://schema.org/name&gt; &quot;FirstName LastName&quot; .
&lt;https://www.themoviedb.org/person/32-robin-wright&gt; &lt;http://schema.org/type&gt; &lt;http://schema.org/Person&gt; .
&lt;https://www.themoviedb.org/person/32-robin-wright&gt; &lt;http://schema.org/name&gt; &quot;Robin Wright&quot; .
</code></pre>
<p><code>Dgraph</code>原生不支持节点标识符这样的外部<code>id</code>，但外部<code>id</code>可以被存储为带有<code>xid</code>边的节点的属性。例如，在上面的例子中，谓词名称在<code>Dgraph</code>中是有效的，但是用<code>&lt;http: schema.org=&quot;&quot; person=&quot;&quot;&gt;</code>标识的节点可以用<code>UID(比如0x123)</code>和一条边在<code>Dgraph</code>中标识：</p>
<pre><code class="language-rdf">&lt;0x123&gt; &lt;xid&gt; &quot;http://schema.org/Person&quot; .
&lt;0x123&gt; &lt;dgraph.type&gt; &quot;ExternalType&quot; .
</code></pre>
<p>而<code>Robin Wright</code>可能获得的<code>UID</code>是<code>0x321</code>和三元组：</p>
<pre><code class="language-rdf">&lt;0x321&gt; &lt;xid&gt; &quot;https://www.themoviedb.org/person/32-robin-wright&quot; .
&lt;0x321&gt; &lt;http://schema.org/type&gt; &lt;0x123&gt; .
&lt;0x321&gt; &lt;http://schema.org/name&gt; &quot;Robin Wright&quot; .
&lt;0x321&gt; &lt;dgraph.type&gt; &quot;Person&quot; .
</code></pre>
<p>相应的<code>Schema</code>应该是下面这样子的：</p>
<pre><code class="language-schema">xid: string @index(exact) .
&lt;http://schema.org/type&gt;: [uid] @reverse .
</code></pre>
<p>查询所有人的例子：</p>
<pre><code class="language-dql">{
  var(func: eq(xid, &quot;http://schema.org/Person&quot;)) {
    allPeople as &lt;~http://schema.org/type&gt;
  }

  q(func: uid(allPeople)) {
    &lt;http://schema.org/name&gt;
  }
}
</code></pre>
<p>通过外部<code>ID</code>查询<code>Robin Wright</code>的例子：</p>
<pre><code class="language-dql">{
  robin(func: eq(xid, &quot;https://www.themoviedb.org/person/32-robin-wright&quot;)) {
    expand(_all_) { expand(_all_) }
  }
}

</code></pre>
<blockquote>
<p>注意：<code>xid</code>边不会在变更中自动添加。一般来说，用户应该自己管理<code>xid</code>，并在必要时添加节点和<code>xid</code>边。<code>Dgraph</code>将所有此类<code>xid</code>的唯一性检查留给外部程序。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部id和插入块-external-ids-and-upsert-block"><a class="header" href="#外部id和插入块-external-ids-and-upsert-block">外部ID和插入块 (External IDs and Upsert Block)</a></h1>
<p><code>upsert</code>块使得管理外部<code>id</code>很容易。</p>
<p>首先，设置如下<code>Schema</code>：</p>
<pre><code class="language-schema">xid: string @index(exact) .
&lt;http://schema.org/name&gt;: string @index(exact) .
&lt;http://schema.org/type&gt;: [uid] @reverse .
</code></pre>
<p>然后设置类型：</p>
<pre><code class="language-dql">{
  set {
    _:blank &lt;xid&gt; &quot;http://schema.org/Person&quot; .
    _:blank &lt;dgraph.type&gt; &quot;ExternalType&quot; .
  }
}
</code></pre>
<p>现在您可以创建一个新的<code>person</code>并使用<code>upsert</code>块添加其类型：</p>
<pre><code class="language-dql">upsert {
    query {
      var(func: eq(xid, &quot;http://schema.org/Person&quot;)) {
        Type as uid
      }
      var(func: eq(&lt;http://schema.org/name&gt;, &quot;Robin Wright&quot;)) {
        Person as uid
      }
    }
    mutation {
        set {
          uid(Person) &lt;xid&gt; &quot;https://www.themoviedb.org/person/32-robin-wright&quot; .
          uid(Person) &lt;http://schema.org/type&gt; uid(Type) .
          uid(Person) &lt;http://schema.org/name&gt; &quot;Robin Wright&quot; .
          uid(Person) &lt;dgraph.type&gt; &quot;Person&quot; .
        }
    }
  }
</code></pre>
<p>还可以删除<code>person</code>并分离<code>Type</code>和<code>person</code>节点之间的关系。这和上面是一样的，但是你使用了关键字<code>delete</code>而不是<code>set</code>。<code>http://schema.org/Person</code>将保留，但<code>Robin Wright</code>将被删除：</p>
<pre><code class="language-dql">upsert {
    query {
      var(func: eq(xid, &quot;http://schema.org/Person&quot;)) {
        Type as uid
      }
      var(func: eq(&lt;http://schema.org/name&gt;, &quot;Robin Wright&quot;)) {
        Person as uid
      }
    }
    mutation {
        delete {
          uid(Person) &lt;xid&gt; &quot;https://www.themoviedb.org/person/32-robin-wright&quot; .
          uid(Person) &lt;http://schema.org/type&gt; uid(Type) .
          uid(Person) &lt;http://schema.org/name&gt; &quot;Robin Wright&quot; .
          uid(Person) &lt;dgraph.type&gt; &quot;Person&quot; .
        }
    }
  }
</code></pre>
<p>再次查询一个用户：</p>
<pre><code class="language-dql">{
  q(func: eq(&lt;http://schema.org/name&gt;, &quot;Robin Wright&quot;)) {
    uid
    xid
    &lt;http://schema.org/name&gt;
    &lt;http://schema.org/type&gt; {
      uid
      xid
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语言和rdf类型-language-and-rdf-types"><a class="header" href="#语言和rdf类型-language-and-rdf-types">语言和RDF类型 (Language and RDF types)</a></h1>
<p><code>RDF N-Quad</code>允许为字符串值和<code>RDF</code>类型指定一种语言。语言是使用<code>@lang</code>指定的。例如：</p>
<pre><code class="language-rdf">&lt;0x01&gt; &lt;name&gt; &quot;Adelaide&quot;@en .
&lt;0x01&gt; &lt;name&gt; &quot;Аделаида&quot;@ru .
&lt;0x01&gt; &lt;name&gt; &quot;Adélaïde&quot;@fr .
&lt;0x01&gt; &lt;dgraph.type&gt; &quot;Person&quot; .
</code></pre>
<p>请参阅<a href="https://dgraph.io/docs/query-language/graphql-fundamentals/#language-support">如何在查询中处理语言字符串</a>。</p>
<p><code>RDF</code>类型通过标准的<code>^^</code>分隔符附加到字面量值上。例如：</p>
<pre><code class="language-rdf">&lt;0x01&gt; &lt;age&gt; &quot;32&quot;^^&lt;xs:int&gt; .
&lt;0x01&gt; &lt;birthdate&gt; &quot;1985-06-08&quot;^^&lt;xs:dateTime&gt; .
</code></pre>
<p>受支持的<code>RDF</code>数据类型和存储数据的相应内部类型如下所示：</p>
<table><thead><tr><th>存储类型</th><th><code>Dgraph</code>类型</th></tr></thead><tbody>
<tr><td>&lt;xs:string&gt;</td><td>string</td></tr>
<tr><td>&lt;xs:dateTime&gt;</td><td>dateTime</td></tr>
<tr><td>&lt;xs:date&gt;</td><td>dateTime</td></tr>
<tr><td>&lt;xs:int&gt;</td><td>int</td></tr>
<tr><td>&lt;xs:integer&gt;</td><td>int</td></tr>
<tr><td>&lt;xs:boolean&gt;</td><td>bool</td></tr>
<tr><td>&lt;xs:double&gt;</td><td>float</td></tr>
<tr><td>&lt;xs:float&gt;</td><td>float</td></tr>
<tr><td>&lt;geo:geojson&gt;</td><td>geo</td></tr>
<tr><td>&lt;xs:password&gt;</td><td>password</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#string&gt;</td><td>string</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;</td><td>dateTime</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#date&gt;</td><td>dateTime</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#int&gt;</td><td>int</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#positiveInteger&gt;</td><td>int</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</td><td>int</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;</td><td>bool</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#double&gt;</td><td>float</td></tr>
<tr><td>&lt;http://www.w3.org/2001/XMLSchema#float&gt;</td><td>float</td></tr>
</tbody></table>
<p>请参阅<a href="https://dgraph.io/docs/query-language/schema/#rdf-types">RDF Schema类型</a>一节，以了解RDF类型如何影响变更(mutation)和存储。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="批量变更-batch-mutations"><a class="header" href="#批量变更-batch-mutations">批量变更 (Batch Mutations)</a></h1>
<p>每个变更可以包含多个<code>RDF</code>三元组。对于大量的数据上传，许多这样的变更可以并行批处理。命令<code>dgraph live</code>就是这样做的；默认情况下，将1000个<code>RDF</code>行批处理到一个查询中，同时并行运行100个这样的查询。</p>
<p><code>dgraph live</code>以<code>gzip</code>的<code>N-Quad</code>文件(即不带<code>{set{</code>的三元组列表)作为输入，并为输入中的所有三元组批量处理变更。使用如下命令查看该工具的文档：</p>
<pre><code class="language-bash">dgraph live --help
</code></pre>
<blockquote>
<p>更多内容查看<a href="https://dgraph.io/docs/deploy/fast-data-loading/overview/">快速数据导入</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="删除-delete"><a class="header" href="#删除-delete">删除 (delete)</a></h1>
<p>由<code>delete</code>关键字标识的删除变更能从数据库中删除三元组。</p>
<p>例如，如果该数据库包含以下内容：</p>
<pre><code class="language-rdf">&lt;0xf11168064b01135b&gt; &lt;name&gt; &quot;Lewis Carrol&quot;
&lt;0xf11168064b01135b&gt; &lt;died&gt; &quot;1998&quot;
&lt;0xf11168064b01135b&gt; &lt;dgraph.type&gt; &quot;Person&quot; .
</code></pre>
<p>然后，下面的<code>delete</code>变更删除指定谓语(predicate)的错误数据，并将其从任何索引中删除：</p>
<pre><code class="language-dql">{
  delete {
    &lt;0xf11168064b01135b&gt; &lt;died&gt; &quot;1998&quot; .
  }
}
</code></pre>
<h2 id="通配符删除-wildcard-delete"><a class="header" href="#通配符删除-wildcard-delete">通配符删除 (Wildcard Delete)</a></h2>
<p>在许多情况下，你可能需要删除一个谓词(predicate)的多个数据。对于给定的节点<code>N</code>，谓词<code>P</code>的所有数据(以及所有对应的索引)都用模式<code>S P *</code>删除：</p>
<pre><code class="language-dql">{
  delete {
    &lt;0xf11168064b01135b&gt; &lt;author.of&gt; * .
  }
}
</code></pre>
<p>模式<code>S * *</code>删除节点中所有已知的边，与被删除的边对应的任何反向边，以及对被删除数据的任何索引：</p>
<blockquote>
<p>注意：对于符合<code>S * *</code>模式的变更，只删除与给定节点(使用<code>dgraph.type</code>)关联的类型中的谓词。任何不匹配节点类型之一的谓词将在<code>S * *</code>删除变更后保留。</p>
</blockquote>
<pre><code class="language-dql">{
  delete {
    &lt;0xf11168064b01135b&gt; * * .
  }
}
</code></pre>
<p>如果删除模式<code>S * *</code>中的节点<code>S</code>只有几条边带有<code>dgraph.type</code>定义，则只删除那些带有<code>dgraph.type</code>定义的三元组。包含非<code>dgraph.type</code>定义的边的节点在<code>S * *</code>删除变更之后仍然存在。</p>
<blockquote>
<p>注意，<code>* P O</code>和<code>* * O</code>的删除模式不受支持，因为存储和查找所有传入边的效率很低。</p>
</blockquote>
<h2 id="非列表边的删除-deletion-of-non-list-predicates"><a class="header" href="#非列表边的删除-deletion-of-non-list-predicates">非列表边的删除 (Deletion of non-list predicates)</a></h2>
<p>删除非列表谓词(即1对1关系)的值可以通过两种方式完成：</p>
<ul>
<li>使用上一节中提到的通配符删除(星号表示法)。</li>
<li>将对象设置为特定的值。如果传递的值不是当前值，则变更将成功，但不会产生任何影响。如果传递的值是当前值，则变更将成功，并将删除非列表谓词。</li>
</ul>
<p>对于被语言标记的值，支持以下特殊语法：</p>
<pre><code class="language-dql">{
  delete {
    &lt;0x12345&gt; &lt;name@es&gt; * .
  }
}
</code></pre>
<p>在本例中，使用语言标记<code>es</code>标记的<code>name</code>字段的值被删除，其他标记的值保持不变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rdf中的边属性-facet-lists-in-rdf"><a class="header" href="#rdf中的边属性-facet-lists-in-rdf">RDF中的边属性 (Facet Lists in RDF)</a></h1>
<p>Schema: </p>
<pre><code class="language-schema">&lt;name&gt;: string @index(exact).
&lt;nickname&gt;: [string] .
</code></pre>
<p>用RDF创建包含facet的列表非常简单：</p>
<pre><code class="language-dql">{
  set {
    _:Julian &lt;name&gt; &quot;Julian&quot; .
    _:Julian &lt;nickname&gt; &quot;Jay-Jay&quot; (kind=&quot;first&quot;) .
    _:Julian &lt;nickname&gt; &quot;Jules&quot; (kind=&quot;official&quot;) .
    _:Julian &lt;nickname&gt; &quot;JB&quot; (kind=&quot;CS-GO&quot;) .
  }
}
</code></pre>
<pre><code class="language-dql">{
  q(func: eq(name,&quot;Julian&quot;)){
    name
    nickname @facets
  }
}
</code></pre>
<p>返回：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [
      {
        &quot;name&quot;: &quot;Julian&quot;,
        &quot;nickname|kind&quot;: {
          &quot;0&quot;: &quot;first&quot;,
          &quot;1&quot;: &quot;official&quot;,
          &quot;2&quot;: &quot;CS-GO&quot;
        },
        &quot;nickname&quot;: [
          &quot;Jay-Jay&quot;,
          &quot;Jules&quot;,
          &quot;JB&quot;
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用curl提交变更-mutations-using-curl"><a class="header" href="#使用curl提交变更-mutations-using-curl">使用cURL提交变更 (Mutations Using cURL)</a></h1>
<p>变更可以通过向<code>Alpha</code>的<code>/mutate</code>发出<code>POST</code>请求来实现。在命令行上，这可以通过<code>curl</code>完成。在<code>URL</code>中传递参数<code>commitNow=true</code>表明你是要提交变更。</p>
<p>提交一个<code>set</code>变更：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
{
  set {
    _:alice &lt;name&gt; &quot;Alice&quot; .
    _:alice &lt;dgraph.type&gt; &quot;Person&quot; .
  }
}'
</code></pre>
<p>提交一个<code>delete</code>变更：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
{
  delete {
    # Example: The UID of Alice is 0x56f33
    &lt;0x56f33&gt; &lt;name&gt; * .
  }
}'
</code></pre>
<p>提交一个存储在文件中的变更，使用<code>--data-binary</code>选项将不会对文件数据编码：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true --data-binary @mutation.txt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-变更格式-json-mutation-format"><a class="header" href="#json-变更格式-json-mutation-format">JSON 变更格式 (JSON Mutation Format)</a></h1>
<p>你也能够通过<code>JSON</code>对象指定一个变更。这可以让变更以更自然的方式表达出来。它还消除了应用程序自定义序列化代码的需要，因为大多数语言已经有了<code>JSON</code>处理库。</p>
<p>当<code>Dgraph</code>接收到<code>JSON</code>对象的变更时，它首先将其转换为内部边格式，然后再将其处理为<code>Dgraph</code>。</p>
<p><strong>对于<code>JSON</code>：</strong></p>
<p>JSON -&gt; Edges -&gt; Posting list</p>
<p><strong>对于<code>RDF</code>：</strong></p>
<p>RDF -&gt; Edges -&gt; Posting list</p>
<p>每个JSON对象表示图中的单个节点。</p>
<blockquote>
<p>注意：<code>JSON</code>变更可以通过<code>Go</code>客户端、<code>JavaScript</code>客户端和<code>Java</code>客户端等<code>gRPC</code>客户端使用，也可以通过<code>dgraph-js-http</code>和<code>cURL</code>对<code>HTTP</code>客户端使用。在<a href="https://dgraph.io/docs/mutations/json-mutation-format/#using-json-operations-via-curl">这里</a>可以看到更多关于<code>cURL</code>的信息。</p>
</blockquote>
<h2 id="设置字面量值"><a class="header" href="#设置字面量值">设置字面量值</a></h2>
<p>当设置新值时，变更消息中的<code>set_json</code>字段应该包含一个<code>JSON</code>对象。</p>
<p>字面量值可以直接通过向<code>JSON</code>对象设置<code>key/value</code>来进行。<code>key</code>将表示谓词(predicate)，<code>value</code>将表示对象。</p>
<p>例如：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;diggy&quot;,
  &quot;food&quot;: &quot;pizza&quot;,
  &quot;dgraph.type&quot;: &quot;Mascot&quot;
}
</code></pre>
<p>上面<code>JSON</code>对象将被转化为如下<code>RDF</code>：</p>
<pre><code class="language-rdf">_:blank-0 &lt;name&gt; &quot;diggy&quot; .
_:blank-0 &lt;food&gt; &quot;pizza&quot; .
_:blank-0 &lt;dgraph.type&gt; &quot;Mascot&quot; .
</code></pre>
<p>变更的返回结果是一个<code>Map</code>，该<code>Map</code>具有一个<code>uid</code>，这个<code>uid</code>对应于键<code>blank-0</code>。你也可以像下面这样指定你自己的<code>uid</code>键：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;_:diggy&quot;,
  &quot;name&quot;: &quot;diggy&quot;,
  &quot;food&quot;: &quot;pizza&quot;,
  &quot;dgraph.type&quot;: &quot;Mascot&quot;
}
</code></pre>
<p>在这种情况下，分配的<code>uid</code>映射将有一个名为<code>diggy</code>的键，其值是分配给它的<code>uid</code>。</p>
<h3 id="禁止值-forbidden-values"><a class="header" href="#禁止值-forbidden-values">禁止值 (Forbidden values)</a></h3>
<blockquote>
<p>使用<code>JSON</code>提交变更时，<code>uid()</code> 和 <code>val()</code> 这两个字符串是不允许使用的。</p>
</blockquote>
<p>例如：<code>Dgraph</code>不能处理以下提交的变更：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;uid(t)&quot;,
  &quot;user_name&quot;: &quot;uid(s ia)&quot;,
  &quot;name&quot;: &quot;val (s kl)&quot;,
}
</code></pre>
<h2 id="多语言支持-language-support"><a class="header" href="#多语言支持-language-support">多语言支持 (Language Support)</a></h2>
<p><code>RDF</code>变更和<code>JSON</code>变更之间的一个重要区别在于指定字符串值的语言。在<code>JSON</code>中，语言标记被附加到边名，而不是像<code>RDF</code>那样的值。</p>
<p>例如，下面是一个使用<code>JSON</code>提交的变更：</p>
<pre><code class="language-json">{
  &quot;food&quot;: &quot;taco&quot;,
  &quot;rating@en&quot;: &quot;tastes good&quot;,
  &quot;rating@es&quot;: &quot;sabe bien&quot;,
  &quot;rating@fr&quot;: &quot;c'est bon&quot;,
  &quot;rating@it&quot;: &quot;è buono&quot;,
  &quot;dgraph.type&quot;: &quot;Food&quot;
}
</code></pre>
<p>作为对比，使用<code>RDF</code>提交相同的变更需要：</p>
<pre><code class="language-rdf">_:blank-0 &lt;food&gt; &quot;taco&quot; .
_:blank-0 &lt;dgraph.type&gt; &quot;Food&quot; .
_:blank-0 &lt;rating&gt; &quot;tastes good&quot;@en .
_:blank-0 &lt;rating&gt; &quot;sabe bien&quot;@es .
_:blank-0 &lt;rating&gt; &quot;c'est bon&quot;@fr .
_:blank-0 &lt;rating&gt; &quot;è buono&quot;@it .
</code></pre>
<h2 id="地理位置支持-geolocation-support"><a class="header" href="#地理位置支持-geolocation-support">地理位置支持 (Geolocation support)</a></h2>
<p><code>JSON</code>变更支持地理位置数据。地理位置数据以<code>JSON</code>对象的形式输入，带有<code>type</code>和<code>coordinates</code>键。记住，我们只支持在<code>Point</code>、<code>Polygon</code>和<code>MultiPolygon</code>类型上建立索引，但是我们可以存储其他类型的地理位置数据。下面是一个例子：</p>
<pre><code class="language-json">{
  &quot;food&quot;: &quot;taco&quot;,
  &quot;location&quot;: {
    &quot;type&quot;: &quot;Point&quot;,
    &quot;coordinates&quot;: [1.0, 2.0]
  }
}
</code></pre>
<h2 id="引用已存在的节点-referencing-existing-nodes"><a class="header" href="#引用已存在的节点-referencing-existing-nodes">引用已存在的节点 (Referencing existing nodes)</a></h2>
<p>如果<code>JSON</code>对象包含一个名为<code>uid</code>的字段，那么该字段将被解释为图中现有节点的<code>uid</code>。这种机制允许您引用现有的节点。</p>
<p>例如：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;0x467ba0&quot;,
  &quot;food&quot;: &quot;taco&quot;,
  &quot;rating&quot;: &quot;tastes good&quot;,
  &quot;dgraph.type&quot;: &quot;Food&quot;
}
</code></pre>
<p>上面的<code>JSON</code>对象将被转化为以下<code>RDF</code>：</p>
<pre><code class="language-rdf">&lt;0x467ba0&gt; &lt;food&gt; &quot;taco&quot; .
&lt;0x467ba0&gt; &lt;rating&gt; &quot;tastes good&quot; .
&lt;0x467ba0&gt; &lt;dgraph.type&gt; &quot;Food&quot; .
</code></pre>
<h2 id="节点之间的边-edges-between-nodes"><a class="header" href="#节点之间的边-edges-between-nodes">节点之间的边 (Edges between nodes)</a></h2>
<p>节点之间的边以类似于字面量值的方式表示，只是对象是一个<code>JSON</code>对象：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Alice&quot;,
  &quot;friend&quot;: {
    &quot;name&quot;: &quot;Betty&quot;
  }
}
</code></pre>
<p>上面的<code>JSON</code>对象将会被转化为：</p>
<pre><code class="language-rdf">_:blank-0 &lt;name&gt; &quot;Alice&quot; .
_:blank-0 &lt;friend&gt; _:blank-1 .
_:blank-1 &lt;name&gt; &quot;Betty&quot; .
</code></pre>
<p>变更的结果将包含分配给<code>blank-0</code>和<code>blank-1</code>节点的<code>uid</code>。如果您想在不同的键下返回这些<code>uid</code>，您可以将<code>uid</code>字段指定为一个空白节点：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;_:alice&quot;,
  &quot;name&quot;: &quot;Alice&quot;,
  &quot;friend&quot;: {
    &quot;uid&quot;: &quot;_:bob&quot;,
    &quot;name&quot;: &quot;Betty&quot;
  }
}
</code></pre>
<p>上面的<code>JSON</code>对象将会被转化为：</p>
<pre><code class="language-rdf">_:alice &lt;name&gt; &quot;Alice&quot; .
_:alice &lt;friend&gt; _:bob .
_:bob &lt;name&gt; &quot;Betty&quot; .
</code></pre>
<p>可以使用与添加字面量值相同的方式引用现有节点。例如连接两个现有节点：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;0x123&quot;,
  &quot;link&quot;: {
    &quot;uid&quot;: &quot;0x456&quot;
  }
}
</code></pre>
<p>将会被转化为：</p>
<pre><code class="language-rdf">&lt;0x123&gt; &lt;link&gt; &lt;0x456&gt; .
</code></pre>
<blockquote>
<p>注意：一个常见的错误是尝试使用<code>{&quot;uid&quot;:&quot;0x123&quot;，&quot;link&quot;:&quot;0x456&quot;}</code>。这将导致一个错误：<code>Dgraph</code>将这个<code>JSON</code>对象解释为将链接谓词设置为字符串<code>0x456</code>，这通常不是你希望的。</p>
</blockquote>
<h2 id="删除字面量值-deleting-literal-values"><a class="header" href="#删除字面量值-deleting-literal-values">删除字面量值 (Deleting literal values)</a></h2>
<p><code>JSON</code>也能提交删除变更。</p>
<p>要发送删除变更，在变更消息中使用<code>delete_json</code>字段而不是<code>set_json</code>字段。</p>
<blockquote>
<p>注意：如果您使用<code>dgraph-js-http</code>客户端或<code>Ratel UI</code>，请检查<code>JSON</code>语法使用原始<code>HTTP</code>或<code>Ratel UI</code>部分。</p>
</blockquote>
<p>在使用删除变更时，始终必须引用现有节点。因此，必须提供每个<code>JSON</code>对象的<code>uid</code>字段。应该删除的谓词应该设置为<code>JSON</code>值<code>null</code>。</p>
<p>例如，要删除食物评级：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;0x467ba0&quot;,
  &quot;rating&quot;: null
}
</code></pre>
<h2 id="删除边"><a class="header" href="#删除边">删除边</a></h2>
<p>删除一条边需要创建该边的相同<code>JSON</code>对象。例如，删除谓词链接<code>0x123</code>到<code>0x456</code>：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;0x123&quot;,
  &quot;link&quot;: {
    &quot;uid&quot;: &quot;0x456&quot;
  }
}
</code></pre>
<p>从单个节点发出的谓词(predicate)的所有边都可以一次删除(相当于删除<code>S P *</code>)：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;0x123&quot;,
  &quot;link&quot;: null
}
</code></pre>
<p>如果没有指定谓词，则删除节点的所有已知出站边(到其他节点和到字面量值)(对应于删除<code>S * *</code>)。要删除的谓词是使用类型系统派生的。有关更多信息，请参阅<a href="https://dgraph.io/docs/mutations/delete/">RDF格式文档</a>和<a href="https://dgraph.io/docs/query-language/type-system/">类型系统</a>部分：</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;0x123&quot;
}
</code></pre>
<h2 id="facets"><a class="header" href="#facets">Facets</a></h2>
<p>可以通过使用<code>|</code>字符来分隔<code>JSON</code>对象字段名中的谓词和<code>facet</code>键来创建<code>facet</code>。这与用于在查询结果中显示<code>facet</code>的编码模式相同。如：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Carol&quot;,
  &quot;name|initial&quot;: &quot;C&quot;,
  &quot;dgraph.type&quot;: &quot;Person&quot;,
  &quot;friend&quot;: {
    &quot;name&quot;: &quot;Daryl&quot;,
    &quot;friend|close&quot;: &quot;yes&quot;,
    &quot;dgraph.type&quot;: &quot;Person&quot;
  }
}
</code></pre>
<p>等价于下面的<code>RDF</code>：</p>
<pre><code class="language-rdf">_:blank-0 &lt;name&gt; &quot;Carol&quot; (initial=&quot;C&quot;) .
_:blank-0 &lt;dgraph.type&gt; &quot;Person&quot; .
_:blank-0 &lt;friend&gt; _:blank-1 (close=&quot;yes&quot;) .
_:blank-1 &lt;name&gt; &quot;Daryl&quot; .
_:blank-1 &lt;dgraph.type&gt; &quot;Person&quot; .
</code></pre>
<p><code>facet</code>不包含类型信息，但是<code>Dgraph</code>将尝试从输入猜测类型。如果一个<code>facet</code>的值可以被解析为一个数字，那么它将被转换为<code>float</code>或<code>int</code>。如果它可以被解析为一个布尔值，那么它将被存储为一个布尔值。如果值是字符串，如果该字符串与<code>Dgraph</code>能识别的时间格式(<code>YYYY</code>, <code>MM-YYYY</code>, <code>DD-MM-YYYY</code>, <code>RFC339</code>等)中的一种相匹配，那么它将被存储为<code>datetime</code>，否则将被存储为双引号字符串。如果不想冒<code>facet</code>数据被误读为时间值的风险，最好将数值数据存储为<code>int</code>或<code>float</code>类型。</p>
<h2 id="删除-facets"><a class="header" href="#删除-facets">删除 Facets</a></h2>
<p>删除<code>Facet</code>最简单的方法是覆盖它。当您为没有<code>facet</code>的相同实体创建一个新的变更时，现有的<code>facet</code>将被自动删除：</p>
<pre><code class="language-rdf">&lt;0x1&gt; &lt;name&gt; &quot;Carol&quot; .
&lt;0x1&gt; &lt;friend&gt; &lt;0x2&gt; .
</code></pre>
<p>另一种方法是使用<code>Upsert Block</code>。</p>
<p>在下面的查询中，我们将删除<code>Name</code>和<code>Friend</code>谓词中的<code>Facet</code>。要覆盖，我们需要收集执行此操作的边的值，并使用<code>val(var)</code>函数来完成覆盖：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
upsert {
  query {
    user as var(func: eq(name, &quot;Carol&quot;)){
      Name as name
      Friends as friend
    }
  }

  mutation {
    set {
      uid(user) &lt;name&gt; val(Name) .
      uid(user) &lt;friend&gt; uid(Friends) .
    }
  }
}' | jq
</code></pre>
<h2 id="使用-json创建一个list然后对这个list操作"><a class="header" href="#使用-json创建一个list然后对这个list操作">使用 <code>JSON</code>创建一个<code>List</code>然后对这个<code>List</code>操作：</a></h2>
<p>Schema:</p>
<pre><code class="language-schema">testList: [string] .
</code></pre>
<p>在<code>testList</code>中添加一些数据：</p>
<pre><code class="language-json">{
  &quot;testList&quot;: [
    &quot;Grape&quot;,
    &quot;Apple&quot;,
    &quot;Strawberry&quot;,
    &quot;Banana&quot;,
    &quot;watermelon&quot;
  ]
}
</code></pre>
<p>现在让我们把<code>Apple</code>从这个列表中删除(注意，<code>List</code>中的项是区分大小写的)：</p>
<pre><code class="language-dql">{
  q(func: has(testList)) {
    uid
    testList
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;delete&quot;: {
    &quot;uid&quot;: &quot;0x6&quot;, #UID of the list.
    &quot;testList&quot;: &quot;Apple&quot;
  }
}
</code></pre>
<p>当然，你也能够一次性删除多个值：</p>
<pre><code class="language-json">{
  &quot;delete&quot;: {
    &quot;uid&quot;: &quot;0x6&quot;,
    &quot;testList&quot;: [
      &quot;Strawberry&quot;,
      &quot;Banana&quot;,
      &quot;watermelon&quot;
    ]
  }
}
</code></pre>
<blockquote>
<p>注意：如果您使用<code>dgraph-js-http</code>客户端或<code>Ratel UI</code>，请检查<code>JSON</code>语法使用原始<code>HTTP</code>或<code>Ratel UI</code>部分。</p>
</blockquote>
<p>添加一个水果：</p>
<pre><code class="language-json">{
   &quot;uid&quot;: &quot;0x6&quot;, #UID of the list.
   &quot;testList&quot;: &quot;Pineapple&quot;
}
</code></pre>
<h2 id="json-与-list-类型的-facet"><a class="header" href="#json-与-list-类型的-facet">JSON 与 List 类型的 facet</a></h2>
<p>schema: </p>
<pre><code class="language-rdf">&lt;name&gt;: string @index(exact).
&lt;nickname&gt;: [string] .
</code></pre>
<p>要创建<code>list</code>类型的谓词(predicate)，需要指定单个列表中的所有值。所有谓词值的<code>facet</code>应该一起指定。它是用<code>map</code>格式完成的，列表中的谓词值的索引是<code>map</code>键，它们各自的<code>facet</code>值是<code>map</code>值。不包含<code>facet</code>值的谓词值将从<code>facet</code>映射中丢失。如：</p>
<pre><code class="language-json">{
  &quot;set&quot;: [
    {
      &quot;uid&quot;: &quot;_:Julian&quot;,
      &quot;name&quot;: &quot;Julian&quot;,
      &quot;nickname&quot;: [&quot;Jay-Jay&quot;, &quot;Jules&quot;, &quot;JB&quot;],
      &quot;nickname|kind&quot;: {
        &quot;0&quot;: &quot;first&quot;,
        &quot;1&quot;: &quot;official&quot;,
        &quot;2&quot;: &quot;CS-GO&quot;
      }
    }
  ]
}
</code></pre>
<p>在上面您可以看到，我们有三个值，它们各自具有方面，可以进入列表。你可以运行这个查询来检查包含<code>facet</code>的列表：</p>
<pre><code class="language-dql">{
  q(func: eq(name,&quot;Julian&quot;)) {
  uid
  nickname @facets
  }
}
</code></pre>
<p>之后如果希望使用<code>facet</code>添加更多值，只需执行相同的过程，但现在必须使用相应节点的<code>UID</code>，而不是使用空白节点：</p>
<pre><code class="language-json">{
  &quot;set&quot;: [
    {
      &quot;uid&quot;: &quot;0x3&quot;,
      &quot;nickname|kind&quot;: &quot;Internet&quot;,
      &quot;nickname&quot;: &quot;@JJ&quot;
    }
  ]
}
</code></pre>
<p>最后返回的结果：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [
      {
        &quot;uid&quot;: &quot;0x3&quot;,
        &quot;nickname|kind&quot;: {
          &quot;0&quot;: &quot;first&quot;,
          &quot;1&quot;: &quot;Internet&quot;,
          &quot;2&quot;: &quot;official&quot;,
          &quot;3&quot;: &quot;CS-GO&quot;
        },
        &quot;nickname&quot;: [
          &quot;Jay-Jay&quot;,
          &quot;@JJ&quot;,
          &quot;Jules&quot;,
          &quot;JB&quot;
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="指定多个操作"><a class="header" href="#指定多个操作">指定多个操作</a></h2>
<p>当指定添加或删除变更时，可以使用<code>JSON</code>数组同时指定多个节点。</p>
<p>例如，下面的<code>JSON</code>对象可以用来添加两个新节点，每个节点都有一个名称：</p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;Edward&quot;
  },
  {
    &quot;name&quot;: &quot;Fredric&quot;
  }
]
</code></pre>
<h2 id="使用-raw-http-或-ratel-ui-解析-json"><a class="header" href="#使用-raw-http-或-ratel-ui-解析-json">使用 <code>Raw HTTP</code> 或 <code>Ratel UI</code> 解析 <code>JSON</code></a></h2>
<p>这种语法可以在最新版本的<code>Ratel</code>中使用，也可以在<code>dgraph-js-http</code>客户端中使用，甚至可以通过<code>cURL</code>使用。</p>
<p>您也可以下载<code>Ratel UI</code>。</p>
<p>变更：</p>
<pre><code class="language-dql">{
  &quot;set&quot;: [
    {
      # One JSON obj in here
    },
    {
      # Another JSON obj in here for multiple operations
    }
  ]
}
</code></pre>
<p>删除：
删除操作与删除字面量值和删除边相同。</p>
<pre><code class="language-dql">{
  &quot;delete&quot;: [
    {
      # One JSON obj in here
    },
    {
      # Another JSON obj in here for multiple operations
    }
  ]
}
</code></pre>
<h2 id="通过-curl-使用-json-操作"><a class="header" href="#通过-curl-使用-json-操作">通过 <code>cURL</code> 使用 <code>JSON</code> 操作</a></h2>
<p>首先，你需要设置 <code>HTTP</code> 相应的请求头为 <code>application/json</code></p>
<pre><code class="language-bash">-H 'Content-Type: application/json'
</code></pre>
<blockquote>
<p>注意：为了使用<code>jq</code>进行<code>JSON</code>格式化，你需要<code>jq</code>包。有关安装细节，请参阅jq下载页面。你也可以使用<code>Python</code>的内置<code>json</code>工具模块，使用<code>python -m json</code>。</p>
</blockquote>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
    {
      &quot;set&quot;: [
        {
          &quot;name&quot;: &quot;Alice&quot;
        },
        {
          &quot;name&quot;: &quot;Bob&quot;
        }
      ]
    }' | jq

</code></pre>
<p>删除操作：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
    {
      &quot;delete&quot;: [
        {
          &quot;uid&quot;: &quot;0xa&quot;
        }
      ]
    }' | jq
</code></pre>
<p>或者你也可以提交一个在文件中的变更：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d @data.json
</code></pre>
<p><code>data.json</code> 中文件内容类似于：</p>
<pre><code class="language-json">{
  &quot;set&quot;: [
    {
      &quot;name&quot;: &quot;Alice&quot;
    },
    {
      &quot;name&quot;: &quot;Bob&quot;
    }
  ]
}
</code></pre>
<p>对于<code>HTTP</code>上的变更，<code>JSON</code>文件必须遵循相同的格式：一个带有<code>set</code>或<code>delete</code>键的<code>JSON</code>对象和一个用于变更的<code>JSON</code>对象数组。如果您已经拥有一个包含数据数组的文件，则可以使用<code>jq</code>将数据转换为适当的格式。例如，如果你的<code>Json</code>文件看起来像这样：</p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;Alice&quot;
  },
  {
    &quot;name&quot;: &quot;Bob&quot;
  }
]
</code></pre>
<p>然后可以使用以下<code>jq</code>命令将数据转换为适当的格式，其中<code>.</code>在<code>jq '{set: .}'</code>中表示<code>data.json</code>的内容：</p>
<pre><code class="language-bash">cat data.json | jq '{set: .}'
</code></pre>
<pre><code class="language-json">{
  &quot;set&quot;: [
    {
      &quot;name&quot;: &quot;Alice&quot;
    },
    {
      &quot;name&quot;: &quot;Bob&quot;
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插入块-upsert-block"><a class="header" href="#插入块-upsert-block">插入块 (Upsert Block)</a></h1>
<p><code>upsert</code>块允许在单个请求中执行查询和变更。<code>upsert</code>块包含一个查询块和一个或多个变更块。在查询块中定义的变量可以使用<code>uid</code>和<code>val</code>函数在变更块中使用。</p>
<p>一般情况下，<code>Upsert Block</code>的结构如下：</p>
<pre><code class="language-dql">upsert {
  query &lt;query block&gt;
  [fragment &lt;fragment block&gt;]
  mutation &lt;mutation block 1&gt;
  [mutation &lt;mutation block 2&gt;]
  ...
}
</code></pre>
<p><code>upsert</code>块的执行还返回在执行变更之前对数据库状态执行的查询的响应。为了获得最新的结果，我们应该提交变更并执行另一个查询。</p>
<h3 id="uid-函数"><a class="header" href="#uid-函数"><code>uid</code> 函数</a></h3>
<p><code>uid</code>函数允许从查询块中定义的变量中提取<code>uid</code>。根据查询块的执行结果，有两种可能的结果：</p>
<ul>
<li>如果变量是空的，即没有节点匹配查询，<code>uid</code>函数返回一个新的<code>uid</code>，在<code>set</code>操作的情况下，因此被视为类似于一个空节点。另一方面，对于<code>delete/del</code>操作，它不返回<code>UID</code>，因此该操作成为<code>no-op</code>，并被静默地忽略。空节点在所有变更块中获得相同的<code>UID</code>。</li>
<li>如果变量存储一个或多个<code>uid</code>, <code>uid</code>函数将返回存储在变量中的所有<code>uid</code>。在这种情况下，将对返回的所有<code>uid</code>执行操作，一次一个。</li>
</ul>
<h3 id="val-函数"><a class="header" href="#val-函数"><code>val</code> 函数</a></h3>
<p><code>val</code>函数允许从值变量中提取值。值变量存储<code>uid</code>到对应值的映射。因此，<code>val(v)</code>被存储在<code>N-Quad</code>中<code>UID (Subject)</code>映射中的值所替换。如果变量<code>v</code>没有给定<code>UID</code>的值，那么这种变更将被静默地忽略。<code>val</code>函数也可以用于聚合变量的结果，在这种情况下，变更中的所有<code>uid</code>都将用聚合值更新。</p>
<h2 id="uid-函数的使用例子"><a class="header" href="#uid-函数的使用例子"><code>uid</code> 函数的使用例子</a></h2>
<p>考虑拥有下面<code>Schema</code>的例子：</p>
<pre><code class="language-bash">curl localhost:8080/alter -X POST -d $'
  name: string @index(term) .
  email: string @index(exact, trigram) @upsert .
  age: int @index(int) .' | jq
</code></pre>
<p>现在，假设我们想要创建一个具有<code>email</code>和<code>name</code>的<code>user</code>。我们还希望确保一个电子邮件在数据库中恰好有一个对应的用户。为了实现这一点，我们首先需要用给定的电子邮件查询数据库中是否存在用户。如果用户存在，则使用其<code>UID</code>更新<code>name</code>信息。如果用户不存在，我们将创建一个新用户并更新电子邮件和名称信息。</p>
<p>我们能够用下面的<code>upsert block</code>块达成上面的需求：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
upsert {
  query {
    q(func: eq(email, &quot;user@company1.io&quot;)) {
      v as uid
      name
    }
  }

  mutation {
    set {
      uid(v) &lt;name&gt; &quot;first last&quot; .
      uid(v) &lt;email&gt; &quot;user@company1.io&quot; .
    }
  }
}' | jq
</code></pre>
<p>返回结果：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [],
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {
      &quot;uid(v)&quot;: &quot;0x1&quot;
    }
  },
  &quot;extensions&quot;: {...}
}
</code></pre>
<p><code>upsert</code>块的查询部分将用户的<code>UID</code>和提供的电子邮件存储在变量<code>v</code>中。变更部分从变量<code>v</code>中提取<code>UID</code>，并将名称和电子邮件信息存储在数据库中。如果用户存在，则更新。如果用户不存在，<code>uid(v)</code>将被视为一个空白节点，并创建一个新用户，如上所述。</p>
<p>如果我们再次运行相同的变更，数据将会被覆盖，并且不会创建新的<code>uid</code>。请注意，当再次执行变更时，结果中的<code>uid</code>映射为空，并且数据映射(键<code>q</code>)包含在前一个<code>upsert</code>中创建的<code>uid</code>：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [
      {
        &quot;uid&quot;: &quot;0x1&quot;,
        &quot;name&quot;: &quot;first last&quot;
      }
    ],
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {}
  },
  &quot;extensions&quot;: {...}
}
</code></pre>
<p>我们可以实现相同的结果使用<code>json</code>数据集如下：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d '
{
  &quot;query&quot;: &quot;{ q(func: eq(email, \&quot;user@company1.io\&quot;)) {v as uid, name} }&quot;,
  &quot;set&quot;: {
    &quot;uid&quot;: &quot;uid(v)&quot;,
    &quot;name&quot;: &quot;first last&quot;,
    &quot;email&quot;: &quot;user@company1.io&quot;
  }
}' | jq
</code></pre>
<p>现在，我们想为拥有相同电子邮件user@company1.io的相同用户添加年龄信息。我们可以使用upsert块做如下相同的事情：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
upsert {
  query {
    q(func: eq(email, &quot;user@company1.io&quot;)) {
      v as uid
    }
  }

  mutation {
    set {
      uid(v) &lt;age&gt; &quot;28&quot; .
    }
  }
}' | jq
</code></pre>
<p>返回结果：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q&quot;: [
      {
        &quot;uid&quot;: &quot;0x1&quot;
      }
    ],
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {}
  },
  &quot;extensions&quot;: {...}
}
</code></pre>
<p>在这里，查询块查询电子邮件为user@company1.io的用户。它将用户的uid存储在变量v中，然后突变块使用uid函数从变量v中提取uid，从而更新用户的年龄。</p>
<p>我们可以实现相同的结果使用json数据集如下：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
{
  &quot;query&quot;: &quot;{ q(func: eq(email, \\&quot;user@company1.io\\&quot;)) {v as uid} }&quot;,
  &quot;set&quot;:{
    &quot;uid&quot;: &quot;uid(v)&quot;,
    &quot;age&quot;: &quot;28&quot;
  }
}' | jq
</code></pre>
<p>如果我们只想在用户存在的时候执行变更，我们可以使用<a href="dql/mutations/./conditional_upsert.html">条件Upsert</a>。</p>
<h2 id="val-函数示例"><a class="header" href="#val-函数示例"><code>val</code> 函数示例</a></h2>
<p>假设我们想把断言年龄迁移到其他年龄。我们可以使用以下突变来做到这一点：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
upsert {
  query {
    v as var(func: has(age)) {
      a as age
    }
  }

  mutation {
    # we copy the values from the old predicate
    set {
      uid(v) &lt;other&gt; val(a) .
    }

    # and we delete the old predicate
    delete {
      uid(v) &lt;age&gt; * .
    }
  }
}' | jq
</code></pre>
<p>返回结果：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {}
  },
  &quot;extensions&quot;: {...}
}
</code></pre>
<p>在这里，变量<code>a</code>将存储从所有<code>uid</code>到其年龄的映射。然后，变更块将每个<code>UID</code>对应的年龄值存储在另一个谓词中，并删除年龄谓词。</p>
<p>我们可以实现相同的结果使用json数据集如下：</p>
<pre><code class="language-json">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d $'{
  &quot;query&quot;: &quot;{ v as var(func: regexp(email, /.*@company1.io$/)) }&quot;,
  &quot;delete&quot;: {
    &quot;uid&quot;: &quot;uid(v)&quot;,
    &quot;age&quot;: null
  },
  &quot;set&quot;: {
    &quot;uid&quot;: &quot;uid(v)&quot;,
    &quot;other&quot;: &quot;val(a)&quot;
  }
}' | jq
</code></pre>
<h2 id="批量删除示例-bulk-delete-exmaple"><a class="header" href="#批量删除示例-bulk-delete-exmaple">批量删除示例 (Bulk Delete Exmaple)</a></h2>
<p>假设我们想从数据库中删除company1的所有用户。这可以通过upsert块在一个查询中实现，如下所示：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
upsert {
  query {
    v as var(func: regexp(email, /.*@company1.io$/))
  }

  mutation {
    delete {
      uid(v) &lt;name&gt; * .
      uid(v) &lt;email&gt; * .
      uid(v) &lt;age&gt; * .
    }
  }
}' | jq
</code></pre>
<p>我们可以实现相同的结果使用json数据集如下：</p>
<pre><code class="language-json">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d '{
  &quot;query&quot;: &quot;{ v as var(func: regexp(email, /.*@company1.io$/)) }&quot;,
  &quot;delete&quot;: {
    &quot;uid&quot;: &quot;uid(v)&quot;,
    &quot;name&quot;: null,
    &quot;email&quot;: null,
    &quot;age&quot;: null
  }
}' | jq
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件插入"><a class="header" href="#条件插入">条件插入</a></h1>
<p>插入块(upsert block)支持使用<code>@if</code>指令指定一个条件变更块(mutation block)。这个变更块只有在指定的条件为<code>true</code>时才会执行。如果指定的条件是<code>false</code>，<code>Dgraph</code>会静默忽略该变更块(mutation block)，通常一个条件变更块有下面这样的结构：</p>
<pre><code class="language-dql">upsert {
  query &lt;query block&gt;
  [fragment &lt;fragment block&gt;]
  mutation [@if(&lt;condition&gt;)] &lt;mutation block 1&gt;
  [mutation [@if(&lt;condition&gt;)] &lt;mutation block 2&gt;]
  ...
}
</code></pre>
<p><code>@if</code>指令接受一个定义在查询块(query block)的条件变量，里面的条件变量能够和<code>AND</code> <code>OR</code> <code>NOT</code> 一起使用。</p>
<h2 id="一个使用条件插入的小例子"><a class="header" href="#一个使用条件插入的小例子">一个使用条件插入的小例子</a></h2>
<p>假设在我们之前的例子中，我们知道公司1的员工少于100人。为了安全起见，我们希望只在变量v中存储的uid小于100但大于50时才执行变异。这可以实现如下：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d  $'
upsert {
  query {
    v as var(func: regexp(email, /.*@company1.io$/))
  }

  mutation @if(lt(len(v), 100) AND gt(len(v), 50)) {
    delete {
      uid(v) &lt;name&gt; * .
      uid(v) &lt;email&gt; * .
      uid(v) &lt;age&gt; * .
    }
  }
}' | jq
</code></pre>
<p>我们可以实现相同的结果使用json数据集如下：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d '{
  &quot;query&quot;: &quot;{ v as var(func: regexp(email, /.*@company1.io$/)) }&quot;,
  &quot;cond&quot;: &quot;@if(lt(len(v), 100) AND gt(len(v), 50))&quot;,
  &quot;delete&quot;: {
    &quot;uid&quot;: &quot;uid(v)&quot;,
    &quot;name&quot;: null,
    &quot;email&quot;: null,
    &quot;age&quot;: null
  }
}' | jq
</code></pre>
<h2 id="关于多变更块的小例子"><a class="header" href="#关于多变更块的小例子">关于多变更块的小例子</a></h2>
<p>考虑以下<code>Schema</code>的一个例子：</p>
<pre><code class="language-bash">curl localhost:8080/alter -X POST -d $'
  name: string @index(term) .
  email: [string] @index(exact) @upsert .' | jq
</code></pre>
<p>假设，我们的数据库中存储了许多用户，每个用户都有一个或多个电子邮件地址。现在，我们得到了属于同一用户的两个电子邮件地址。如果电子邮件地址属于数据库中的不同节点，我们希望删除现有节点，并创建一个新节点，将这两个电子邮件都附加到这个新节点。否则，我们将使用这两个电子邮件创建/更新新的/现有节点。</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/rdf&quot; -X POST localhost:8080/mutate?commitNow=true -d $'
upsert {
  query {
    # filter is needed to ensure that we do not get same UIDs in u1 and u2
    q1(func: eq(email, &quot;user_email1@company1.io&quot;)) @filter(not(eq(email, &quot;user_email2@company1.io&quot;))) {
      u1 as uid
    }

    q2(func: eq(email, &quot;user_email2@company1.io&quot;)) @filter(not(eq(email, &quot;user_email1@company1.io&quot;))) {
      u2 as uid
    }

    q3(func: eq(email, &quot;user_email1@company1.io&quot;)) @filter(eq(email, &quot;user_email2@company1.io&quot;)) {
      u3 as uid
    }
  }

  # case when both emails do not exist
  mutation @if(eq(len(u1), 0) AND eq(len(u2), 0) AND eq(len(u3), 0)) {
    set {
      _:user &lt;name&gt; &quot;user&quot; .
      _:user &lt;dgraph.type&gt; &quot;Person&quot; .
      _:user &lt;email&gt; &quot;user_email1@company1.io&quot; .
      _:user &lt;email&gt; &quot;user_email2@company1.io&quot; .
    }
  }

  # case when email1 exists but email2 does not
  mutation @if(eq(len(u1), 1) AND eq(len(u2), 0) AND eq(len(u3), 0)) {
    set {
      uid(u1) &lt;email&gt; &quot;user_email2@company1.io&quot; .
    }
  }

  # case when email1 does not exist but email2 exists
  mutation @if(eq(len(u1), 0) AND eq(len(u2), 1) AND eq(len(u3), 0)) {
    set {
      uid(u2) &lt;email&gt; &quot;user_email1@company1.io&quot; .
    }
  }

  # case when both emails exist and needs merging
  mutation @if(eq(len(u1), 1) AND eq(len(u2), 1) AND eq(len(u3), 0)) {
    set {
      _:user &lt;name&gt; &quot;user&quot; .
      _:user &lt;dgraph.type&gt; &quot;Person&quot; .
      _:user &lt;email&gt; &quot;user_email1@company1.io&quot; .
      _:user &lt;email&gt; &quot;user_email2@company1.io&quot; .
    }

    delete {
      uid(u1) &lt;name&gt; * .
      uid(u1) &lt;email&gt; * .
      uid(u2) &lt;name&gt; * .
      uid(u2) &lt;email&gt; * .
    }
  }
}' | jq
</code></pre>
<p>返回结果(当数据库都为空时)：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q1&quot;: [],
    &quot;q2&quot;: [],
    &quot;q3&quot;: [],
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {
      &quot;user&quot;: &quot;0x1&quot;
    }
  },
  &quot;extensions&quot;: {...}
}
</code></pre>
<p>返回结果(两个邮件都存在，并附加到不同的节点)：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q1&quot;: [
      {
        &quot;uid&quot;: &quot;0x2&quot;
      }
    ],
    &quot;q2&quot;: [
      {
        &quot;uid&quot;: &quot;0x3&quot;
      }
    ],
    &quot;q3&quot;: [],
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {
      &quot;user&quot;: &quot;0x4&quot;
    }
  },
  &quot;extensions&quot;: {...}
}
</code></pre>
<p>返回结果(当两个电子邮件存在并且已经附加到同一个节点)：</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;q1&quot;: [],
    &quot;q2&quot;: [],
    &quot;q3&quot;: [
      {
        &quot;uid&quot;: &quot;0x4&quot;
      }
    ],
    &quot;code&quot;: &quot;Success&quot;,
    &quot;message&quot;: &quot;Done&quot;,
    &quot;uids&quot;: {}
  },
  &quot;extensions&quot;: {...}
}
</code></pre>
<p>我们可以实现相同的结果使用json数据集如下：</p>
<pre><code class="language-bash">curl -H &quot;Content-Type: application/json&quot; -X POST localhost:8080/mutate?commitNow=true -d '{
  &quot;query&quot;: &quot;{q1(func: eq(email, \&quot;user_email1@company1.io\&quot;)) @filter(not(eq(email, \&quot;user_email2@company1.io\&quot;))) {u1 as uid} \n q2(func: eq(email, \&quot;user_email2@company1.io\&quot;)) @filter(not(eq(email, \&quot;user_email1@company1.io\&quot;))) {u2 as uid} \n q3(func: eq(email, \&quot;user_email1@company1.io\&quot;)) @filter(eq(email, \&quot;user_email2@company1.io\&quot;)) {u3 as uid}}&quot;,
  &quot;mutations&quot;: [
    {
      &quot;cond&quot;: &quot;@if(eq(len(u1), 0) AND eq(len(u2), 0) AND eq(len(u3), 0))&quot;,
      &quot;set&quot;: [
        {
          &quot;uid&quot;: &quot;_:user&quot;,
          &quot;name&quot;: &quot;user&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        },
        {
          &quot;uid&quot;: &quot;_:user&quot;,
          &quot;email&quot;: &quot;user_email1@company1.io&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        },
        {
          &quot;uid&quot;: &quot;_:user&quot;,
          &quot;email&quot;: &quot;user_email2@company1.io&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        }
      ]
    },
    {
      &quot;cond&quot;: &quot;@if(eq(len(u1), 1) AND eq(len(u2), 0) AND eq(len(u3), 0))&quot;,
      &quot;set&quot;: [
        {
          &quot;uid&quot;: &quot;uid(u1)&quot;,
          &quot;email&quot;: &quot;user_email2@company1.io&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        }
      ]
    },
    {
      &quot;cond&quot;: &quot;@if(eq(len(u1), 1) AND eq(len(u2), 0) AND eq(len(u3), 0))&quot;,
      &quot;set&quot;: [
        {
          &quot;uid&quot;: &quot;uid(u2)&quot;,
          &quot;email&quot;: &quot;user_email1@company1.io&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        }
      ]
    },
    {
      &quot;cond&quot;: &quot;@if(eq(len(u1), 1) AND eq(len(u2), 1) AND eq(len(u3), 0))&quot;,
      &quot;set&quot;: [
        {
          &quot;uid&quot;: &quot;_:user&quot;,
          &quot;name&quot;: &quot;user&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        },
        {
          &quot;uid&quot;: &quot;_:user&quot;,
          &quot;email&quot;: &quot;user_email1@company1.io&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        },
        {
          &quot;uid&quot;: &quot;_:user&quot;,
          &quot;email&quot;: &quot;user_email2@company1.io&quot;,
          &quot;dgraph.type&quot;: &quot;Person&quot;
        }
      ],
      &quot;delete&quot;: [
        {
          &quot;uid&quot;: &quot;uid(u1)&quot;,
          &quot;name&quot;: null,
          &quot;email&quot;: null
        },
        {
          &quot;uid&quot;: &quot;uid(u2)&quot;,
          &quot;name&quot;: null,
          &quot;email&quot;: null
        }
      ]
    }
  ]
}' | jq
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反向边-reverse-edges"><a class="header" href="#反向边-reverse-edges">反向边 (reverse edges)</a></h1>
<p><code>Dgraph</code>中的任何出边(<code>outgoing edge</code>)都可以使用<code>Schema</code>中的<code>@reverse</code>指令反向，并使用波浪号作为边名的前缀来查询。例如<code>&lt;~myEdge&gt;</code>。</p>
<p><code>Dgraph</code>是有向图模型，这意味着所有属性总是在一个方向上从一个实体指向另一个实体或值，即<code>S P -&gt; O</code>。</p>
<p>反向边是自动生成的边，不属于你的数据集的一部分。这意味着您不能直接在反向边上提交变更。改变正向边将会自动更新反向边的值。</p>
<p><strong>正确地使用反向边</strong></p>
<p>在<code>RDF</code>中，三元组的排列已经定义了可以逆转的内容：</p>
<pre><code class="language-rdf">_:MyObject &lt;myEdge&gt; _:BlankNode  . #反向边正确的语法
_:BlankNode &lt;dgraph.type&gt; &quot;Person&quot; .
</code></pre>
<p>纠正和应用反向边的最简单方法是使用<code>JSON</code>。它只是将<code>Schema</code>上的指令放在所需的边上。在构建你的变更时，请记住<code>JSON</code>中没有反向边相关的语法。因此，您应该做的事情与<code>RDF</code>类似：更改<code>JSON</code>对象的排列。</p>
<p>因为<code>MyObject</code>实体在<code>Person</code>实体之上，所以在格式化变更时，<code>MyObject</code>必须在前面：</p>
<pre><code class="language-json">{
   &quot;set&quot;: [
      {
         &quot;uid&quot;: &quot;_:MyObject&quot;,
         &quot;dgraph.type&quot;: &quot;Object&quot;,
         &quot;myEdge&quot;: {
            &quot;uid&quot;: &quot;_:BlankNode&quot;,
            &quot;dgraph.type&quot;: &quot;Person&quot;
         }
      }
   ]
}
</code></pre>
<p>另一种方法是分割成一些小块或小批，并使用空白节点作为引用。这有助于组织和重用引用：</p>
<pre><code class="language-json">{
   &quot;set&quot;: [
      {
         &quot;uid&quot;: &quot;_:MyObject&quot;,
         &quot;dgraph.type&quot;: &quot;Object&quot;,
         &quot;myEdge&quot;: [{&quot;uid&quot;: &quot;_:BlankNode&quot;}]
      },
      {
         &quot;uid&quot;: &quot;_:BlankNode&quot;,
         &quot;dgraph.type&quot;: &quot;Person&quot;
      }
   ]
}
</code></pre>
<h2 id="更多的关于反向边的小例子"><a class="header" href="#更多的关于反向边的小例子">更多的关于反向边的小例子</a></h2>
<p>在<code>RDF</code>中，想要正确地使用反向边非常简单：</p>
<pre><code class="language-rdf">name: String .
husband: uid @reverse .
wife: uid @reverse .
parent: [uid] @reverse .
</code></pre>
<pre><code class="language-schema">{
  set {
    _:Megalosaurus &lt;name&gt; &quot;Earl Sneed Sinclair&quot; .
    _:Megalosaurus &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:Megalosaurus &lt;wife&gt; _:Allosaurus .
    _:Allosaurus &lt;name&gt; &quot;Francis Johanna Phillips Sinclair&quot; (short=&quot;Fran&quot;) .
    _:Allosaurus &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:Allosaurus &lt;husband&gt; _:Megalosaurus .
    _:Hypsilophodon &lt;name&gt; &quot;Robert Mark Sinclair&quot; (short=&quot;Robbie&quot;) .
    _:Hypsilophodon &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:Hypsilophodon &lt;parent&gt; _:Allosaurus (role=&quot;son&quot;) .
    _:Hypsilophodon &lt;parent&gt; _:Megalosaurus (role=&quot;son&quot;) .
    _:Protoceratops &lt;name&gt; &quot;Charlene Fiona Sinclair&quot; .
    _:Protoceratops &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:Protoceratops &lt;parent&gt; _:Allosaurus (role=&quot;daughter&quot;) .
    _:Protoceratops &lt;parent&gt; _:Megalosaurus (role=&quot;daughter&quot;) .
    _:MegalosaurusBaby &lt;name&gt; &quot;Baby Sinclair&quot; (short=&quot;Baby&quot;) .
    _:MegalosaurusBaby &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:MegalosaurusBaby &lt;parent&gt; _:Allosaurus (role=&quot;son&quot;) .
    _:MegalosaurusBaby &lt;parent&gt; _:Megalosaurus (role=&quot;son&quot;) .
  }
}
</code></pre>
<p>边的方向应该如下：</p>
<pre><code class="language-text">Exchanged hierarchy:
 Object -&gt; Parent;
 Object &lt;~ Parent; #Reverse
 Children to parents via &quot;parent&quot; edge.
 wife and husband bidirectional using reverse.
Normal hierarchy:
 Parent -&gt; Object;
 Parent &lt;~ Object; #Reverse
 This hierarchy is not part of the example, but is generally used in all graph models.
 To make this hierarchy we need to bring the hierarchical relationship starting from the parents and not from the children. Instead of using the edges &quot;wife&quot; and &quot;husband&quot; we switch to single edge called &quot;married&quot; to simplify the model.
    _:Megalosaurus &lt;name&gt; &quot;Earl Sneed Sinclair&quot; .
    _:Megalosaurus &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:Megalosaurus &lt;married&gt; _:Allosaurus .
    _:Megalosaurus &lt;parent&gt; _:Hypsilophodon (role=&quot;son&quot;) .
    _:Megalosaurus &lt;parent&gt; _:Protoceratops (role=&quot;daughter&quot;) .
    _:Megalosaurus &lt;parent&gt; _:MegalosaurusBaby (role=&quot;son&quot;) .
    _:Allosaurus &lt;name&gt; &quot;Francis Johanna Phillips Sinclair&quot; (short=&quot;Fran&quot;) .
    _:Allosaurus &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:Allosaurus &lt;married&gt; _:Megalosaurus .
    _:Allosaurus &lt;parent&gt; _:Hypsilophodon (role=&quot;son&quot;) .
    _:Allosaurus &lt;parent&gt; _:Protoceratops (role=&quot;daughter&quot;) .
    _:Allosaurus &lt;parent&gt; _:MegalosaurusBaby (role=&quot;son&quot;) .
</code></pre>
<h2 id="查询-1"><a class="header" href="#查询-1">查询</a></h2>
<ol>
<li><code>wife_husband</code>是<code>wife</code>的反向边。</li>
<li><code>husband</code>是一条正常的正向边。</li>
</ol>
<pre><code class="language-dql">{
  q(func: has(wife)) {
    name
    WF as wife {
      name
    }
  }
  reverseIt(func: uid(WF)) {
    name
    wife_husband : ~wife {
      name
    }
    husband {
      name
    }
  }
}
</code></pre>
<ol>
<li><code>Children</code> 是 <code>parent</code> 的反向边：</li>
</ol>
<pre><code class="language-dql">{
  q(func: has(name)) @filter(eq(name, &quot;Earl Sneed Sinclair&quot;)){
    name
    Children : ~parent @facets {
      name
    }
  }
}
</code></pre>
<h2 id="反向边和-facet"><a class="header" href="#反向边和-facet">反向边和 facet</a></h2>
<p>反向边上的<code>facet</code>与正向边上的相同。也就是说，如果您在一条边上设置或更新一个<code>facet</code>，那么它的反向边将具有相同的<code>facet</code>：</p>
<pre><code class="language-dql">{
  set {
    _:Megalosaurus &lt;name&gt; &quot;Earl Sneed Sinclair&quot; .
    _:Megalosaurus &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:Megalosaurus &lt;wife&gt; _:Allosaurus .
    _:Megalosaurus &lt;parent&gt; _:MegalosaurusBaby (role=&quot;parent -&gt; child&quot;) .
    _:MegalosaurusBaby &lt;name&gt; &quot;Baby Sinclair&quot; (short=&quot;Baby -&gt; parent&quot;) .
    _:MegalosaurusBaby &lt;dgraph.type&gt; &quot;Dinosaur&quot; .
    _:MegalosaurusBaby &lt;parent&gt; _:Megalosaurus (role=&quot;child -&gt; parent&quot;) .
  }
}
</code></pre>
<p>使用前面例子中的类似查询：</p>
<pre><code class="language-dql">{
  Parent(func: has(name)) @filter(eq(name, &quot;Earl Sneed Sinclair&quot;)){
    name
    C as Children : parent @facets {
      name
    }
  }
    Child(func: uid(C)) {
      name
      parent @facets {
        name
      }
    }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;Parent&quot;: [
      {
        &quot;name&quot;: &quot;Earl Sneed Sinclair&quot;,
        &quot;Children&quot;: [
          {
            &quot;name&quot;: &quot;Baby Sinclair&quot;,
            &quot;Children|role&quot;: &quot;parent -&gt; child&quot;
          }
        ]
      }
    ],
    &quot;Child&quot;: [
      {
        &quot;name&quot;: &quot;Baby Sinclair&quot;,
        &quot;parent&quot;: [
          {
            &quot;name&quot;: &quot;Earl Sneed Sinclair&quot;,
            &quot;parent|role&quot;: &quot;child -&gt; parent&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="数据加密"><a class="header" href="#数据加密">数据加密</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="检索调试信息"><a class="header" href="#检索调试信息">检索调试信息</a></h1>
<p>每个<code>Dgraph</code>数据节点都在<code>/debug/pprof</code>端点上公开概要文件，在<code>/debug/vars</code>端点上公开度量。每个Dgraph数据节点都有自己的分析和度量信息。下面是Dgraph公开的调试信息列表，以及检索这些信息的相应命令。</p>
<h2 id="metrics-信息"><a class="header" href="#metrics-信息">Metrics 信息</a></h2>
<p>如果想从<code>Dgraph</code>实例外部收集这些<code>Metrics</code>信息，则需要在<code>Alpha</code>启动时传递<code>--expose_trace=true</code>标志，否则仅可以通过<code>localhost</code>收集<code>metrics</code>信息。</p>
<pre><code class="language-bash">curl http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/vars
</code></pre>
<p><code>Metrics</code>信息也能在<code>/debug/promethus_metrics</code>通过<code>Promethus</code>的格式检索。详情查看<a href="https://dgraph.io/docs/deploy/metrics/">链接</a></p>
<h2 id="性能信息"><a class="header" href="#性能信息">性能信息</a></h2>
<p>性能信息能够通过<code>GO</code>内建的工具<code>go tool pprof</code>查看，可以浏览<a href="https://blog.golang.org/profiling-go-programs">这篇帖子</a>关于<code>pprof</code>工具的使用。</p>
<p>每一个<code>Dgraph Alpha</code>和<code>Dgraph Zero</code>都会通过<code>HTTP</code>端口在<code>/debug/pprof/&lt;profile&gt;</code>暴露性能信息：</p>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/heap
Fetching profile from ...
Saved Profile in ...
</code></pre>
<p>上面的命令运行成功之后将输出性能信息的保存位置。</p>
<p>在交互式的pprof shell中，你可以使用像top这样的命令来获取配置文件中top函数的列表，web命令来获取在web浏览器中打开的配置文件的可视化图形，或者list命令来显示覆盖了配置信息的代码列表。</p>
<h2 id="cpu-profile"><a class="header" href="#cpu-profile">CPU Profile</a></h2>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/profile
</code></pre>
<h2 id="内存-profile"><a class="header" href="#内存-profile">内存 Profile</a></h2>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/heap
</code></pre>
<h2 id="块-profile"><a class="header" href="#块-profile">块 Profile</a></h2>
<p>默认情况下，Dgraph不收集块配置文件。Dgraph必须以——profile_mode=block和——block_rate=<n>和N&gt; 1开始。</n></p>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/block
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="检索调试信息-1"><a class="header" href="#检索调试信息-1">检索调试信息</a></h1>
<p>每个<code>Dgraph</code>数据节点都在<code>/debug/pprof</code>端点上公开概要文件，在<code>/debug/vars</code>端点上公开度量。每个Dgraph数据节点都有自己的分析和度量信息。下面是Dgraph公开的调试信息列表，以及检索这些信息的相应命令。</p>
<h2 id="metrics-信息-1"><a class="header" href="#metrics-信息-1">Metrics 信息</a></h2>
<p>如果想从<code>Dgraph</code>实例外部收集这些<code>Metrics</code>信息，则需要在<code>Alpha</code>启动时传递<code>--expose_trace=true</code>标志，否则仅可以通过<code>localhost</code>收集<code>metrics</code>信息。</p>
<pre><code class="language-bash">curl http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/vars
</code></pre>
<p><code>Metrics</code>信息也能在<code>/debug/promethus_metrics</code>通过<code>Promethus</code>的格式检索。详情查看<a href="https://dgraph.io/docs/deploy/metrics/">链接</a></p>
<h2 id="性能信息-1"><a class="header" href="#性能信息-1">性能信息</a></h2>
<p>性能信息能够通过<code>GO</code>内建的工具<code>go tool pprof</code>查看，可以浏览<a href="https://blog.golang.org/profiling-go-programs">这篇帖子</a>关于<code>pprof</code>工具的使用。</p>
<p>每一个<code>Dgraph Alpha</code>和<code>Dgraph Zero</code>都会通过<code>HTTP</code>端口在<code>/debug/pprof/&lt;profile&gt;</code>暴露性能信息：</p>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/heap
Fetching profile from ...
Saved Profile in ...
</code></pre>
<p>上面的命令运行成功之后将输出性能信息的保存位置。</p>
<p>在交互式的pprof shell中，你可以使用像top这样的命令来获取配置文件中top函数的列表，web命令来获取在web浏览器中打开的配置文件的可视化图形，或者list命令来显示覆盖了配置信息的代码列表。</p>
<h2 id="cpu-profile-1"><a class="header" href="#cpu-profile-1">CPU Profile</a></h2>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/profile
</code></pre>
<h2 id="内存-profile-1"><a class="header" href="#内存-profile-1">内存 Profile</a></h2>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/heap
</code></pre>
<h2 id="块-profile-1"><a class="header" href="#块-profile-1">块 Profile</a></h2>
<p>默认情况下，Dgraph不收集块配置文件。Dgraph必须以——profile_mode=block和——block_rate=<n>和N&gt; 1开始。</n></p>
<pre><code class="language-bash">go tool pprof http://&lt;IP&gt;:&lt;HTTP_PORT&gt;/debug/pprof/block
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="原则"><a class="header" href="#原则">原则</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原则-1"><a class="header" href="#原则-1">原则</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版本更新"><a class="header" href="#版本更新">版本更新</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://0.0.0.0:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
